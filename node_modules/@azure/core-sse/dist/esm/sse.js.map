{"version":3,"file":"sse.js","sourceRoot":"","sources":["../../src/sse.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { IncomingMessage } from \"node:http\";\nimport { EventMessage, EventMessageStream, PartialSome } from \"./models.js\";\nimport { createStream, ensureAsyncIterable } from \"./utils.js\";\n\nenum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\n/**\n * Processes a response stream into a stream of events.\n * @param chunkStream - A stream of Uint8Array chunks\n * @returns An async iterable of EventMessage objects\n */\nexport function createSseStream(chunkStream: ReadableStream<Uint8Array>): EventMessageStream;\n/**\n * Processes a response stream into a stream of events.\n * @param chunkStream - An async iterable of Uint8Array chunks\n * @returns An async iterable of EventMessage objects\n */\nexport function createSseStream(chunkStream: IncomingMessage): EventMessageStream;\nexport function createSseStream(\n  chunkStream: IncomingMessage | ReadableStream<Uint8Array>,\n): EventMessageStream {\n  const { cancel, iterable } = ensureAsyncIterable(chunkStream);\n  const asyncIter = toMessage(toLine(iterable));\n  return createStream(asyncIter, cancel);\n}\n\nfunction concatBuffer(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\n\nfunction createMessage(): PartialSome<EventMessage, \"data\"> {\n  return {\n    data: undefined,\n    event: \"\",\n    id: \"\",\n    retry: undefined,\n  };\n}\n\nasync function* toLine(\n  chunkIter: AsyncIterable<Uint8Array>,\n): AsyncIterable<{ line: Uint8Array; fieldLen: number }> {\n  let buf: Uint8Array | undefined;\n  let bufIdx = 0;\n  let fieldLen = -1;\n  let discardTrailingNewline = false;\n  for await (const chunk of chunkIter) {\n    if (buf === undefined) {\n      buf = chunk;\n      bufIdx = 0;\n      fieldLen = -1;\n    } else {\n      buf = concatBuffer(buf, chunk);\n    }\n    const bufLen = buf.length;\n    let start = 0;\n    while (bufIdx < bufLen) {\n      if (discardTrailingNewline) {\n        if (buf[bufIdx] === ControlChars.NewLine) {\n          start = ++bufIdx;\n        }\n        discardTrailingNewline = false;\n      }\n      let end = -1;\n      for (; bufIdx < bufLen && end === -1; ++bufIdx) {\n        switch (buf[bufIdx]) {\n          case ControlChars.Colon:\n            if (fieldLen === -1) {\n              fieldLen = bufIdx - start;\n            }\n            break;\n          case ControlChars.CarriageReturn:\n            // We need to discard the trailing newline if any but can't do\n            // that now because we need to dispatch the current line first.\n            discardTrailingNewline = true;\n            end = bufIdx;\n            break;\n          case ControlChars.NewLine:\n            end = bufIdx;\n            break;\n        }\n      }\n      if (end === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next chunk and then continue parsing:\n        break;\n      }\n      yield { line: buf.subarray(start, end), fieldLen };\n      start = bufIdx; // we're now on the next line\n      fieldLen = -1;\n    }\n    if (start === bufLen) {\n      buf = undefined;\n    } else if (start !== 0) {\n      // discard already processed lines\n      buf = buf.subarray(start);\n      bufIdx -= start;\n    }\n  }\n}\n\nasync function* toMessage(\n  lineIter: AsyncIterable<{ line: Uint8Array; fieldLen: number }>,\n): AsyncIterableIterator<EventMessage> {\n  let message = createMessage();\n  const decoder = new TextDecoder();\n  for await (const { line, fieldLen } of lineIter) {\n    if (line.length === 0 && message.data !== undefined) {\n      // empty line denotes end of message. Yield and start a new message:\n      yield message as EventMessage;\n      message = createMessage();\n    } else if (fieldLen > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLen));\n      const valueOffset = fieldLen + (line[fieldLen + 1] === ControlChars.Space ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          message.id = value;\n          break;\n        case \"retry\": {\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            message.retry = retry;\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n"]}