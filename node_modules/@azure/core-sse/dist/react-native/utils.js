// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
export function createStream(asyncIter, cancel) {
    const stream = iteratorToStream(asyncIter, cancel);
    /** TODO: remove these polyfills once all supported runtimes support them */
    return polyfillStream(stream, cancel);
}
function polyfillStream(stream, dispose) {
    makeAsyncIterable(stream);
    makeAsyncDisposable(stream, dispose);
    return stream;
}
function makeAsyncDisposable(webStream, dispose) {
    Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
    if (!webStream[Symbol.asyncDispose]) {
        webStream[Symbol.asyncDispose] = () => dispose();
    }
}
function makeAsyncIterable(webStream) {
    if (!webStream[Symbol.asyncIterator]) {
        webStream[Symbol.asyncIterator] = () => toAsyncIterable(webStream);
    }
    if (!webStream.values) {
        webStream.values = () => toAsyncIterable(webStream);
    }
}
function iteratorToStream(iterator, cancel) {
    return new ReadableStream({
        async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
                controller.close();
            }
            else {
                controller.enqueue(value);
            }
        },
        cancel,
    });
}
export function ensureAsyncIterable(stream) {
    if (isReadableStream(stream)) {
        makeAsyncIterable(stream);
        return {
            cancel: () => stream.cancel(),
            iterable: stream,
        };
    }
    else {
        return {
            cancel: async () => {
                stream.socket.end();
            },
            iterable: stream,
        };
    }
}
function isReadableStream(body) {
    return Boolean(body &&
        typeof body.getReader === "function" &&
        typeof body.tee === "function");
}
async function* toAsyncIterable(stream) {
    const reader = stream.getReader();
    try {
        while (true) {
            const { value, done } = await reader.read();
            if (done) {
                return;
            }
            yield value;
        }
    }
    finally {
        const cancelPromise = reader.cancel();
        reader.releaseLock();
        await cancelPromise;
    }
}
//# sourceMappingURL=utils.js.map