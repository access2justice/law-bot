// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import GeographyPoint from "./geographyPoint";
const ISO8601DateRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{1,3})?Z$/i;
const GeoJSONPointTypeName = "Point";
const WorldGeodeticSystem1984 = "EPSG:4326"; // See https://epsg.io/4326
export function serialize(obj) {
    return walk(obj, (value) => {
        const result = serializeSpecialNumbers(value);
        return result;
    });
}
export function deserialize(obj) {
    return walk(obj, (value) => {
        let result = deserializeSpecialNumbers(value);
        result = deserializeDates(result);
        result = deserializeGeoPoint(result);
        return result;
    });
}
function walk(start, mapper) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    const seenMarker = new WeakMap();
    const result = { value: undefined };
    const queue = [
        { value: start, parent: result, key: "value" },
    ];
    while (queue.length) {
        const current = queue.shift();
        if (typeof current.value === "object" && current.value !== null) {
            if (seenMarker.has(current.value)) {
                continue;
            }
            else {
                seenMarker.set(current.value, true);
            }
        }
        const mapped = mapper(current.value);
        if ((current === null || current === void 0 ? void 0 : current.parent) && current.key) {
            current.parent[current.key] = mapped;
        }
        if (typeof mapped === "object" && mapped !== null) {
            for (const key of Object.keys(mapped)) {
                queue.push({
                    value: mapped[key],
                    parent: mapped,
                    key,
                });
            }
        }
    }
    return result.value;
}
function serializeSpecialNumbers(input) {
    if (typeof input === "number") {
        if (isNaN(input)) {
            return "NaN";
        }
        else if (input === Infinity) {
            return "INF";
        }
        else if (input === -Infinity) {
            return "-INF";
        }
    }
    return input;
}
function deserializeSpecialNumbers(input) {
    if (typeof input === "string") {
        if (input === "NaN") {
            return NaN;
        }
        else if (input === "INF") {
            return Infinity;
        }
        else if (input === "-INF") {
            return -Infinity;
        }
    }
    return input;
}
function deserializeDates(input) {
    if (typeof input === "string") {
        if (ISO8601DateRegex.test(input)) {
            return new Date(input);
        }
    }
    return input;
}
function deserializeGeoPoint(input) {
    if (isGeoJSONPoint(input)) {
        return new GeographyPoint({ longitude: input.coordinates[0], latitude: input.coordinates[1] });
    }
    return input;
}
function isGeoJSONPoint(obj) {
    const requiredKeys = ["type", "coordinates"];
    return isValidObject(obj, {
        requiredKeys,
        propertyValidator: (key) => {
            switch (key) {
                case "type":
                    return obj.type === GeoJSONPointTypeName;
                    break;
                case "coordinates":
                    return isCoordinateArray(obj.coordinates);
                    break;
                case "crs":
                    return isCrs(obj.crs);
                    break;
                default:
                    return false;
            }
        },
    });
}
function isCoordinateArray(maybeCoordinates) {
    if (!Array.isArray(maybeCoordinates)) {
        return false;
    }
    if (maybeCoordinates.length !== 2) {
        return false;
    }
    if (typeof maybeCoordinates[0] !== "number" || typeof maybeCoordinates[1] !== "number") {
        return false;
    }
    return true;
}
function isCrs(maybeCrs) {
    return isValidObject(maybeCrs, {
        requiredKeys: ["type", "properties"],
        propertyValidator: (key) => {
            switch (key) {
                case "type":
                    return maybeCrs.type === "name";
                    break;
                case "properties":
                    return isCrsProperties(maybeCrs.properties);
                    break;
                default:
                    return false;
            }
        },
    });
}
function isCrsProperties(maybeProperties) {
    return isValidObject(maybeProperties, {
        requiredKeys: ["name"],
        propertyValidator: (key) => {
            if (key === "name") {
                return maybeProperties.name === WorldGeodeticSystem1984;
            }
            else {
                return false;
            }
        },
    });
}
function isValidObject(obj, options = {}) {
    if (typeof obj !== "object" || obj === null) {
        return false;
    }
    const keys = Object.keys(obj);
    if (options.requiredKeys) {
        for (const requiredKey of options.requiredKeys) {
            if (!keys.includes(requiredKey)) {
                return false;
            }
        }
    }
    if (options.propertyValidator) {
        for (const key of keys) {
            if (!options.propertyValidator(key)) {
                return false;
            }
        }
    }
    return true;
}
//# sourceMappingURL=serialization.js.map