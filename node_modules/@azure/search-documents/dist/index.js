'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreHttpCompat = require('@azure/core-http-compat');
var coreClient = require('@azure/core-client');
var coreAuth = require('@azure/core-auth');
var logger$1 = require('@azure/logger');
var coreTracing = require('@azure/core-tracing');
var EventEmitter = require('events');
var util = require('util');
var fs = require('fs');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreHttpCompat__namespace = /*#__PURE__*/_interopNamespaceDefault(coreHttpCompat);
var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);
var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const SearchError$1 = {
    type: {
        name: "Composite",
        className: "SearchError",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchError"
                        }
                    }
                }
            }
        }
    }
};
const SearchDocumentsResult = {
    type: {
        name: "Composite",
        className: "SearchDocumentsResult",
        modelProperties: {
            count: {
                serializedName: "@odata\\.count",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            coverage: {
                serializedName: "@search\\.coverage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            facets: {
                serializedName: "@search\\.facets",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Sequence",
                            element: { type: { name: "Composite", className: "FacetResult" } }
                        }
                    }
                }
            },
            answers: {
                serializedName: "@search\\.answers",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryAnswerResult"
                        }
                    }
                }
            },
            nextPageParameters: {
                serializedName: "@search\\.nextPageParameters",
                type: {
                    name: "Composite",
                    className: "SearchRequest"
                }
            },
            results: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@odata\\.nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            semanticPartialResponseReason: {
                serializedName: "@search\\.semanticPartialResponseReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            semanticPartialResponseType: {
                serializedName: "@search\\.semanticPartialResponseType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FacetResult = {
    type: {
        name: "Composite",
        className: "FacetResult",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            count: {
                serializedName: "count",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const QueryAnswerResult = {
    type: {
        name: "Composite",
        className: "QueryAnswerResult",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            score: {
                serializedName: "score",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            key: {
                serializedName: "key",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            highlights: {
                serializedName: "highlights",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchRequest = {
    type: {
        name: "Composite",
        className: "SearchRequest",
        modelProperties: {
            includeTotalResultCount: {
                serializedName: "count",
                type: {
                    name: "Boolean"
                }
            },
            facets: {
                serializedName: "facets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            highlightFields: {
                serializedName: "highlight",
                type: {
                    name: "String"
                }
            },
            highlightPostTag: {
                serializedName: "highlightPostTag",
                type: {
                    name: "String"
                }
            },
            highlightPreTag: {
                serializedName: "highlightPreTag",
                type: {
                    name: "String"
                }
            },
            minimumCoverage: {
                serializedName: "minimumCoverage",
                type: {
                    name: "Number"
                }
            },
            orderBy: {
                serializedName: "orderby",
                type: {
                    name: "String"
                }
            },
            queryType: {
                serializedName: "queryType",
                type: {
                    name: "Enum",
                    allowedValues: ["simple", "full", "semantic"]
                }
            },
            scoringStatistics: {
                serializedName: "scoringStatistics",
                type: {
                    name: "Enum",
                    allowedValues: ["local", "global"]
                }
            },
            sessionId: {
                serializedName: "sessionId",
                type: {
                    name: "String"
                }
            },
            scoringParameters: {
                serializedName: "scoringParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            scoringProfile: {
                serializedName: "scoringProfile",
                type: {
                    name: "String"
                }
            },
            searchText: {
                serializedName: "search",
                type: {
                    name: "String"
                }
            },
            searchFields: {
                serializedName: "searchFields",
                type: {
                    name: "String"
                }
            },
            searchMode: {
                serializedName: "searchMode",
                type: {
                    name: "Enum",
                    allowedValues: ["any", "all"]
                }
            },
            select: {
                serializedName: "select",
                type: {
                    name: "String"
                }
            },
            skip: {
                serializedName: "skip",
                type: {
                    name: "Number"
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            },
            semanticConfigurationName: {
                serializedName: "semanticConfiguration",
                type: {
                    name: "String"
                }
            },
            semanticErrorHandling: {
                serializedName: "semanticErrorHandling",
                type: {
                    name: "String"
                }
            },
            semanticMaxWaitInMilliseconds: {
                constraints: {
                    InclusiveMinimum: 700
                },
                serializedName: "semanticMaxWaitInMilliseconds",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            answers: {
                serializedName: "answers",
                type: {
                    name: "String"
                }
            },
            captions: {
                serializedName: "captions",
                type: {
                    name: "String"
                }
            },
            vectorQueries: {
                serializedName: "vectorQueries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VectorQuery"
                        }
                    }
                }
            },
            vectorFilterMode: {
                serializedName: "vectorFilterMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VectorQuery = {
    type: {
        name: "Composite",
        className: "VectorQuery",
        uberParent: "VectorQuery",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: {
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            },
            kNearestNeighborsCount: {
                serializedName: "k",
                type: {
                    name: "Number"
                }
            },
            fields: {
                serializedName: "fields",
                type: {
                    name: "String"
                }
            },
            exhaustive: {
                serializedName: "exhaustive",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SearchResult = {
    type: {
        name: "Composite",
        className: "SearchResult",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            _score: {
                serializedName: "@search\\.score",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            _rerankerScore: {
                serializedName: "@search\\.rerankerScore",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            _highlights: {
                serializedName: "@search\\.highlights",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Sequence", element: { type: { name: "String" } } }
                    }
                }
            },
            _captions: {
                serializedName: "@search\\.captions",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryCaptionResult"
                        }
                    }
                }
            }
        }
    }
};
const QueryCaptionResult = {
    type: {
        name: "Composite",
        className: "QueryCaptionResult",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            text: {
                serializedName: "text",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            highlights: {
                serializedName: "highlights",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SuggestDocumentsResult = {
    type: {
        name: "Composite",
        className: "SuggestDocumentsResult",
        modelProperties: {
            results: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SuggestResult"
                        }
                    }
                }
            },
            coverage: {
                serializedName: "@search\\.coverage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SuggestResult = {
    type: {
        name: "Composite",
        className: "SuggestResult",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            _text: {
                serializedName: "@search\\.text",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SuggestRequest = {
    type: {
        name: "Composite",
        className: "SuggestRequest",
        modelProperties: {
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            useFuzzyMatching: {
                serializedName: "fuzzy",
                type: {
                    name: "Boolean"
                }
            },
            highlightPostTag: {
                serializedName: "highlightPostTag",
                type: {
                    name: "String"
                }
            },
            highlightPreTag: {
                serializedName: "highlightPreTag",
                type: {
                    name: "String"
                }
            },
            minimumCoverage: {
                serializedName: "minimumCoverage",
                type: {
                    name: "Number"
                }
            },
            orderBy: {
                serializedName: "orderby",
                type: {
                    name: "String"
                }
            },
            searchText: {
                serializedName: "search",
                required: true,
                type: {
                    name: "String"
                }
            },
            searchFields: {
                serializedName: "searchFields",
                type: {
                    name: "String"
                }
            },
            select: {
                serializedName: "select",
                type: {
                    name: "String"
                }
            },
            suggesterName: {
                serializedName: "suggesterName",
                required: true,
                type: {
                    name: "String"
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const IndexBatch = {
    type: {
        name: "Composite",
        className: "IndexBatch",
        modelProperties: {
            actions: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IndexAction"
                        }
                    }
                }
            }
        }
    }
};
const IndexAction = {
    type: {
        name: "Composite",
        className: "IndexAction",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            __actionType: {
                serializedName: "@search\\.action",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["upload", "merge", "mergeOrUpload", "delete"]
                }
            }
        }
    }
};
const IndexDocumentsResult = {
    type: {
        name: "Composite",
        className: "IndexDocumentsResult",
        modelProperties: {
            results: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IndexingResult"
                        }
                    }
                }
            }
        }
    }
};
const IndexingResult = {
    type: {
        name: "Composite",
        className: "IndexingResult",
        modelProperties: {
            key: {
                serializedName: "key",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            succeeded: {
                serializedName: "status",
                required: true,
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutocompleteResult = {
    type: {
        name: "Composite",
        className: "AutocompleteResult",
        modelProperties: {
            coverage: {
                serializedName: "@search\\.coverage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            results: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutocompleteItem"
                        }
                    }
                }
            }
        }
    }
};
const AutocompleteItem = {
    type: {
        name: "Composite",
        className: "AutocompleteItem",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            queryPlusText: {
                serializedName: "queryPlusText",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutocompleteRequest = {
    type: {
        name: "Composite",
        className: "AutocompleteRequest",
        modelProperties: {
            searchText: {
                serializedName: "search",
                required: true,
                type: {
                    name: "String"
                }
            },
            autocompleteMode: {
                serializedName: "autocompleteMode",
                type: {
                    name: "Enum",
                    allowedValues: ["oneTerm", "twoTerms", "oneTermWithContext"]
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            useFuzzyMatching: {
                serializedName: "fuzzy",
                type: {
                    name: "Boolean"
                }
            },
            highlightPostTag: {
                serializedName: "highlightPostTag",
                type: {
                    name: "String"
                }
            },
            highlightPreTag: {
                serializedName: "highlightPreTag",
                type: {
                    name: "String"
                }
            },
            minimumCoverage: {
                serializedName: "minimumCoverage",
                type: {
                    name: "Number"
                }
            },
            searchFields: {
                serializedName: "searchFields",
                type: {
                    name: "String"
                }
            },
            suggesterName: {
                serializedName: "suggesterName",
                required: true,
                type: {
                    name: "String"
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VectorizedQuery = {
    serializedName: "vector",
    type: {
        name: "Composite",
        className: "VectorizedQuery",
        uberParent: "VectorQuery",
        polymorphicDiscriminator: VectorQuery.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, VectorQuery.type.modelProperties), { vector: {
                serializedName: "vector",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            } })
    }
};
let discriminators$1 = {
    VectorQuery: VectorQuery,
    "VectorQuery.vector": VectorizedQuery
};

var Mappers$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AutocompleteItem: AutocompleteItem,
    AutocompleteRequest: AutocompleteRequest,
    AutocompleteResult: AutocompleteResult,
    FacetResult: FacetResult,
    IndexAction: IndexAction,
    IndexBatch: IndexBatch,
    IndexDocumentsResult: IndexDocumentsResult,
    IndexingResult: IndexingResult,
    QueryAnswerResult: QueryAnswerResult,
    QueryCaptionResult: QueryCaptionResult,
    SearchDocumentsResult: SearchDocumentsResult,
    SearchError: SearchError$1,
    SearchRequest: SearchRequest,
    SearchResult: SearchResult,
    SuggestDocumentsResult: SuggestDocumentsResult,
    SuggestRequest: SuggestRequest,
    SuggestResult: SuggestResult,
    VectorQuery: VectorQuery,
    VectorizedQuery: VectorizedQuery,
    discriminators: discriminators$1
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept$1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint$1 = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const indexName$1 = {
    parameterPath: "indexName",
    mapper: {
        serializedName: "indexName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion$1 = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const searchText = {
    parameterPath: ["options", "searchText"],
    mapper: {
        serializedName: "search",
        type: {
            name: "String"
        }
    }
};
const includeTotalResultCount = {
    parameterPath: ["options", "searchOptions", "includeTotalResultCount"],
    mapper: {
        serializedName: "$count",
        type: {
            name: "Boolean"
        }
    }
};
const facets = {
    parameterPath: ["options", "searchOptions", "facets"],
    mapper: {
        serializedName: "facet",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const filter = {
    parameterPath: ["options", "searchOptions", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const highlightFields = {
    parameterPath: ["options", "searchOptions", "highlightFields"],
    mapper: {
        serializedName: "highlight",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const highlightPostTag = {
    parameterPath: ["options", "searchOptions", "highlightPostTag"],
    mapper: {
        serializedName: "highlightPostTag",
        type: {
            name: "String"
        }
    }
};
const highlightPreTag = {
    parameterPath: ["options", "searchOptions", "highlightPreTag"],
    mapper: {
        serializedName: "highlightPreTag",
        type: {
            name: "String"
        }
    }
};
const minimumCoverage = {
    parameterPath: ["options", "searchOptions", "minimumCoverage"],
    mapper: {
        serializedName: "minimumCoverage",
        type: {
            name: "Number"
        }
    }
};
const orderBy = {
    parameterPath: ["options", "searchOptions", "orderBy"],
    mapper: {
        serializedName: "$orderby",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const queryType = {
    parameterPath: ["options", "searchOptions", "queryType"],
    mapper: {
        serializedName: "queryType",
        type: {
            name: "Enum",
            allowedValues: ["simple", "full", "semantic"]
        }
    }
};
const scoringParameters = {
    parameterPath: ["options", "searchOptions", "scoringParameters"],
    mapper: {
        serializedName: "scoringParameter",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "Multi"
};
const scoringProfile = {
    parameterPath: ["options", "searchOptions", "scoringProfile"],
    mapper: {
        serializedName: "scoringProfile",
        type: {
            name: "String"
        }
    }
};
const searchFields = {
    parameterPath: ["options", "searchOptions", "searchFields"],
    mapper: {
        serializedName: "searchFields",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const searchMode = {
    parameterPath: ["options", "searchOptions", "searchMode"],
    mapper: {
        serializedName: "searchMode",
        type: {
            name: "Enum",
            allowedValues: ["any", "all"]
        }
    }
};
const scoringStatistics = {
    parameterPath: ["options", "searchOptions", "scoringStatistics"],
    mapper: {
        serializedName: "scoringStatistics",
        type: {
            name: "Enum",
            allowedValues: ["local", "global"]
        }
    }
};
const sessionId = {
    parameterPath: ["options", "searchOptions", "sessionId"],
    mapper: {
        serializedName: "sessionId",
        type: {
            name: "String"
        }
    }
};
const select$1 = {
    parameterPath: ["options", "searchOptions", "select"],
    mapper: {
        serializedName: "$select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const skip = {
    parameterPath: ["options", "searchOptions", "skip"],
    mapper: {
        serializedName: "$skip",
        type: {
            name: "Number"
        }
    }
};
const top = {
    parameterPath: ["options", "searchOptions", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const semanticConfiguration = {
    parameterPath: ["options", "searchOptions", "semanticConfiguration"],
    mapper: {
        serializedName: "semanticConfiguration",
        type: {
            name: "String"
        }
    }
};
const semanticErrorHandling = {
    parameterPath: ["options", "searchOptions", "semanticErrorHandling"],
    mapper: {
        serializedName: "semanticErrorHandling",
        type: {
            name: "String"
        }
    }
};
const semanticMaxWaitInMilliseconds = {
    parameterPath: ["options", "searchOptions", "semanticMaxWaitInMilliseconds"],
    mapper: {
        constraints: {
            InclusiveMinimum: 700
        },
        serializedName: "semanticMaxWaitInMilliseconds",
        type: {
            name: "Number"
        }
    }
};
const answers = {
    parameterPath: ["options", "searchOptions", "answers"],
    mapper: {
        serializedName: "answers",
        type: {
            name: "String"
        }
    }
};
const captions = {
    parameterPath: ["options", "searchOptions", "captions"],
    mapper: {
        serializedName: "captions",
        type: {
            name: "String"
        }
    }
};
const contentType$1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const searchRequest = {
    parameterPath: "searchRequest",
    mapper: SearchRequest
};
const key = {
    parameterPath: "key",
    mapper: {
        serializedName: "key",
        required: true,
        type: {
            name: "String"
        }
    }
};
const selectedFields = {
    parameterPath: ["options", "selectedFields"],
    mapper: {
        serializedName: "$select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const searchText1 = {
    parameterPath: "searchText",
    mapper: {
        serializedName: "search",
        required: true,
        type: {
            name: "String"
        }
    }
};
const suggesterName = {
    parameterPath: "suggesterName",
    mapper: {
        serializedName: "suggesterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const filter1 = {
    parameterPath: ["options", "suggestOptions", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const useFuzzyMatching = {
    parameterPath: ["options", "suggestOptions", "useFuzzyMatching"],
    mapper: {
        serializedName: "fuzzy",
        type: {
            name: "Boolean"
        }
    }
};
const highlightPostTag1 = {
    parameterPath: ["options", "suggestOptions", "highlightPostTag"],
    mapper: {
        serializedName: "highlightPostTag",
        type: {
            name: "String"
        }
    }
};
const highlightPreTag1 = {
    parameterPath: ["options", "suggestOptions", "highlightPreTag"],
    mapper: {
        serializedName: "highlightPreTag",
        type: {
            name: "String"
        }
    }
};
const minimumCoverage1 = {
    parameterPath: ["options", "suggestOptions", "minimumCoverage"],
    mapper: {
        serializedName: "minimumCoverage",
        type: {
            name: "Number"
        }
    }
};
const orderBy1 = {
    parameterPath: ["options", "suggestOptions", "orderBy"],
    mapper: {
        serializedName: "$orderby",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const searchFields1 = {
    parameterPath: ["options", "suggestOptions", "searchFields"],
    mapper: {
        serializedName: "searchFields",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const select1 = {
    parameterPath: ["options", "suggestOptions", "select"],
    mapper: {
        serializedName: "$select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const top1 = {
    parameterPath: ["options", "suggestOptions", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const suggestRequest = {
    parameterPath: "suggestRequest",
    mapper: SuggestRequest
};
const batch = {
    parameterPath: "batch",
    mapper: IndexBatch
};
const autocompleteMode = {
    parameterPath: ["options", "autocompleteOptions", "autocompleteMode"],
    mapper: {
        serializedName: "autocompleteMode",
        type: {
            name: "Enum",
            allowedValues: ["oneTerm", "twoTerms", "oneTermWithContext"]
        }
    }
};
const filter2 = {
    parameterPath: ["options", "autocompleteOptions", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const useFuzzyMatching1 = {
    parameterPath: ["options", "autocompleteOptions", "useFuzzyMatching"],
    mapper: {
        serializedName: "fuzzy",
        type: {
            name: "Boolean"
        }
    }
};
const highlightPostTag2 = {
    parameterPath: ["options", "autocompleteOptions", "highlightPostTag"],
    mapper: {
        serializedName: "highlightPostTag",
        type: {
            name: "String"
        }
    }
};
const highlightPreTag2 = {
    parameterPath: ["options", "autocompleteOptions", "highlightPreTag"],
    mapper: {
        serializedName: "highlightPreTag",
        type: {
            name: "String"
        }
    }
};
const minimumCoverage2 = {
    parameterPath: ["options", "autocompleteOptions", "minimumCoverage"],
    mapper: {
        serializedName: "minimumCoverage",
        type: {
            name: "Number"
        }
    }
};
const searchFields2 = {
    parameterPath: ["options", "autocompleteOptions", "searchFields"],
    mapper: {
        serializedName: "searchFields",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const top2 = {
    parameterPath: ["options", "autocompleteOptions", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const autocompleteRequest = {
    parameterPath: "autocompleteRequest",
    mapper: AutocompleteRequest
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Documents operations. */
class DocumentsImpl {
    /**
     * Initialize a new instance of the class Documents class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Queries the number of documents in the index.
     * @param options The options parameters.
     */
    count(options) {
        return this.client.sendOperationRequest({ options }, countOperationSpec);
    }
    /**
     * Searches for documents in the index.
     * @param options The options parameters.
     */
    searchGet(options) {
        return this.client.sendOperationRequest({ options }, searchGetOperationSpec);
    }
    /**
     * Searches for documents in the index.
     * @param searchRequest The definition of the Search request.
     * @param options The options parameters.
     */
    searchPost(searchRequest, options) {
        return this.client.sendOperationRequest({ searchRequest, options }, searchPostOperationSpec);
    }
    /**
     * Retrieves a document from the index.
     * @param key The key of the document to retrieve.
     * @param options The options parameters.
     */
    get(key, options) {
        return this.client.sendOperationRequest({ key, options }, getOperationSpec$5);
    }
    /**
     * Suggests documents in the index that match the given partial query text.
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no
     *                   more than 100 characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     *                      of the index definition.
     * @param options The options parameters.
     */
    suggestGet(searchText, suggesterName, options) {
        return this.client.sendOperationRequest({ searchText, suggesterName, options }, suggestGetOperationSpec);
    }
    /**
     * Suggests documents in the index that match the given partial query text.
     * @param suggestRequest The Suggest request.
     * @param options The options parameters.
     */
    suggestPost(suggestRequest, options) {
        return this.client.sendOperationRequest({ suggestRequest, options }, suggestPostOperationSpec);
    }
    /**
     * Sends a batch of document write actions to the index.
     * @param batch The batch of index actions.
     * @param options The options parameters.
     */
    index(batch, options) {
        return this.client.sendOperationRequest({ batch, options }, indexOperationSpec);
    }
    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     *                      of the index definition.
     * @param options The options parameters.
     */
    autocompleteGet(searchText, suggesterName, options) {
        return this.client.sendOperationRequest({ searchText, suggesterName, options }, autocompleteGetOperationSpec);
    }
    /**
     * Autocompletes incomplete query terms based on input text and matching terms in the index.
     * @param autocompleteRequest The definition of the Autocomplete request.
     * @param options The options parameters.
     */
    autocompletePost(autocompleteRequest, options) {
        return this.client.sendOperationRequest({ autocompleteRequest, options }, autocompletePostOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers$1, /* isXml */ false);
const countOperationSpec = {
    path: "/docs/$count",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "Number" } }
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [accept$1],
    serializer: serializer$6
};
const searchGetOperationSpec = {
    path: "/docs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchDocumentsResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [
        apiVersion$1,
        searchText,
        includeTotalResultCount,
        facets,
        filter,
        highlightFields,
        highlightPostTag,
        highlightPreTag,
        minimumCoverage,
        orderBy,
        queryType,
        scoringParameters,
        scoringProfile,
        searchFields,
        searchMode,
        scoringStatistics,
        sessionId,
        select$1,
        skip,
        top,
        semanticConfiguration,
        semanticErrorHandling,
        semanticMaxWaitInMilliseconds,
        answers,
        captions
    ],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [accept$1],
    serializer: serializer$6
};
const searchPostOperationSpec = {
    path: "/docs/search.post.search",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SearchDocumentsResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: searchRequest,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [accept$1, contentType$1],
    mediaType: "json",
    serializer: serializer$6
};
const getOperationSpec$5 = {
    path: "/docs('{key}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "any" } } }
            }
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [apiVersion$1, selectedFields],
    urlParameters: [endpoint$1, indexName$1, key],
    headerParameters: [accept$1],
    serializer: serializer$6
};
const suggestGetOperationSpec = {
    path: "/docs/search.suggest",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SuggestDocumentsResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [
        apiVersion$1,
        searchText1,
        suggesterName,
        filter1,
        useFuzzyMatching,
        highlightPostTag1,
        highlightPreTag1,
        minimumCoverage1,
        orderBy1,
        searchFields1,
        select1,
        top1
    ],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [accept$1],
    serializer: serializer$6
};
const suggestPostOperationSpec = {
    path: "/docs/search.post.suggest",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SuggestDocumentsResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: suggestRequest,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [accept$1, contentType$1],
    mediaType: "json",
    serializer: serializer$6
};
const indexOperationSpec = {
    path: "/docs/search.index",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IndexDocumentsResult
        },
        207: {
            bodyMapper: IndexDocumentsResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: batch,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [accept$1, contentType$1],
    mediaType: "json",
    serializer: serializer$6
};
const autocompleteGetOperationSpec = {
    path: "/docs/search.autocomplete",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutocompleteResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    queryParameters: [
        apiVersion$1,
        searchText1,
        suggesterName,
        autocompleteMode,
        filter2,
        useFuzzyMatching1,
        highlightPostTag2,
        highlightPreTag2,
        minimumCoverage2,
        searchFields2,
        top2
    ],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [accept$1],
    serializer: serializer$6
};
const autocompletePostOperationSpec = {
    path: "/docs/search.post.autocomplete",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AutocompleteResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    requestBody: autocompleteRequest,
    queryParameters: [apiVersion$1],
    urlParameters: [endpoint$1, indexName$1],
    headerParameters: [accept$1, contentType$1],
    mediaType: "json",
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
let SearchClient$1 = class SearchClient extends coreHttpCompat__namespace.ExtendedServiceClient {
    /**
     * Initializes a new instance of the SearchClient class.
     * @param endpoint The endpoint URL of the search service.
     * @param indexName The name of the index.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(endpoint, indexName, apiVersion, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        if (indexName === undefined) {
            throw new Error("'indexName' cannot be null");
        }
        if (apiVersion === undefined) {
            throw new Error("'apiVersion' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-search-documents/12.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}/indexes('{indexName}')" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        this.indexName = indexName;
        this.apiVersion = apiVersion;
        this.documents = new DocumentsImpl(this);
        this.addCustomApiVersionPolicy(apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const API_KEY_HEADER_NAME = "api-key";
const searchApiKeyCredentialPolicy = "SearchApiKeyCredentialPolicy";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Azure Cognitive Search
 */
function createSearchApiKeyCredentialPolicy(credential) {
    return {
        name: searchApiKeyCredentialPolicy,
        async sendRequest(request, next) {
            if (!request.headers.has(API_KEY_HEADER_NAME)) {
                request.headers.set(API_KEY_HEADER_NAME, credential.key);
            }
            return next(request);
        },
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The `@azure/logger` configuration for this package.
 */
const logger = logger$1.createClientLogger("search");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Creates a tracing client using the global tracer.
 * @internal
 */
const tracingClient = coreTracing.createTracingClient({
    namespace: "Microsoft.Search",
    packageName: "Azure.Search",
});
const createSpan = tracingClient.startSpan;

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const WorldGeodeticSystem1984$1 = "EPSG:4326"; // See https://epsg.io/4326
/**
 * Represents a geographic point in global coordinates.
 */
class GeographyPoint {
    /**
     * Constructs a new instance of GeographyPoint given
     * the specified coordinates.
     * @param geographyPoint - object with longitude and latitude values in decimal
     */
    constructor(geographyPoint) {
        this.longitude = geographyPoint.longitude;
        this.latitude = geographyPoint.latitude;
    }
    /**
     * Used to serialize to a GeoJSON Point.
     */
    toJSON() {
        return {
            type: "Point",
            coordinates: [this.longitude, this.latitude],
            crs: { type: "name", properties: { name: WorldGeodeticSystem1984$1 } },
        };
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const ISO8601DateRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{1,3})?Z$/i;
const GeoJSONPointTypeName = "Point";
const WorldGeodeticSystem1984 = "EPSG:4326"; // See https://epsg.io/4326
function serialize(obj) {
    return walk(obj, (value) => {
        const result = serializeSpecialNumbers(value);
        return result;
    });
}
function deserialize(obj) {
    return walk(obj, (value) => {
        let result = deserializeSpecialNumbers(value);
        result = deserializeDates(result);
        result = deserializeGeoPoint(result);
        return result;
    });
}
function walk(start, mapper) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    const seenMarker = new WeakMap();
    const result = { value: undefined };
    const queue = [
        { value: start, parent: result, key: "value" },
    ];
    while (queue.length) {
        const current = queue.shift();
        if (typeof current.value === "object" && current.value !== null) {
            if (seenMarker.has(current.value)) {
                continue;
            }
            else {
                seenMarker.set(current.value, true);
            }
        }
        const mapped = mapper(current.value);
        if ((current === null || current === void 0 ? void 0 : current.parent) && current.key) {
            current.parent[current.key] = mapped;
        }
        if (typeof mapped === "object" && mapped !== null) {
            for (const key of Object.keys(mapped)) {
                queue.push({
                    value: mapped[key],
                    parent: mapped,
                    key,
                });
            }
        }
    }
    return result.value;
}
function serializeSpecialNumbers(input) {
    if (typeof input === "number") {
        if (isNaN(input)) {
            return "NaN";
        }
        else if (input === Infinity) {
            return "INF";
        }
        else if (input === -Infinity) {
            return "-INF";
        }
    }
    return input;
}
function deserializeSpecialNumbers(input) {
    if (typeof input === "string") {
        if (input === "NaN") {
            return NaN;
        }
        else if (input === "INF") {
            return Infinity;
        }
        else if (input === "-INF") {
            return -Infinity;
        }
    }
    return input;
}
function deserializeDates(input) {
    if (typeof input === "string") {
        if (ISO8601DateRegex.test(input)) {
            return new Date(input);
        }
    }
    return input;
}
function deserializeGeoPoint(input) {
    if (isGeoJSONPoint(input)) {
        return new GeographyPoint({ longitude: input.coordinates[0], latitude: input.coordinates[1] });
    }
    return input;
}
function isGeoJSONPoint(obj) {
    const requiredKeys = ["type", "coordinates"];
    return isValidObject(obj, {
        requiredKeys,
        propertyValidator: (key) => {
            switch (key) {
                case "type":
                    return obj.type === GeoJSONPointTypeName;
                case "coordinates":
                    return isCoordinateArray(obj.coordinates);
                case "crs":
                    return isCrs(obj.crs);
                default:
                    return false;
            }
        },
    });
}
function isCoordinateArray(maybeCoordinates) {
    if (!Array.isArray(maybeCoordinates)) {
        return false;
    }
    if (maybeCoordinates.length !== 2) {
        return false;
    }
    if (typeof maybeCoordinates[0] !== "number" || typeof maybeCoordinates[1] !== "number") {
        return false;
    }
    return true;
}
function isCrs(maybeCrs) {
    return isValidObject(maybeCrs, {
        requiredKeys: ["type", "properties"],
        propertyValidator: (key) => {
            switch (key) {
                case "type":
                    return maybeCrs.type === "name";
                case "properties":
                    return isCrsProperties(maybeCrs.properties);
                default:
                    return false;
            }
        },
    });
}
function isCrsProperties(maybeProperties) {
    return isValidObject(maybeProperties, {
        requiredKeys: ["name"],
        propertyValidator: (key) => {
            if (key === "name") {
                return maybeProperties.name === WorldGeodeticSystem1984;
            }
            else {
                return false;
            }
        },
    });
}
function isValidObject(obj, options = {}) {
    if (typeof obj !== "object" || obj === null) {
        return false;
    }
    const keys = Object.keys(obj);
    if (options.requiredKeys) {
        for (const requiredKey of options.requiredKeys) {
            if (!keys.includes(requiredKey)) {
                return false;
            }
        }
    }
    if (options.propertyValidator) {
        for (const key of keys) {
            if (!options.propertyValidator(key)) {
                return false;
            }
        }
    }
    return true;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const AcceptHeaderName = "Accept";
const odataMetadataPolicy = "OdataMetadataPolicy";
/**
 * A policy factory for setting the Accept header to ignore odata metadata
 * @internal
 */
function createOdataMetadataPolicy(metadataLevel) {
    return {
        name: odataMetadataPolicy,
        async sendRequest(request, next) {
            request.headers.set(AcceptHeaderName, `application/json;odata.metadata=${metadataLevel}`);
            return next(request);
        },
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Class used to perform batch operations
 * with multiple documents to the index.
 */
class IndexDocumentsBatch {
    constructor(actions = []) {
        this.actions = actions;
    }
    /**
     * Upload an array of documents to the index.
     * @param documents - The documents to upload.
     */
    upload(documents) {
        const batch = documents.map((doc) => {
            return Object.assign(Object.assign({}, doc), { __actionType: "upload" });
        });
        this.actions.push(...batch);
    }
    /**
     * Update a set of documents in the index.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents - The updated documents.
     */
    merge(documents) {
        const batch = documents.map((doc) => {
            return Object.assign(Object.assign({}, doc), { __actionType: "merge" });
        });
        this.actions.push(...batch);
    }
    /**
     * Update a set of documents in the index or uploads them if they don't exist.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents - The new/updated documents.
     */
    mergeOrUpload(documents) {
        const batch = documents.map((doc) => {
            return Object.assign(Object.assign({}, doc), { __actionType: "mergeOrUpload" });
        });
        this.actions.push(...batch);
    }
    delete(keyNameOrDocuments, keyValues) {
        if (keyValues) {
            const keyName = keyNameOrDocuments;
            const batch = keyValues.map((keyValue) => {
                return {
                    __actionType: "delete",
                    [keyName]: keyValue,
                };
            });
            this.actions.push(...batch);
        }
        else {
            const documents = keyNameOrDocuments;
            const batch = documents.map((document) => {
                return Object.assign({ __actionType: "delete" }, document);
            });
            this.actions.push(...batch);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Encodes a string in base64 format.
 * @param value - The string to encode.
 */
function encode(value) {
    return Buffer.from(value).toString("base64");
}
/**
 * Decodes a base64 string into a regular string.
 * @param value - The base64 string to decode.
 */
function decode(value) {
    return Buffer.from(value, "base64").toString();
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isComplexField(field) {
    return field.type === "Edm.ComplexType" || field.type === "Collection(Edm.ComplexType)";
}
/**
 * Defines values for TokenizerName.
 * @readonly
 */
var KnownTokenizerNames;
(function (KnownTokenizerNames) {
    /**
     * Grammar-based tokenizer that is suitable for processing most European-language documents. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicTokenizer.html
     */
    KnownTokenizerNames["Classic"] = "classic";
    /**
     * Tokenizes the input from an edge into n-grams of the given size(s). See
     * https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenizer.html
     */
    KnownTokenizerNames["EdgeNGram"] = "edgeNGram";
    /**
     * Emits the entire input as a single token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/KeywordTokenizer.html
     */
    KnownTokenizerNames["Keyword"] = "keyword_v2";
    /**
     * Divides text at non-letters. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LetterTokenizer.html
     */
    KnownTokenizerNames["Letter"] = "letter";
    /**
     * Divides text at non-letters and converts them to lower case. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseTokenizer.html
     */
    KnownTokenizerNames["Lowercase"] = "lowercase";
    /**
     * Divides text using language-specific rules.
     */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    KnownTokenizerNames["MicrosoftLanguageTokenizer"] = "microsoft_language_tokenizer";
    /**
     * Divides text using language-specific rules and reduces words to their base forms.
     */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    KnownTokenizerNames["MicrosoftLanguageStemmingTokenizer"] = "microsoft_language_stemming_tokenizer";
    /**
     * Tokenizes the input into n-grams of the given size(s). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenizer.html
     */
    KnownTokenizerNames["NGram"] = "nGram";
    /**
     * Tokenizer for path-like hierarchies. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/path/PathHierarchyTokenizer.html
     */
    KnownTokenizerNames["PathHierarchy"] = "path_hierarchy_v2";
    /**
     * Tokenizer that uses regex pattern matching to construct distinct tokens. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/pattern/PatternTokenizer.html
     */
    KnownTokenizerNames["Pattern"] = "pattern";
    /**
     * Standard Lucene analyzer; Composed of the standard tokenizer, lowercase filter and stop
     * filter. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/StandardTokenizer.html
     */
    KnownTokenizerNames["Standard"] = "standard_v2";
    /**
     * Tokenizes urls and emails as one token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizer.html
     */
    KnownTokenizerNames["UaxUrlEmail"] = "uax_url_email";
    /**
     * Divides text at whitespace. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/WhitespaceTokenizer.html
     */
    KnownTokenizerNames["Whitespace"] = "whitespace";
})(KnownTokenizerNames || (KnownTokenizerNames = {}));
/**
 * Defines values for TokenFilterName.
 * @readonly
 */
var KnownTokenFilterNames;
(function (KnownTokenFilterNames) {
    /**
     * A token filter that applies the Arabic normalizer to normalize the orthography. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ar/ArabicNormalizationFilter.html
     */
    KnownTokenFilterNames["ArabicNormalization"] = "arabic_normalization";
    /**
     * Strips all characters after an apostrophe (including the apostrophe itself). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/tr/ApostropheFilter.html
     */
    KnownTokenFilterNames["Apostrophe"] = "apostrophe";
    /**
     * Converts alphabetic, numeric, and symbolic Unicode characters which are not in the first 127
     * ASCII characters (the "Basic Latin" Unicode block) into their ASCII equivalents, if such
     * equivalents exist. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html
     */
    KnownTokenFilterNames["AsciiFolding"] = "asciifolding";
    /**
     * Forms bigrams of CJK terms that are generated from StandardTokenizer. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKBigramFilter.html
     */
    KnownTokenFilterNames["CjkBigram"] = "cjk_bigram";
    /**
     * Normalizes CJK width differences. Folds fullwidth ASCII variants into the equivalent basic
     * Latin, and half-width Katakana variants into the equivalent Kana. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKWidthFilter.html
     */
    KnownTokenFilterNames["CjkWidth"] = "cjk_width";
    /**
     * Removes English possessives, and dots from acronyms. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicFilter.html
     */
    KnownTokenFilterNames["Classic"] = "classic";
    /**
     * Construct bigrams for frequently occurring terms while indexing. Single terms are still
     * indexed too, with bigrams overlaid. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/commongrams/CommonGramsFilter.html
     */
    KnownTokenFilterNames["CommonGram"] = "common_grams";
    /**
     * Generates n-grams of the given size(s) starting from the front or the back of an input token.
     * See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenFilter.html
     */
    KnownTokenFilterNames["EdgeNGram"] = "edgeNGram_v2";
    /**
     * Removes elisions. For example, "l'avion" (the plane) will be converted to "avion" (plane). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/util/ElisionFilter.html
     */
    KnownTokenFilterNames["Elision"] = "elision";
    /**
     * Normalizes German characters according to the heuristics of the German2 snowball algorithm.
     * See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/de/GermanNormalizationFilter.html
     */
    KnownTokenFilterNames["GermanNormalization"] = "german_normalization";
    /**
     * Normalizes text in Hindi to remove some differences in spelling variations. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/hi/HindiNormalizationFilter.html
     */
    KnownTokenFilterNames["HindiNormalization"] = "hindi_normalization";
    /**
     * Normalizes the Unicode representation of text in Indian languages. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/in/IndicNormalizationFilter.html
     */
    KnownTokenFilterNames["IndicNormalization"] = "indic_normalization";
    /**
     * Emits each incoming token twice, once as keyword and once as non-keyword. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/KeywordRepeatFilter.html
     */
    KnownTokenFilterNames["KeywordRepeat"] = "keyword_repeat";
    /**
     * A high-performance kstem filter for English. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/en/KStemFilter.html
     */
    KnownTokenFilterNames["KStem"] = "kstem";
    /**
     * Removes words that are too long or too short. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LengthFilter.html
     */
    KnownTokenFilterNames["Length"] = "length";
    /**
     * Limits the number of tokens while indexing. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LimitTokenCountFilter.html
     */
    KnownTokenFilterNames["Limit"] = "limit";
    /**
     * Normalizes token text to lower case. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseFilter.htm
     */
    KnownTokenFilterNames["Lowercase"] = "lowercase";
    /**
     * Generates n-grams of the given size(s). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenFilter.html
     */
    KnownTokenFilterNames["NGram"] = "nGram_v2";
    /**
     * Applies normalization for Persian. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/fa/PersianNormalizationFilter.html
     */
    KnownTokenFilterNames["PersianNormalization"] = "persian_normalization";
    /**
     * Create tokens for phonetic matches. See
     * https://lucene.apache.org/core/4_10_3/analyzers-phonetic/org/apache/lucene/analysis/phonetic/package-tree.html
     */
    KnownTokenFilterNames["Phonetic"] = "phonetic";
    /**
     * Uses the Porter stemming algorithm to transform the token stream. See
     * http://tartarus.org/~martin/PorterStemmer
     */
    KnownTokenFilterNames["PorterStem"] = "porter_stem";
    /**
     * Reverses the token string. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/reverse/ReverseStringFilter.html
     */
    KnownTokenFilterNames["Reverse"] = "reverse";
    /**
     * Normalizes use of the interchangeable Scandinavian characters. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianNormalizationFilter.html
     */
    KnownTokenFilterNames["ScandinavianNormalization"] = "scandinavian_normalization";
    /**
     * Folds Scandinavian characters åÅäæÄÆ-&gt;a and öÖøØ-&gt;o. It also discriminates against use
     * of double vowels aa, ae, ao, oe and oo, leaving just the first one. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianFoldingFilter.html
     */
    KnownTokenFilterNames["ScandinavianFoldingNormalization"] = "scandinavian_folding";
    /**
     * Creates combinations of tokens as a single token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/shingle/ShingleFilter.html
     */
    KnownTokenFilterNames["Shingle"] = "shingle";
    /**
     * A filter that stems words using a Snowball-generated stemmer. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/snowball/SnowballFilter.html
     */
    KnownTokenFilterNames["Snowball"] = "snowball";
    /**
     * Normalizes the Unicode representation of Sorani text. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ckb/SoraniNormalizationFilter.html
     */
    KnownTokenFilterNames["SoraniNormalization"] = "sorani_normalization";
    /**
     * Language specific stemming filter. See
     * https://docs.microsoft.com/rest/api/searchservice/Custom-analyzers-in-Azure-Search#TokenFilters
     */
    KnownTokenFilterNames["Stemmer"] = "stemmer";
    /**
     * Removes stop words from a token stream. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/StopFilter.html
     */
    KnownTokenFilterNames["Stopwords"] = "stopwords";
    /**
     * Trims leading and trailing whitespace from tokens. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TrimFilter.html
     */
    KnownTokenFilterNames["Trim"] = "trim";
    /**
     * Truncates the terms to a specific length. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TruncateTokenFilter.html
     */
    KnownTokenFilterNames["Truncate"] = "truncate";
    /**
     * Filters out tokens with same text as the previous token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/RemoveDuplicatesTokenFilter.html
     */
    KnownTokenFilterNames["Unique"] = "unique";
    /**
     * Normalizes token text to upper case. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/UpperCaseFilter.html
     */
    KnownTokenFilterNames["Uppercase"] = "uppercase";
    /**
     * Splits words into subwords and performs optional transformations on subword groups.
     */
    KnownTokenFilterNames["WordDelimiter"] = "word_delimiter";
})(KnownTokenFilterNames || (KnownTokenFilterNames = {}));
/**
 * Defines values for CharFilterName.
 * @readonly
 */
var KnownCharFilterNames;
(function (KnownCharFilterNames) {
    /**
     * A character filter that attempts to strip out HTML constructs. See
     * https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.html
     */
    KnownCharFilterNames["HtmlStrip"] = "html_strip";
})(KnownCharFilterNames || (KnownCharFilterNames = {}));
/**
 * Defines values for AnalyzerName.
 * See https://docs.microsoft.com/rest/api/searchservice/Language-support
 * @readonly
 */
exports.KnownAnalyzerNames = void 0;
(function (KnownAnalyzerNames) {
    /**
     * Arabic
     */
    KnownAnalyzerNames["ArMicrosoft"] = "ar.microsoft";
    /**
     * Arabic
     */
    KnownAnalyzerNames["ArLucene"] = "ar.lucene";
    /**
     * Armenian
     */
    KnownAnalyzerNames["HyLucene"] = "hy.lucene";
    /**
     * Bangla
     */
    KnownAnalyzerNames["BnMicrosoft"] = "bn.microsoft";
    /**
     * Basque
     */
    KnownAnalyzerNames["EuLucene"] = "eu.lucene";
    /**
     * Bulgarian
     */
    KnownAnalyzerNames["BgMicrosoft"] = "bg.microsoft";
    /**
     * Bulgarian
     */
    KnownAnalyzerNames["BgLucene"] = "bg.lucene";
    /**
     * Catalan
     */
    KnownAnalyzerNames["CaMicrosoft"] = "ca.microsoft";
    /**
     * Catalan
     */
    KnownAnalyzerNames["CaLucene"] = "ca.lucene";
    /**
     * Chinese Simplified
     */
    KnownAnalyzerNames["ZhHansMicrosoft"] = "zh-Hans.microsoft";
    /**
     * Chinese Simplified
     */
    KnownAnalyzerNames["ZhHansLucene"] = "zh-Hans.lucene";
    /**
     * Chinese Traditional
     */
    KnownAnalyzerNames["ZhHantMicrosoft"] = "zh-Hant.microsoft";
    /**
     * Chinese Traditional
     */
    KnownAnalyzerNames["ZhHantLucene"] = "zh-Hant.lucene";
    /**
     * Croatian
     */
    KnownAnalyzerNames["HrMicrosoft"] = "hr.microsoft";
    /**
     * Czech
     */
    KnownAnalyzerNames["CsMicrosoft"] = "cs.microsoft";
    /**
     * Czech
     */
    KnownAnalyzerNames["CsLucene"] = "cs.lucene";
    /**
     * Danish
     */
    KnownAnalyzerNames["DaMicrosoft"] = "da.microsoft";
    /**
     * Danish
     */
    KnownAnalyzerNames["DaLucene"] = "da.lucene";
    /**
     * Dutch
     */
    KnownAnalyzerNames["NlMicrosoft"] = "nl.microsoft";
    /**
     * Dutch
     */
    KnownAnalyzerNames["NlLucene"] = "nl.lucene";
    /**
     * English
     */
    KnownAnalyzerNames["EnMicrosoft"] = "en.microsoft";
    /**
     * English
     */
    KnownAnalyzerNames["EnLucene"] = "en.lucene";
    /**
     * Estonian
     */
    KnownAnalyzerNames["EtMicrosoft"] = "et.microsoft";
    /**
     * Finnish
     */
    KnownAnalyzerNames["FiMicrosoft"] = "fi.microsoft";
    /**
     * Finnish
     */
    KnownAnalyzerNames["FiLucene"] = "fi.lucene";
    /**
     * French
     */
    KnownAnalyzerNames["FrMicrosoft"] = "fr.microsoft";
    /**
     * French
     */
    KnownAnalyzerNames["FrLucene"] = "fr.lucene";
    /**
     * Galician
     */
    KnownAnalyzerNames["GlLucene"] = "gl.lucene";
    /**
     * German
     */
    KnownAnalyzerNames["DeMicrosoft"] = "de.microsoft";
    /**
     * German
     */
    KnownAnalyzerNames["DeLucene"] = "de.lucene";
    /**
     * Greek
     */
    KnownAnalyzerNames["ElMicrosoft"] = "el.microsoft";
    /**
     * Greek
     */
    KnownAnalyzerNames["ElLucene"] = "el.lucene";
    /**
     * Gujarati
     */
    KnownAnalyzerNames["GuMicrosoft"] = "gu.microsoft";
    /**
     * Hebrew
     */
    KnownAnalyzerNames["HeMicrosoft"] = "he.microsoft";
    /**
     * Hindi
     */
    KnownAnalyzerNames["HiMicrosoft"] = "hi.microsoft";
    /**
     * Hindi
     */
    KnownAnalyzerNames["HiLucene"] = "hi.lucene";
    /**
     * Hungarian
     */
    KnownAnalyzerNames["HuMicrosoft"] = "hu.microsoft";
    /**
     * Hungarian
     */
    KnownAnalyzerNames["HuLucene"] = "hu.lucene";
    /**
     * Icelandic
     */
    KnownAnalyzerNames["IsMicrosoft"] = "is.microsoft";
    /**
     * Indonesian (Bahasa)
     */
    KnownAnalyzerNames["IdMicrosoft"] = "id.microsoft";
    /**
     * Indonesian (Bahasa)
     */
    KnownAnalyzerNames["IdLucene"] = "id.lucene";
    /**
     * Irish
     */
    KnownAnalyzerNames["GaLucene"] = "ga.lucene";
    /**
     * Italian
     */
    KnownAnalyzerNames["ItMicrosoft"] = "it.microsoft";
    /**
     * Italian
     */
    KnownAnalyzerNames["ItLucene"] = "it.lucene";
    /**
     * Japanese
     */
    KnownAnalyzerNames["JaMicrosoft"] = "ja.microsoft";
    /**
     * Japanese
     */
    KnownAnalyzerNames["JaLucene"] = "ja.lucene";
    /**
     * Kannada
     */
    KnownAnalyzerNames["KnMicrosoft"] = "kn.microsoft";
    /**
     * Korean
     */
    KnownAnalyzerNames["KoMicrosoft"] = "ko.microsoft";
    /**
     * Korean
     */
    KnownAnalyzerNames["KoLucene"] = "ko.lucene";
    /**
     * Latvian
     */
    KnownAnalyzerNames["LvMicrosoft"] = "lv.microsoft";
    /**
     * Latvian
     */
    KnownAnalyzerNames["LvLucene"] = "lv.lucene";
    /**
     * Lithuanian
     */
    KnownAnalyzerNames["LtMicrosoft"] = "lt.microsoft";
    /**
     * Malayalam
     */
    KnownAnalyzerNames["MlMicrosoft"] = "ml.microsoft";
    /**
     * Malay (Latin)
     */
    KnownAnalyzerNames["MsMicrosoft"] = "ms.microsoft";
    /**
     * Marathi
     */
    KnownAnalyzerNames["MrMicrosoft"] = "mr.microsoft";
    /**
     * Norwegian
     */
    KnownAnalyzerNames["NbMicrosoft"] = "nb.microsoft";
    /**
     * Norwegian
     */
    KnownAnalyzerNames["NoLucene"] = "no.lucene";
    /**
     * Persian
     */
    KnownAnalyzerNames["FaLucene"] = "fa.lucene";
    /**
     * Polish
     */
    KnownAnalyzerNames["PlMicrosoft"] = "pl.microsoft";
    /**
     * Polish
     */
    KnownAnalyzerNames["PlLucene"] = "pl.lucene";
    /**
     * Portuguese (Brazil)
     */
    KnownAnalyzerNames["PtBRMicrosoft"] = "pt-BR.microsoft";
    /**
     * Portuguese (Brazil)
     */
    KnownAnalyzerNames["PtBRLucene"] = "pt-BR.lucene";
    /**
     * Portuguese (Portugal)
     */
    KnownAnalyzerNames["PtPTMicrosoft"] = "pt-PT.microsoft";
    /**
     * Portuguese (Portugal)
     */
    KnownAnalyzerNames["PtPTLucene"] = "pt-PT.lucene";
    /**
     * Punjabi
     */ KnownAnalyzerNames["PaMicrosoft"] = "pa.microsoft";
    /**
     * Romanian
     */
    KnownAnalyzerNames["RoMicrosoft"] = "ro.microsoft";
    /**
     * Romanian
     */
    KnownAnalyzerNames["RoLucene"] = "ro.lucene";
    /**
     * Russian
     */
    KnownAnalyzerNames["RuMicrosoft"] = "ru.microsoft";
    /**
     * Russian
     */
    KnownAnalyzerNames["RuLucene"] = "ru.lucene";
    /**
     * Serbian (Cyrillic)
     */
    KnownAnalyzerNames["SrCyrillicMicrosoft"] = "sr-cyrillic.microsoft";
    /**
     * Serbian (Latin)
     */
    KnownAnalyzerNames["SrLatinMicrosoft"] = "sr-latin.microsoft";
    /**
     * Slovak
     */
    KnownAnalyzerNames["SkMicrosoft"] = "sk.microsoft";
    /**
     * Slovenian
     */
    KnownAnalyzerNames["SlMicrosoft"] = "sl.microsoft";
    /**
     * Spanish
     */
    KnownAnalyzerNames["EsMicrosoft"] = "es.microsoft";
    /**
     * Spanish
     */
    KnownAnalyzerNames["EsLucene"] = "es.lucene";
    /**
     * Swedish
     */
    KnownAnalyzerNames["SvMicrosoft"] = "sv.microsoft";
    /**
     * Swedish
     */
    KnownAnalyzerNames["SvLucene"] = "sv.lucene";
    /**
     * Tamil
     */
    KnownAnalyzerNames["TaMicrosoft"] = "ta.microsoft";
    /**
     * Telugu
     */
    KnownAnalyzerNames["TeMicrosoft"] = "te.microsoft";
    /**
     * Thai
     */
    KnownAnalyzerNames["ThMicrosoft"] = "th.microsoft";
    /**
     * Thai
     */
    KnownAnalyzerNames["ThLucene"] = "th.lucene";
    /**
     * Turkish
     */
    KnownAnalyzerNames["TrMicrosoft"] = "tr.microsoft";
    /**
     * Turkish
     */
    KnownAnalyzerNames["TrLucene"] = "tr.lucene";
    /**
     * Ukrainian
     */
    KnownAnalyzerNames["UkMicrosoft"] = "uk.microsoft";
    /**
     * Urdu
     */
    KnownAnalyzerNames["UrMicrosoft"] = "ur.microsoft";
    /**
     * Vietnamese
     */
    KnownAnalyzerNames["ViMicrosoft"] = "vi.microsoft";
    /**
     * See: https://lucene.apache.org/core/6_6_1/core/org/apache/lucene/analysis/standard/StandardAnalyzer.html
     */
    KnownAnalyzerNames["StandardLucene"] = "standard.lucene";
    /**
     * See https://lucene.apache.org/core/6_6_1/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html
     */
    KnownAnalyzerNames["StandardAsciiFoldingLucene"] = "standardasciifolding.lucene";
    /**
     * Treats the entire content of a field as a single token. This is useful for data like zip codes, ids, and some product names.
     */
    KnownAnalyzerNames["Keyword"] = "keyword";
    /**
     * Flexibly separates text into terms via a regular expression pattern.
     */
    KnownAnalyzerNames["Pattern"] = "pattern";
    /**
     * Divides text at non-letters and converts them to lower case.
     */
    KnownAnalyzerNames["Simple"] = "simple";
    /**
     * Divides text at non-letters; Applies the lowercase and stopword token filters.
     */
    KnownAnalyzerNames["Stop"] = "stop";
    /**
     * An analyzer that uses the whitespace tokenizer.
     */
    KnownAnalyzerNames["Whitespace"] = "whitespace";
})(exports.KnownAnalyzerNames || (exports.KnownAnalyzerNames = {}));
// END manually modified generated interfaces

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function convertSkillsToPublic(skills) {
    if (!skills) {
        return skills;
    }
    const result = [];
    for (const skill of skills) {
        switch (skill.odatatype) {
            case "#Microsoft.Skills.Util.ConditionalSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.KeyPhraseExtractionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Vision.OcrSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Vision.ImageAnalysisSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.LanguageDetectionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Util.ShaperSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.MergeSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.EntityRecognitionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.SentimentSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.SplitSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.PIIDetectionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.V3.EntityRecognitionSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.V3.EntityLinkingSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.V3.SentimentSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.TranslationSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Custom.WebApiSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Text.CustomEntityLookupSkill":
                result.push(skill);
                break;
            case "#Microsoft.Skills.Util.DocumentExtractionSkill":
                result.push(skill);
                break;
        }
    }
    return result;
}
function convertCognitiveServicesAccountToGenerated(cognitiveServicesAccount) {
    if (!cognitiveServicesAccount) {
        return cognitiveServicesAccount;
    }
    return cognitiveServicesAccount;
}
function convertCognitiveServicesAccountToPublic(cognitiveServicesAccount) {
    if (!cognitiveServicesAccount) {
        return cognitiveServicesAccount;
    }
    if (cognitiveServicesAccount.odatatype === "#Microsoft.Azure.Search.DefaultCognitiveServices") {
        return cognitiveServicesAccount;
    }
    else {
        return cognitiveServicesAccount;
    }
}
function convertTokenFiltersToGenerated(tokenFilters) {
    if (!tokenFilters) {
        return tokenFilters;
    }
    const result = [];
    for (const filter of tokenFilters) {
        result.push(filter);
    }
    return result;
}
function convertAnalyzersToGenerated(analyzers) {
    if (!analyzers) {
        return analyzers;
    }
    const result = [];
    for (const analyzer of analyzers) {
        switch (analyzer.odatatype) {
            case "#Microsoft.Azure.Search.StandardAnalyzer":
            case "#Microsoft.Azure.Search.StopAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.PatternAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { flags: analyzer.flags ? analyzer.flags.join("|") : undefined }));
                break;
            case "#Microsoft.Azure.Search.CustomAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { tokenizerName: analyzer.tokenizerName }));
                break;
        }
    }
    return result;
}
function convertAnalyzersToPublic(analyzers) {
    if (!analyzers) {
        return analyzers;
    }
    const result = [];
    for (const analyzer of analyzers) {
        switch (analyzer.odatatype) {
            case "#Microsoft.Azure.Search.StandardAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.StopAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.PatternAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { flags: analyzer.flags
                        ? analyzer.flags.split("|")
                        : undefined }));
                break;
            case "#Microsoft.Azure.Search.CustomAnalyzer":
                {
                    const customAnalyzer = analyzer;
                    const { name, tokenizerName, tokenFilters } = customAnalyzer;
                    const publicAnalyzer = Object.assign(Object.assign({}, customAnalyzer), { name: name, tokenizerName, tokenFilters: tokenFilters });
                    result.push(publicAnalyzer);
                }
                break;
        }
    }
    return result;
}
function convertFieldsToPublic(fields) {
    if (!fields) {
        return fields;
    }
    return fields.map((field) => {
        if (field.type === "Collection(Edm.ComplexType)" || field.type === "Edm.ComplexType") {
            const result = {
                name: field.name,
                type: field.type,
                fields: convertFieldsToPublic(field.fields),
            };
            return result;
        }
        else {
            const type = field.type;
            const synonymMapNames = field.synonymMaps;
            const { retrievable, analyzer, searchAnalyzer, indexAnalyzer } = field, restField = tslib.__rest(field, ["retrievable", "analyzer", "searchAnalyzer", "indexAnalyzer"]);
            const hidden = typeof retrievable === "boolean" ? !retrievable : retrievable;
            const result = Object.assign(Object.assign({}, restField), { type,
                hidden, analyzerName: analyzer, searchAnalyzerName: searchAnalyzer, indexAnalyzerName: indexAnalyzer, synonymMapNames });
            return result;
        }
    });
}
function convertFieldsToGenerated(fields) {
    return fields.map((field) => {
        var _a, _b, _c, _d;
        if (isComplexField(field)) {
            return {
                name: field.name,
                type: field.type,
                fields: convertFieldsToGenerated(field.fields),
            };
        }
        else {
            const { hidden } = field, restField = tslib.__rest(field, ["hidden"]);
            const retrievable = typeof hidden === "boolean" ? !hidden : hidden;
            return Object.assign(Object.assign({}, restField), { retrievable, 
                // modify API defaults to use less storage for simple types
                searchable: (_a = field.searchable) !== null && _a !== void 0 ? _a : false, filterable: (_b = field.filterable) !== null && _b !== void 0 ? _b : false, facetable: (_c = field.facetable) !== null && _c !== void 0 ? _c : false, sortable: (_d = field.sortable) !== null && _d !== void 0 ? _d : false, analyzer: field.analyzerName, searchAnalyzer: field.searchAnalyzerName, indexAnalyzer: field.indexAnalyzerName, synonymMaps: field.synonymMapNames });
        }
    });
}
function convertTokenizersToGenerated(tokenizers) {
    if (!tokenizers) {
        return tokenizers;
    }
    const result = [];
    for (const tokenizer of tokenizers) {
        if (tokenizer.odatatype === "#Microsoft.Azure.Search.PatternTokenizer") {
            result.push(Object.assign(Object.assign({}, tokenizer), { flags: tokenizer.flags ? tokenizer.flags.join("|") : undefined }));
        }
        else {
            result.push(tokenizer);
        }
    }
    return result;
}
function convertTokenizersToPublic(tokenizers) {
    var _a;
    if (!tokenizers) {
        return tokenizers;
    }
    const result = [];
    for (const tokenizer of tokenizers) {
        if (tokenizer.odatatype === "#Microsoft.Azure.Search.PatternTokenizer") {
            const patternTokenizer = tokenizer;
            const flags = (_a = patternTokenizer.flags) === null || _a === void 0 ? void 0 : _a.split("|");
            result.push(Object.assign(Object.assign({}, tokenizer), { flags }));
        }
        else {
            result.push(tokenizer);
        }
    }
    return result;
}
function convertSimilarityToGenerated(similarity) {
    if (!similarity) {
        return similarity;
    }
    return similarity;
}
function convertSimilarityToPublic(similarity) {
    if (!similarity) {
        return similarity;
    }
    if (similarity.odatatype === "#Microsoft.Azure.Search.ClassicSimilarity") {
        return similarity;
    }
    else {
        return similarity;
    }
}
function convertEncryptionKeyToPublic(encryptionKey) {
    if (!encryptionKey) {
        return encryptionKey;
    }
    const result = {
        keyName: encryptionKey.keyName,
        keyVersion: encryptionKey.keyVersion,
        vaultUrl: encryptionKey.vaultUri,
    };
    if (encryptionKey.accessCredentials) {
        result.applicationId = encryptionKey.accessCredentials.applicationId;
        result.applicationSecret = encryptionKey.accessCredentials.applicationSecret;
    }
    return result;
}
function convertEncryptionKeyToGenerated(encryptionKey) {
    if (!encryptionKey) {
        return encryptionKey;
    }
    const result = {
        keyName: encryptionKey.keyName,
        keyVersion: encryptionKey.keyVersion,
        vaultUri: encryptionKey.vaultUrl,
    };
    if (encryptionKey.applicationId) {
        result.accessCredentials = {
            applicationId: encryptionKey.applicationId,
            applicationSecret: encryptionKey.applicationSecret,
        };
    }
    return result;
}
function generatedIndexToPublicIndex(generatedIndex) {
    return {
        name: generatedIndex.name,
        defaultScoringProfile: generatedIndex.defaultScoringProfile,
        corsOptions: generatedIndex.corsOptions,
        suggesters: generatedIndex.suggesters,
        encryptionKey: convertEncryptionKeyToPublic(generatedIndex.encryptionKey),
        etag: generatedIndex.etag,
        analyzers: convertAnalyzersToPublic(generatedIndex.analyzers),
        tokenizers: convertTokenizersToPublic(generatedIndex.tokenizers),
        tokenFilters: generatedIndex.tokenFilters,
        charFilters: generatedIndex.charFilters,
        scoringProfiles: generatedIndex.scoringProfiles,
        fields: convertFieldsToPublic(generatedIndex.fields),
        similarity: convertSimilarityToPublic(generatedIndex.similarity),
        semanticSearch: generatedIndex.semanticSearch,
        vectorSearch: generatedVectorSearchToPublicVectorSearch(generatedIndex.vectorSearch),
    };
}
function generatedVectorSearchAlgorithmConfigurationToPublicVectorSearchAlgorithmConfiguration(generatedAlgorithmConfiguration) {
    var _a;
    if (!generatedAlgorithmConfiguration) {
        return generatedAlgorithmConfiguration;
    }
    if (["hnsw", "exhaustiveKnn"].includes(generatedAlgorithmConfiguration.kind)) {
        const algorithmConfiguration = generatedAlgorithmConfiguration;
        const metric = (_a = algorithmConfiguration.parameters) === null || _a === void 0 ? void 0 : _a.metric;
        return Object.assign(Object.assign({}, algorithmConfiguration), { parameters: Object.assign(Object.assign({}, algorithmConfiguration.parameters), { metric }) });
    }
    throw Error("Unsupported algorithm configuration");
}
function generatedVectorSearchToPublicVectorSearch(vectorSearch) {
    var _a;
    if (!vectorSearch) {
        return vectorSearch;
    }
    return Object.assign(Object.assign({}, vectorSearch), { algorithms: (_a = vectorSearch.algorithms) === null || _a === void 0 ? void 0 : _a.map(generatedVectorSearchAlgorithmConfigurationToPublicVectorSearchAlgorithmConfiguration) });
}
function generatedSearchResultToPublicSearchResult(results) {
    const returnValues = results.map((result) => {
        const { _score: score, _highlights: highlights, _rerankerScore: rerankerScore, _captions: captions } = result, restProps = tslib.__rest(result, ["_score", "_highlights", "_rerankerScore", "_captions"]);
        const obj = {
            score,
            highlights,
            rerankerScore,
            captions,
            document: restProps, // todo: make this change in beta
        };
        return obj;
    });
    return returnValues;
}
function generatedSuggestDocumentsResultToPublicSuggestDocumentsResult(searchDocumentsResult) {
    const results = searchDocumentsResult.results.map((element) => {
        const { _text } = element, restProps = tslib.__rest(element, ["_text"]);
        const obj = {
            text: _text,
            document: restProps, // todo: make this change in beta
        };
        return obj;
    });
    const result = {
        results: results,
        coverage: searchDocumentsResult.coverage,
    };
    return result;
}
function publicIndexToGeneratedIndex(index) {
    const { encryptionKey, tokenFilters, analyzers, tokenizers, fields, similarity } = index;
    return Object.assign(Object.assign({}, index), { encryptionKey: convertEncryptionKeyToGenerated(encryptionKey), tokenFilters: convertTokenFiltersToGenerated(tokenFilters), analyzers: convertAnalyzersToGenerated(analyzers), tokenizers: convertTokenizersToGenerated(tokenizers), fields: convertFieldsToGenerated(fields), similarity: convertSimilarityToGenerated(similarity) });
}
function generatedSkillsetToPublicSkillset(generatedSkillset) {
    const { skills, cognitiveServicesAccount, knowledgeStore, encryptionKey } = generatedSkillset, props = tslib.__rest(generatedSkillset, ["skills", "cognitiveServicesAccount", "knowledgeStore", "encryptionKey"]);
    return Object.assign(Object.assign({}, props), { skills: convertSkillsToPublic(skills), cognitiveServicesAccount: convertCognitiveServicesAccountToPublic(cognitiveServicesAccount), knowledgeStore: convertKnowledgeStoreToPublic(knowledgeStore), encryptionKey: convertEncryptionKeyToPublic(encryptionKey) });
}
function publicSkillsetToGeneratedSkillset(skillset) {
    return {
        name: skillset.name,
        description: skillset.description,
        etag: skillset.etag,
        skills: skillset.skills,
        cognitiveServicesAccount: convertCognitiveServicesAccountToGenerated(skillset.cognitiveServicesAccount),
        knowledgeStore: skillset.knowledgeStore,
        encryptionKey: convertEncryptionKeyToGenerated(skillset.encryptionKey),
    };
}
function generatedSynonymMapToPublicSynonymMap(synonymMap) {
    const result = {
        name: synonymMap.name,
        encryptionKey: convertEncryptionKeyToPublic(synonymMap.encryptionKey),
        etag: synonymMap.etag,
        synonyms: [],
    };
    if (synonymMap.synonyms) {
        result.synonyms = synonymMap.synonyms.split("\n");
    }
    return result;
}
function publicSynonymMapToGeneratedSynonymMap(synonymMap) {
    const result = {
        name: synonymMap.name,
        format: "solr",
        encryptionKey: convertEncryptionKeyToGenerated(synonymMap.encryptionKey),
        etag: synonymMap.etag,
        synonyms: synonymMap.synonyms.join("\n"),
    };
    result.encryptionKey = convertEncryptionKeyToGenerated(synonymMap.encryptionKey);
    return result;
}
function publicSearchIndexerToGeneratedSearchIndexer(indexer) {
    return Object.assign(Object.assign({}, indexer), { encryptionKey: convertEncryptionKeyToGenerated(indexer.encryptionKey) });
}
function generatedSearchIndexerToPublicSearchIndexer(indexer) {
    var _a, _b, _c, _d;
    const { parsingMode, dataToExtract, imageAction, pdfTextRotationAlgorithm, executionEnvironment, } = (_b = (_a = indexer.parameters) === null || _a === void 0 ? void 0 : _a.configuration) !== null && _b !== void 0 ? _b : {};
    const configuration = ((_c = indexer.parameters) === null || _c === void 0 ? void 0 : _c.configuration) && Object.assign(Object.assign({}, (_d = indexer.parameters) === null || _d === void 0 ? void 0 : _d.configuration), { parsingMode: parsingMode, dataToExtract: dataToExtract, imageAction: imageAction, pdfTextRotationAlgorithm: pdfTextRotationAlgorithm, executionEnvironment: executionEnvironment });
    const parameters = Object.assign(Object.assign({}, indexer.parameters), { configuration });
    return Object.assign(Object.assign({}, indexer), { parameters, encryptionKey: convertEncryptionKeyToPublic(indexer.encryptionKey) });
}
function publicDataSourceToGeneratedDataSource(dataSource) {
    return {
        name: dataSource.name,
        description: dataSource.description,
        type: dataSource.type,
        credentials: {
            connectionString: dataSource.connectionString,
        },
        container: dataSource.container,
        etag: dataSource.etag,
        dataChangeDetectionPolicy: dataSource.dataChangeDetectionPolicy,
        dataDeletionDetectionPolicy: dataSource.dataDeletionDetectionPolicy,
        encryptionKey: convertEncryptionKeyToGenerated(dataSource.encryptionKey),
    };
}
function generatedDataSourceToPublicDataSource(dataSource) {
    return {
        name: dataSource.name,
        description: dataSource.name,
        type: dataSource.type,
        connectionString: dataSource.credentials.connectionString,
        container: dataSource.container,
        etag: dataSource.etag,
        dataChangeDetectionPolicy: convertDataChangeDetectionPolicyToPublic(dataSource.dataChangeDetectionPolicy),
        dataDeletionDetectionPolicy: convertDataDeletionDetectionPolicyToPublic(dataSource.dataDeletionDetectionPolicy),
        encryptionKey: convertEncryptionKeyToPublic(dataSource.encryptionKey),
    };
}
function convertDataChangeDetectionPolicyToPublic(dataChangeDetectionPolicy) {
    if (!dataChangeDetectionPolicy) {
        return dataChangeDetectionPolicy;
    }
    if (dataChangeDetectionPolicy.odatatype ===
        "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy") {
        return dataChangeDetectionPolicy;
    }
    else {
        return dataChangeDetectionPolicy;
    }
}
function convertDataDeletionDetectionPolicyToPublic(dataDeletionDetectionPolicy) {
    if (!dataDeletionDetectionPolicy) {
        return dataDeletionDetectionPolicy;
    }
    return dataDeletionDetectionPolicy;
}
function getRandomIntegerInclusive(min, max) {
    // Make sure inputs are integers.
    min = Math.ceil(min);
    max = Math.floor(max);
    // Pick a random offset from zero to the size of the range.
    // Since Math.random() can never return 1, we have to make the range one larger
    // in order to be inclusive of the maximum value after we take the floor.
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
}
/**
 * A wrapper for setTimeout that resolves a promise after timeInMs milliseconds.
 * @param timeInMs - The number of milliseconds to be delayed.
 * @returns Promise that is resolved after timeInMs
 */
function delay(timeInMs) {
    return new Promise((resolve) => setTimeout(() => resolve(), timeInMs));
}
const defaultServiceVersion = "2023-11-01";
function convertKnowledgeStoreToPublic(knowledgeStore) {
    return knowledgeStore;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Known values for Search Audience
 */
exports.KnownSearchAudience = void 0;
(function (KnownSearchAudience) {
    /**
     * Audience for Azure China
     */
    KnownSearchAudience["AzureChina"] = "https://search.azure.cn";
    /**
     * Audience for Azure Government
     */
    KnownSearchAudience["AzureGovernment"] = "https://search.azure.us";
    /**
     * Audience for Azure Public
     */
    KnownSearchAudience["AzurePublicCloud"] = "https://search.azure.com";
})(exports.KnownSearchAudience || (exports.KnownSearchAudience = {}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Class used to perform operations against a search index,
 * including querying documents in the index as well as
 * adding, updating, and removing them.
 */
class SearchClient {
    /**
     * Creates an instance of SearchClient.
     *
     * Example usage:
     * ```ts
     * const { SearchClient, AzureKeyCredential } = require("@azure/search-documents");
     *
     * const client = new SearchClient(
     *   "<endpoint>",
     *   "<indexName>",
     *   new AzureKeyCredential("<Admin Key>")
     * );
     * ```
     *
     * Optionally, the type of the model can be used to enable strong typing and type hints:
     * ```ts
     * type TModel = {
     *   keyName: string;
     *   field1?: string | null;
     *   field2?: { anotherField?: string | null } | null;
     * };
     *
     * const client = new SearchClient<TModel>(
     *   ...
     * );
     * ```
     *
     * @param endpoint - The endpoint of the search service
     * @param indexName - The name of the index
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Search client.
     *
     * @typeParam TModel - An optional type that represents the documents stored in
     * the search index. For the best typing experience, all non-key fields should
     * be marked optional and nullable, and the key property should have the
     * non-nullable type `string`.
     */
    constructor(endpoint, indexName, credential, options = {}) {
        var _a, _b;
        /// Maintenance note: when updating supported API versions,
        /// the ContinuationToken logic will need to be updated below.
        /**
         *  The service version to use when communicating with the service.
         */
        this.serviceVersion = defaultServiceVersion;
        /**
         * The API version to use when communicating with the service.
         * @deprecated use {@Link serviceVersion} instead
         */
        this.apiVersion = defaultServiceVersion;
        this.endpoint = endpoint;
        this.indexName = indexName;
        const internalClientPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
                additionalAllowedHeaderNames: [
                    "elapsed-time",
                    "Location",
                    "OData-MaxVersion",
                    "OData-Version",
                    "Prefer",
                    "throttle-reason",
                ],
            },
        });
        this.serviceVersion =
            (_b = (_a = options.serviceVersion) !== null && _a !== void 0 ? _a : options.apiVersion) !== null && _b !== void 0 ? _b : defaultServiceVersion;
        this.apiVersion = this.serviceVersion;
        this.client = new SearchClient$1(this.endpoint, this.indexName, this.serviceVersion, internalClientPipelineOptions);
        if (coreAuth.isTokenCredential(credential)) {
            const scope = options.audience
                ? `${options.audience}/.default`
                : `${exports.KnownSearchAudience.AzurePublicCloud}/.default`;
            this.client.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({ credential, scopes: scope }));
        }
        else {
            this.client.pipeline.addPolicy(createSearchApiKeyCredentialPolicy(credential));
        }
        this.client.pipeline.addPolicy(createOdataMetadataPolicy("none"));
    }
    /**
     * Retrieves the number of documents in the index.
     * @param options - Options to the count operation.
     */
    async getDocumentsCount(options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-getDocumentsCount", options);
        try {
            let documentsCount = 0;
            await this.client.documents.count(Object.assign(Object.assign({}, updatedOptions), { onResponse: (rawResponse, flatResponse) => {
                    documentsCount = Number(rawResponse.bodyAsText);
                    if (updatedOptions.onResponse) {
                        updatedOptions.onResponse(rawResponse, flatResponse);
                    }
                } }));
            return documentsCount;
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Based on a partial searchText from the user, return a list
     * of potential completion strings based on a specified suggester.
     * @param searchText - The search text on which to base autocomplete results.
     * @param suggesterName - The name of the suggester as specified in the suggesters collection that's part of the index definition.
     * @param options - Options to the autocomplete operation.
     * @example
     * ```ts
     * import {
     *   AzureKeyCredential,
     *   SearchClient,
     *   SearchFieldArray,
     * } from "@azure/search-documents";
     *
     * type TModel = {
     *   key: string;
     *   azure?: { sdk: string | null } | null;
     * };
     *
     * const client = new SearchClient<TModel>(
     *   "endpoint.azure",
     *   "indexName",
     *   new AzureKeyCredential("key")
     * );
     *
     * const searchFields: SearchFieldArray<TModel> = ["azure/sdk"];
     *
     * const autocompleteResult = await client.autocomplete(
     *   "searchText",
     *   "suggesterName",
     *   { searchFields }
     * );
     * ```
     */
    async autocomplete(searchText, suggesterName, options = {}) {
        const { searchFields } = options, nonFieldOptions = tslib.__rest(options, ["searchFields"]);
        const fullOptions = Object.assign({ searchText: searchText, suggesterName: suggesterName, searchFields: this.convertSearchFields(searchFields) }, nonFieldOptions);
        if (!fullOptions.searchText) {
            throw new RangeError("searchText must be provided.");
        }
        if (!fullOptions.suggesterName) {
            throw new RangeError("suggesterName must be provided.");
        }
        const { span, updatedOptions } = createSpan("SearchClient-autocomplete", options);
        try {
            const result = await this.client.documents.autocompletePost(fullOptions, updatedOptions);
            return result;
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async searchDocuments(searchText, options = {}, nextPageParameters = {}) {
        const { searchFields, select, orderBy, includeTotalCount, vectorSearchOptions } = options, restOptions = tslib.__rest(options, ["searchFields", "select", "orderBy", "includeTotalCount", "vectorSearchOptions"]);
        const semanticSearchOptions = restOptions
            .semanticSearchOptions;
        delete restOptions.semanticSearchOptions;
        const _a = semanticSearchOptions !== null && semanticSearchOptions !== void 0 ? semanticSearchOptions : {}, { configurationName, errorMode, answers, captions } = _a, restSemanticOptions = tslib.__rest(_a, ["configurationName", "errorMode", "answers", "captions"]);
        const _b = vectorSearchOptions !== null && vectorSearchOptions !== void 0 ? vectorSearchOptions : {}, { queries, filterMode } = _b, restVectorOptions = tslib.__rest(_b, ["queries", "filterMode"]);
        const fullOptions = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, restSemanticOptions), restVectorOptions), restOptions), nextPageParameters), { searchFields: this.convertSearchFields(searchFields), select: this.convertSelect(select) || "*", orderBy: this.convertOrderBy(orderBy), includeTotalResultCount: includeTotalCount, vectorQueries: queries === null || queries === void 0 ? void 0 : queries.map(this.convertVectorQuery.bind(this)), answers: this.convertQueryAnswers(answers), captions: this.convertCaptions(captions), semanticErrorHandling: errorMode, semanticConfigurationName: configurationName, vectorFilterMode: filterMode });
        const { span, updatedOptions } = createSpan("SearchClient-searchDocuments", options);
        try {
            const result = await this.client.documents.searchPost(Object.assign(Object.assign({}, fullOptions), { searchText: searchText }), updatedOptions);
            const { results, nextLink, nextPageParameters: resultNextPageParameters, semanticPartialResponseReason: semanticErrorReason, semanticPartialResponseType: semanticSearchResultsType } = result, restResult = tslib.__rest(result, ["results", "nextLink", "nextPageParameters", "semanticPartialResponseReason", "semanticPartialResponseType"]);
            const modifiedResults = generatedSearchResultToPublicSearchResult(results);
            const converted = Object.assign(Object.assign({}, restResult), { results: modifiedResults, semanticErrorReason: semanticErrorReason, semanticSearchResultsType: semanticSearchResultsType, continuationToken: this.encodeContinuationToken(nextLink, resultNextPageParameters) });
            return deserialize(converted);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    listSearchResultsPage(searchText, options = {}, settings = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSearchResultsPage_1() {
            let decodedContinuation = this.decodeContinuationToken(settings.continuationToken);
            let result = yield tslib.__await(this.searchDocuments(searchText, options, decodedContinuation === null || decodedContinuation === void 0 ? void 0 : decodedContinuation.nextPageParameters));
            yield yield tslib.__await(result);
            // Technically, we should also leverage nextLink, but the generated code
            // doesn't support this yet.
            while (result.continuationToken) {
                decodedContinuation = this.decodeContinuationToken(result.continuationToken);
                result = yield tslib.__await(this.searchDocuments(searchText, options, decodedContinuation === null || decodedContinuation === void 0 ? void 0 : decodedContinuation.nextPageParameters));
                yield yield tslib.__await(result);
            }
        });
    }
    listSearchResultsAll(firstPage, searchText, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSearchResultsAll_1() {
            var _a, e_1, _b, _c;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(firstPage.results)));
            if (firstPage.continuationToken) {
                try {
                    for (var _d = true, _e = tslib.__asyncValues(this.listSearchResultsPage(searchText, options, {
                        continuationToken: firstPage.continuationToken,
                    })), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                        _c = _f.value;
                        _d = false;
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page.results)));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        });
    }
    listSearchResults(firstPage, searchText, options = {}) {
        const iter = this.listSearchResultsAll(firstPage, searchText, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                return this.listSearchResultsPage(searchText, options, settings);
            },
        };
    }
    /**
     * Performs a search on the current index given
     * the specified arguments.
     * @param searchText - Text to search
     * @param options - Options for the search operation.
     * @example
     * ```ts
     * import {
     *   AzureKeyCredential,
     *   SearchClient,
     *   SearchFieldArray,
     * } from "@azure/search-documents";
     *
     * type TModel = {
     *   key: string;
     *   azure?: { sdk: string | null } | null;
     * };
     *
     * const client = new SearchClient<TModel>(
     *   "endpoint.azure",
     *   "indexName",
     *   new AzureKeyCredential("key")
     * );
     *
     * const select = ["azure/sdk"] as const;
     * const searchFields: SearchFieldArray<TModel> = ["azure/sdk"];
     *
     * const searchResult = await client.search("searchText", {
     *   select,
     *   searchFields,
     * });
     * ```
     */
    async search(searchText, options) {
        const { span, updatedOptions } = createSpan("SearchClient-search", options);
        try {
            const pageResult = await this.searchDocuments(searchText, updatedOptions);
            return Object.assign(Object.assign({}, pageResult), { results: this.listSearchResults(pageResult, searchText, updatedOptions) });
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns a short list of suggestions based on the searchText
     * and specified suggester.
     * @param searchText - The search text to use to suggest documents. Must be at least 1 character, and no more than 100 characters.
     * @param suggesterName - The name of the suggester as specified in the suggesters collection that's part of the index definition.
     * @param options - Options for the suggest operation
     * @example
     * ```ts
     * import {
     *   AzureKeyCredential,
     *   SearchClient,
     *   SearchFieldArray,
     * } from "@azure/search-documents";
     *
     * type TModel = {
     *   key: string;
     *   azure?: { sdk: string | null } | null;
     * };
     *
     * const client = new SearchClient<TModel>(
     *   "endpoint.azure",
     *   "indexName",
     *   new AzureKeyCredential("key")
     * );
     *
     * const select = ["azure/sdk"] as const;
     * const searchFields: SearchFieldArray<TModel> = ["azure/sdk"];
     *
     * const suggestResult = await client.suggest("searchText", "suggesterName", {
     *   select,
     *   searchFields,
     * });
     * ```
     */
    async suggest(searchText, suggesterName, options = {}) {
        const { select, searchFields, orderBy } = options, nonFieldOptions = tslib.__rest(options, ["select", "searchFields", "orderBy"]);
        const fullOptions = Object.assign({ searchText: searchText, suggesterName: suggesterName, searchFields: this.convertSearchFields(searchFields), select: this.convertSelect(select), orderBy: this.convertOrderBy(orderBy) }, nonFieldOptions);
        if (!fullOptions.searchText) {
            throw new RangeError("searchText must be provided.");
        }
        if (!fullOptions.suggesterName) {
            throw new RangeError("suggesterName must be provided.");
        }
        const { span, updatedOptions } = createSpan("SearchClient-suggest", options);
        try {
            const result = await this.client.documents.suggestPost(fullOptions, updatedOptions);
            const modifiedResult = generatedSuggestDocumentsResultToPublicSuggestDocumentsResult(result);
            return deserialize(modifiedResult);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieve a particular document from the index by key.
     * @param key - The primary key value of the document
     * @param options - Additional options
     */
    async getDocument(key, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-getDocument", options);
        try {
            const result = await this.client.documents.get(key, Object.assign(Object.assign({}, updatedOptions), { selectedFields: updatedOptions.selectedFields }));
            return deserialize(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Perform a set of index modifications (upload, merge, mergeOrUpload, delete)
     * for the given set of documents.
     * This operation may partially succeed and not all document operations will
     * be reflected in the index. If you would like to treat this as an exception,
     * set the `throwOnAnyFailure` option to true.
     * For more details about how merging works, see: https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param batch - An array of actions to perform on the index.
     * @param options - Additional options.
     */
    async indexDocuments(
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    batch, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-indexDocuments", options);
        try {
            let status = 0;
            const result = await this.client.documents.index({ actions: serialize(batch.actions) }, Object.assign(Object.assign({}, updatedOptions), { onResponse: (rawResponse, flatResponse) => {
                    status = rawResponse.status;
                    if (updatedOptions.onResponse) {
                        updatedOptions.onResponse(rawResponse, flatResponse);
                    }
                } }));
            if (options.throwOnAnyFailure && status === 207) {
                throw result;
            }
            return result;
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Upload an array of documents to the index.
     * @param documents - The documents to upload.
     * @param options - Additional options.
     */
    async uploadDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-uploadDocuments", options);
        const batch = new IndexDocumentsBatch();
        batch.upload(documents);
        try {
            return await this.indexDocuments(batch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Update a set of documents in the index.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents - The updated documents.
     * @param options - Additional options.
     */
    async mergeDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-mergeDocuments", options);
        const batch = new IndexDocumentsBatch();
        batch.merge(documents);
        try {
            return await this.indexDocuments(batch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Update a set of documents in the index or upload them if they don't exist.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents - The updated documents.
     * @param options - Additional options.
     */
    async mergeOrUploadDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-mergeDocuments", options);
        const batch = new IndexDocumentsBatch();
        batch.mergeOrUpload(documents);
        try {
            return await this.indexDocuments(batch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async deleteDocuments(keyNameOrDocuments, keyValuesOrOptions, options = {}) {
        const { span, updatedOptions } = createSpan("SearchClient-deleteDocuments", options);
        const batch = new IndexDocumentsBatch();
        if (typeof keyNameOrDocuments === "string") {
            batch.delete(keyNameOrDocuments, keyValuesOrOptions);
        }
        else {
            batch.delete(keyNameOrDocuments);
        }
        try {
            return await this.indexDocuments(batch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    encodeContinuationToken(nextLink, nextPageParameters) {
        if (!nextLink || !nextPageParameters) {
            return undefined;
        }
        const payload = JSON.stringify({
            apiVersion: this.apiVersion,
            nextLink,
            nextPageParameters,
        });
        return encode(payload);
    }
    decodeContinuationToken(token) {
        if (!token) {
            return undefined;
        }
        const decodedToken = decode(token);
        try {
            const result = JSON.parse(decodedToken);
            if (result.apiVersion !== this.apiVersion) {
                throw new RangeError(`Continuation token uses unsupported apiVersion "${this.apiVersion}"`);
            }
            return {
                nextLink: result.nextLink,
                nextPageParameters: result.nextPageParameters,
            };
        }
        catch (e) {
            throw new Error(`Corrupted or invalid continuation token: ${decodedToken}`);
        }
    }
    convertSelect(select) {
        if (select) {
            return select.join(",");
        }
        return select;
    }
    convertVectorQueryFields(fields) {
        if (fields) {
            return fields.join(",");
        }
        return fields;
    }
    convertSearchFields(searchFields) {
        if (searchFields) {
            return searchFields.join(",");
        }
        return searchFields;
    }
    convertOrderBy(orderBy) {
        if (orderBy) {
            return orderBy.join(",");
        }
        return orderBy;
    }
    convertQueryAnswers(answers) {
        if (!answers) {
            return answers;
        }
        const config = [];
        const { answerType: output, count, threshold } = answers;
        if (count) {
            config.push(`count-${count}`);
        }
        if (threshold) {
            config.push(`threshold-${threshold}`);
        }
        if (config.length) {
            return output + `|${config.join(",")}`;
        }
        return output;
    }
    convertCaptions(captions) {
        if (!captions) {
            return captions;
        }
        const config = [];
        const { captionType: output, highlight } = captions;
        if (highlight !== undefined) {
            config.push(`highlight-${highlight}`);
        }
        if (config.length) {
            return output + `|${config.join(",")}`;
        }
        return output;
    }
    convertVectorQuery(vectorQuery) {
        if (!vectorQuery) {
            return vectorQuery;
        }
        return Object.assign(Object.assign({}, vectorQuery), { fields: this.convertVectorQueryFields(vectorQuery === null || vectorQuery === void 0 ? void 0 : vectorQuery.fields) });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Default Batch Size
 */
const DEFAULT_BATCH_SIZE = 512;
/**
 * Default window flush interval
 */
const DEFAULT_FLUSH_WINDOW = 60000;
/**
 * Default number of times to retry.
 */
const DEFAULT_RETRY_COUNT = 3;
/**
 * Default Max Delay between retries.
 */
const DEFAULT_MAX_RETRY_DELAY = 60000;
/**
 * Class used to perform buffered operations against a search index,
 * including adding, updating, and removing them.
 */
class SearchIndexingBufferedSender {
    /**
     * Creates a new instance of SearchIndexingBufferedSender.
     *
     * @param client - Search Client used to call the underlying IndexBatch operations.
     * @param options - Options to modify auto flush.
     *
     */
    constructor(client, documentKeyRetriever, options = {}) {
        var _a, _b, _c, _d, _e, _f;
        /**
         * Event emitter/publisher used in the Buffered Sender
         */
        this.emitter = new EventEmitter();
        this.client = client;
        this.documentKeyRetriever = documentKeyRetriever;
        // General Configuration properties
        this.autoFlush = (_a = options.autoFlush) !== null && _a !== void 0 ? _a : true;
        this.initialBatchActionCount = (_b = options.initialBatchActionCount) !== null && _b !== void 0 ? _b : DEFAULT_BATCH_SIZE;
        this.flushWindowInMs = (_c = options.flushWindowInMs) !== null && _c !== void 0 ? _c : DEFAULT_FLUSH_WINDOW;
        // Retry specific configuration properties
        this.throttlingDelayInMs = (_d = options.throttlingDelayInMs) !== null && _d !== void 0 ? _d : DEFAULT_FLUSH_WINDOW;
        this.maxRetriesPerAction = (_e = options.maxRetriesPerAction) !== null && _e !== void 0 ? _e : DEFAULT_RETRY_COUNT;
        this.maxThrottlingDelayInMs = (_f = options.maxThrottlingDelayInMs) !== null && _f !== void 0 ? _f : DEFAULT_MAX_RETRY_DELAY;
        this.batchObject = new IndexDocumentsBatch();
        if (this.autoFlush) {
            const interval = setInterval(() => this.flush(), this.flushWindowInMs);
            interval === null || interval === void 0 ? void 0 : interval.unref();
            this.cleanupTimer = () => {
                clearInterval(interval);
            };
        }
    }
    /**
     * Uploads the documents/Adds the documents to the upload queue.
     *
     * @param documents - Documents to be uploaded.
     * @param options - Upload options.
     */
    async uploadDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexingBufferedSender-uploadDocuments", options);
        try {
            this.batchObject.upload(documents);
            this.emitter.emit("batchAdded", {
                action: "upload",
                documents,
            });
            return this.internalFlush(false, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Merges the documents/Adds the documents to the merge queue.
     *
     * @param documents - Documents to be merged.
     * @param options - Upload options.
     */
    async mergeDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexingBufferedSender-mergeDocuments", options);
        try {
            this.batchObject.merge(documents);
            this.emitter.emit("batchAdded", {
                action: "merge",
                documents,
            });
            return this.internalFlush(false, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Merges/Uploads the documents/Adds the documents to the merge/upload queue.
     *
     * @param documents - Documents to be merged/uploaded.
     * @param options - Upload options.
     */
    async mergeOrUploadDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexingBufferedSender-mergeOrUploadDocuments", options);
        try {
            this.batchObject.mergeOrUpload(documents);
            this.emitter.emit("batchAdded", {
                action: "mergeOrUpload",
                documents,
            });
            return this.internalFlush(false, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes the documents/Adds the documents to the delete queue.
     *
     * @param documents - Documents to be deleted.
     * @param options - Upload options.
     */
    async deleteDocuments(documents, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexingBufferedSender-deleteDocuments", options);
        try {
            this.batchObject.delete(documents);
            this.emitter.emit("batchAdded", {
                action: "delete",
                documents,
            });
            return this.internalFlush(false, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Flushes the queue manually.
     *
     * @param options - Flush options.
     */
    async flush(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexingBufferedSender-flush", options);
        try {
            if (this.batchObject.actions.length > 0) {
                return this.internalFlush(true, updatedOptions);
            }
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * If using autoFlush: true, call this to cleanup the autoflush timer.
     */
    async dispose() {
        if (this.batchObject.actions.length > 0) {
            await this.internalFlush(true);
        }
        if (this.cleanupTimer) {
            this.cleanupTimer();
        }
    }
    on(event, listener) {
        this.emitter.on(event, listener);
    }
    off(event, listener) {
        this.emitter.removeListener(event, listener);
    }
    isBatchReady() {
        return this.batchObject.actions.length >= this.initialBatchActionCount;
    }
    async internalFlush(force, options = {}) {
        if (force || (this.autoFlush && this.isBatchReady())) {
            // Split it
            const actions = this.batchObject.actions;
            this.batchObject = new IndexDocumentsBatch();
            while (actions.length > 0) {
                const actionsToSend = actions.splice(0, this.initialBatchActionCount);
                const { batchToSubmit, submitLater } = this.pruneActions(actionsToSend);
                actions.unshift(...submitLater);
                await this.submitDocuments(batchToSubmit, options);
            }
        }
    }
    pruneActions(batch) {
        const hashSet = new Set();
        const resultBatch = [];
        const pruned = [];
        for (const document of batch) {
            const key = this.documentKeyRetriever(document);
            if (hashSet.has(key)) {
                pruned.push(document);
            }
            else {
                hashSet.add(key);
                resultBatch.push(document);
            }
        }
        return { batchToSubmit: resultBatch, submitLater: pruned };
    }
    async submitDocuments(actionsToSend, options, retryAttempt = 1) {
        try {
            for (const action of actionsToSend) {
                this.emitter.emit("beforeDocumentSent", action);
            }
            const result = await this.client.indexDocuments(new IndexDocumentsBatch(actionsToSend), options);
            // raise success event
            this.emitter.emit("batchSucceeded", result);
        }
        catch (e) {
            if (e.statusCode && e.statusCode === 413 && actionsToSend.length > 1) {
                // Cut the payload size to half
                const splitActionsArray = [
                    actionsToSend.slice(0, actionsToSend.length / 2),
                    actionsToSend.slice(actionsToSend.length / 2, actionsToSend.length),
                ];
                this.initialBatchActionCount = splitActionsArray[0].length; // So, we do not want 413 happening again and again
                for (const actions of splitActionsArray) {
                    await this.submitDocuments(actions, options);
                }
            }
            else if (this.isRetryAbleError(e) && retryAttempt <= this.maxRetriesPerAction) {
                // Exponentially increase the delay each time
                const exponentialDelay = this.throttlingDelayInMs * Math.pow(2, retryAttempt);
                // Don't let the delay exceed the maximum
                const clampedExponentialDelay = Math.min(this.maxThrottlingDelayInMs, exponentialDelay);
                // Allow the final value to have some "jitter" (within 50% of the delay size) so
                // that retries across multiple clients don't occur simultaneously.
                const delayWithJitter = clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);
                await delay(delayWithJitter);
                await this.submitDocuments(actionsToSend, options, retryAttempt + 1);
            }
            else {
                this.emitter.emit("batchFailed", e);
                throw e;
            }
        }
    }
    isRetryAbleError(e) {
        return e.statusCode && (e.statusCode === 422 || e.statusCode === 409 || e.statusCode === 503);
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const SearchIndexerDataSource = {
    type: {
        name: "Composite",
        className: "SearchIndexerDataSource",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "DataSourceCredentials"
                }
            },
            container: {
                serializedName: "container",
                type: {
                    name: "Composite",
                    className: "SearchIndexerDataContainer"
                }
            },
            dataChangeDetectionPolicy: {
                serializedName: "dataChangeDetectionPolicy",
                type: {
                    name: "Composite",
                    className: "DataChangeDetectionPolicy"
                }
            },
            dataDeletionDetectionPolicy: {
                serializedName: "dataDeletionDetectionPolicy",
                type: {
                    name: "Composite",
                    className: "DataDeletionDetectionPolicy"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            },
            encryptionKey: {
                serializedName: "encryptionKey",
                type: {
                    name: "Composite",
                    className: "SearchResourceEncryptionKey"
                }
            }
        }
    }
};
const DataSourceCredentials = {
    type: {
        name: "Composite",
        className: "DataSourceCredentials",
        modelProperties: {
            connectionString: {
                serializedName: "connectionString",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerDataContainer = {
    type: {
        name: "Composite",
        className: "SearchIndexerDataContainer",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            query: {
                serializedName: "query",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataChangeDetectionPolicy = {
    type: {
        name: "Composite",
        className: "DataChangeDetectionPolicy",
        uberParent: "DataChangeDetectionPolicy",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataDeletionDetectionPolicy = {
    type: {
        name: "Composite",
        className: "DataDeletionDetectionPolicy",
        uberParent: "DataDeletionDetectionPolicy",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchResourceEncryptionKey = {
    type: {
        name: "Composite",
        className: "SearchResourceEncryptionKey",
        modelProperties: {
            keyName: {
                serializedName: "keyVaultKeyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                serializedName: "keyVaultKeyVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            vaultUri: {
                serializedName: "keyVaultUri",
                required: true,
                type: {
                    name: "String"
                }
            },
            accessCredentials: {
                serializedName: "accessCredentials",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectoryApplicationCredentials"
                }
            }
        }
    }
};
const AzureActiveDirectoryApplicationCredentials = {
    type: {
        name: "Composite",
        className: "AzureActiveDirectoryApplicationCredentials",
        modelProperties: {
            applicationId: {
                serializedName: "applicationId",
                required: true,
                type: {
                    name: "String"
                }
            },
            applicationSecret: {
                serializedName: "applicationSecret",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchError = {
    type: {
        name: "Composite",
        className: "SearchError",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchError"
                        }
                    }
                }
            }
        }
    }
};
const ListDataSourcesResult = {
    type: {
        name: "Composite",
        className: "ListDataSourcesResult",
        modelProperties: {
            dataSources: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerDataSource"
                        }
                    }
                }
            }
        }
    }
};
const SearchIndexer = {
    type: {
        name: "Composite",
        className: "SearchIndexer",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            dataSourceName: {
                serializedName: "dataSourceName",
                required: true,
                type: {
                    name: "String"
                }
            },
            skillsetName: {
                serializedName: "skillsetName",
                type: {
                    name: "String"
                }
            },
            targetIndexName: {
                serializedName: "targetIndexName",
                required: true,
                type: {
                    name: "String"
                }
            },
            schedule: {
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "IndexingSchedule"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "IndexingParameters"
                }
            },
            fieldMappings: {
                serializedName: "fieldMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FieldMapping"
                        }
                    }
                }
            },
            outputFieldMappings: {
                serializedName: "outputFieldMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FieldMapping"
                        }
                    }
                }
            },
            isDisabled: {
                defaultValue: false,
                serializedName: "disabled",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            },
            encryptionKey: {
                serializedName: "encryptionKey",
                type: {
                    name: "Composite",
                    className: "SearchResourceEncryptionKey"
                }
            }
        }
    }
};
const IndexingSchedule = {
    type: {
        name: "Composite",
        className: "IndexingSchedule",
        modelProperties: {
            interval: {
                serializedName: "interval",
                required: true,
                type: {
                    name: "TimeSpan"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const IndexingParameters = {
    type: {
        name: "Composite",
        className: "IndexingParameters",
        modelProperties: {
            batchSize: {
                serializedName: "batchSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            maxFailedItems: {
                defaultValue: 0,
                serializedName: "maxFailedItems",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            maxFailedItemsPerBatch: {
                defaultValue: 0,
                serializedName: "maxFailedItemsPerBatch",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            configuration: {
                serializedName: "configuration",
                type: {
                    name: "Composite",
                    className: "IndexingParametersConfiguration"
                }
            }
        }
    }
};
const IndexingParametersConfiguration = {
    type: {
        name: "Composite",
        className: "IndexingParametersConfiguration",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            parsingMode: {
                defaultValue: "default",
                serializedName: "parsingMode",
                type: {
                    name: "String"
                }
            },
            excludedFileNameExtensions: {
                defaultValue: "",
                serializedName: "excludedFileNameExtensions",
                type: {
                    name: "String"
                }
            },
            indexedFileNameExtensions: {
                defaultValue: "",
                serializedName: "indexedFileNameExtensions",
                type: {
                    name: "String"
                }
            },
            failOnUnsupportedContentType: {
                defaultValue: false,
                serializedName: "failOnUnsupportedContentType",
                type: {
                    name: "Boolean"
                }
            },
            failOnUnprocessableDocument: {
                defaultValue: false,
                serializedName: "failOnUnprocessableDocument",
                type: {
                    name: "Boolean"
                }
            },
            indexStorageMetadataOnlyForOversizedDocuments: {
                defaultValue: false,
                serializedName: "indexStorageMetadataOnlyForOversizedDocuments",
                type: {
                    name: "Boolean"
                }
            },
            delimitedTextHeaders: {
                serializedName: "delimitedTextHeaders",
                type: {
                    name: "String"
                }
            },
            delimitedTextDelimiter: {
                serializedName: "delimitedTextDelimiter",
                type: {
                    name: "String"
                }
            },
            firstLineContainsHeaders: {
                defaultValue: true,
                serializedName: "firstLineContainsHeaders",
                type: {
                    name: "Boolean"
                }
            },
            documentRoot: {
                serializedName: "documentRoot",
                type: {
                    name: "String"
                }
            },
            dataToExtract: {
                defaultValue: "contentAndMetadata",
                serializedName: "dataToExtract",
                type: {
                    name: "String"
                }
            },
            imageAction: {
                defaultValue: "none",
                serializedName: "imageAction",
                type: {
                    name: "String"
                }
            },
            allowSkillsetToReadFileData: {
                defaultValue: false,
                serializedName: "allowSkillsetToReadFileData",
                type: {
                    name: "Boolean"
                }
            },
            pdfTextRotationAlgorithm: {
                defaultValue: "none",
                serializedName: "pdfTextRotationAlgorithm",
                type: {
                    name: "String"
                }
            },
            executionEnvironment: {
                defaultValue: "standard",
                serializedName: "executionEnvironment",
                type: {
                    name: "String"
                }
            },
            queryTimeout: {
                defaultValue: "00:05:00",
                serializedName: "queryTimeout",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FieldMapping = {
    type: {
        name: "Composite",
        className: "FieldMapping",
        modelProperties: {
            sourceFieldName: {
                serializedName: "sourceFieldName",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetFieldName: {
                serializedName: "targetFieldName",
                type: {
                    name: "String"
                }
            },
            mappingFunction: {
                serializedName: "mappingFunction",
                type: {
                    name: "Composite",
                    className: "FieldMappingFunction"
                }
            }
        }
    }
};
const FieldMappingFunction = {
    type: {
        name: "Composite",
        className: "FieldMappingFunction",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const ListIndexersResult = {
    type: {
        name: "Composite",
        className: "ListIndexersResult",
        modelProperties: {
            indexers: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexer"
                        }
                    }
                }
            }
        }
    }
};
const SearchIndexerStatus = {
    type: {
        name: "Composite",
        className: "SearchIndexerStatus",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["unknown", "error", "running"]
                }
            },
            lastResult: {
                serializedName: "lastResult",
                type: {
                    name: "Composite",
                    className: "IndexerExecutionResult"
                }
            },
            executionHistory: {
                serializedName: "executionHistory",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IndexerExecutionResult"
                        }
                    }
                }
            },
            limits: {
                serializedName: "limits",
                type: {
                    name: "Composite",
                    className: "SearchIndexerLimits"
                }
            }
        }
    }
};
const IndexerExecutionResult = {
    type: {
        name: "Composite",
        className: "IndexerExecutionResult",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["transientFailure", "success", "inProgress", "reset"]
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                nullable: true,
                type: {
                    name: "DateTime"
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerError"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerWarning"
                        }
                    }
                }
            },
            itemCount: {
                serializedName: "itemsProcessed",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            failedItemCount: {
                serializedName: "itemsFailed",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            initialTrackingState: {
                serializedName: "initialTrackingState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            finalTrackingState: {
                serializedName: "finalTrackingState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerError = {
    type: {
        name: "Composite",
        className: "SearchIndexerError",
        modelProperties: {
            key: {
                serializedName: "key",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            documentationLink: {
                serializedName: "documentationLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerWarning = {
    type: {
        name: "Composite",
        className: "SearchIndexerWarning",
        modelProperties: {
            key: {
                serializedName: "key",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            documentationLink: {
                serializedName: "documentationLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerLimits = {
    type: {
        name: "Composite",
        className: "SearchIndexerLimits",
        modelProperties: {
            maxRunTime: {
                serializedName: "maxRunTime",
                readOnly: true,
                type: {
                    name: "TimeSpan"
                }
            },
            maxDocumentExtractionSize: {
                serializedName: "maxDocumentExtractionSize",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxDocumentContentCharactersToExtract: {
                serializedName: "maxDocumentContentCharactersToExtract",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SearchIndexerSkillset = {
    type: {
        name: "Composite",
        className: "SearchIndexerSkillset",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            skills: {
                serializedName: "skills",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerSkill"
                        }
                    }
                }
            },
            cognitiveServicesAccount: {
                serializedName: "cognitiveServices",
                type: {
                    name: "Composite",
                    className: "CognitiveServicesAccount"
                }
            },
            knowledgeStore: {
                serializedName: "knowledgeStore",
                type: {
                    name: "Composite",
                    className: "SearchIndexerKnowledgeStore"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            },
            encryptionKey: {
                serializedName: "encryptionKey",
                type: {
                    name: "Composite",
                    className: "SearchResourceEncryptionKey"
                }
            }
        }
    }
};
const SearchIndexerSkill = {
    type: {
        name: "Composite",
        className: "SearchIndexerSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            context: {
                serializedName: "context",
                type: {
                    name: "String"
                }
            },
            inputs: {
                serializedName: "inputs",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InputFieldMappingEntry"
                        }
                    }
                }
            },
            outputs: {
                serializedName: "outputs",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutputFieldMappingEntry"
                        }
                    }
                }
            }
        }
    }
};
const InputFieldMappingEntry = {
    type: {
        name: "Composite",
        className: "InputFieldMappingEntry",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "source",
                type: {
                    name: "String"
                }
            },
            sourceContext: {
                serializedName: "sourceContext",
                type: {
                    name: "String"
                }
            },
            inputs: {
                serializedName: "inputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InputFieldMappingEntry"
                        }
                    }
                }
            }
        }
    }
};
const OutputFieldMappingEntry = {
    type: {
        name: "Composite",
        className: "OutputFieldMappingEntry",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetName: {
                serializedName: "targetName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CognitiveServicesAccount = {
    type: {
        name: "Composite",
        className: "CognitiveServicesAccount",
        uberParent: "CognitiveServicesAccount",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerKnowledgeStore = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStore",
        modelProperties: {
            storageConnectionString: {
                serializedName: "storageConnectionString",
                required: true,
                type: {
                    name: "String"
                }
            },
            projections: {
                serializedName: "projections",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerKnowledgeStoreProjection"
                        }
                    }
                }
            }
        }
    }
};
const SearchIndexerKnowledgeStoreProjection = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStoreProjection",
        modelProperties: {
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerKnowledgeStoreTableProjectionSelector"
                        }
                    }
                }
            },
            objects: {
                serializedName: "objects",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerKnowledgeStoreObjectProjectionSelector"
                        }
                    }
                }
            },
            files: {
                serializedName: "files",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerKnowledgeStoreFileProjectionSelector"
                        }
                    }
                }
            }
        }
    }
};
const SearchIndexerKnowledgeStoreProjectionSelector = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStoreProjectionSelector",
        modelProperties: {
            referenceKeyName: {
                serializedName: "referenceKeyName",
                type: {
                    name: "String"
                }
            },
            generatedKeyName: {
                serializedName: "generatedKeyName",
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "source",
                type: {
                    name: "String"
                }
            },
            sourceContext: {
                serializedName: "sourceContext",
                type: {
                    name: "String"
                }
            },
            inputs: {
                serializedName: "inputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InputFieldMappingEntry"
                        }
                    }
                }
            }
        }
    }
};
const ListSkillsetsResult = {
    type: {
        name: "Composite",
        className: "ListSkillsetsResult",
        modelProperties: {
            skillsets: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerSkillset"
                        }
                    }
                }
            }
        }
    }
};
const SynonymMap = {
    type: {
        name: "Composite",
        className: "SynonymMap",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            format: {
                defaultValue: "solr",
                isConstant: true,
                serializedName: "format",
                type: {
                    name: "String"
                }
            },
            synonyms: {
                serializedName: "synonyms",
                required: true,
                type: {
                    name: "String"
                }
            },
            encryptionKey: {
                serializedName: "encryptionKey",
                type: {
                    name: "Composite",
                    className: "SearchResourceEncryptionKey"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListSynonymMapsResult = {
    type: {
        name: "Composite",
        className: "ListSynonymMapsResult",
        modelProperties: {
            synonymMaps: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SynonymMap"
                        }
                    }
                }
            }
        }
    }
};
const SearchIndex = {
    type: {
        name: "Composite",
        className: "SearchIndex",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            fields: {
                serializedName: "fields",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchField"
                        }
                    }
                }
            },
            scoringProfiles: {
                serializedName: "scoringProfiles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScoringProfile"
                        }
                    }
                }
            },
            defaultScoringProfile: {
                serializedName: "defaultScoringProfile",
                type: {
                    name: "String"
                }
            },
            corsOptions: {
                serializedName: "corsOptions",
                type: {
                    name: "Composite",
                    className: "CorsOptions"
                }
            },
            suggesters: {
                serializedName: "suggesters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Suggester"
                        }
                    }
                }
            },
            analyzers: {
                serializedName: "analyzers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LexicalAnalyzer"
                        }
                    }
                }
            },
            tokenizers: {
                serializedName: "tokenizers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LexicalTokenizer"
                        }
                    }
                }
            },
            tokenFilters: {
                serializedName: "tokenFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TokenFilter"
                        }
                    }
                }
            },
            charFilters: {
                serializedName: "charFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CharFilter"
                        }
                    }
                }
            },
            encryptionKey: {
                serializedName: "encryptionKey",
                type: {
                    name: "Composite",
                    className: "SearchResourceEncryptionKey"
                }
            },
            similarity: {
                serializedName: "similarity",
                type: {
                    name: "Composite",
                    className: "Similarity"
                }
            },
            semanticSearch: {
                serializedName: "semantic",
                type: {
                    name: "Composite",
                    className: "SemanticSearch"
                }
            },
            vectorSearch: {
                serializedName: "vectorSearch",
                type: {
                    name: "Composite",
                    className: "VectorSearch"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchField = {
    type: {
        name: "Composite",
        className: "SearchField",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                type: {
                    name: "Boolean"
                }
            },
            retrievable: {
                serializedName: "retrievable",
                type: {
                    name: "Boolean"
                }
            },
            searchable: {
                serializedName: "searchable",
                type: {
                    name: "Boolean"
                }
            },
            filterable: {
                serializedName: "filterable",
                type: {
                    name: "Boolean"
                }
            },
            sortable: {
                serializedName: "sortable",
                type: {
                    name: "Boolean"
                }
            },
            facetable: {
                serializedName: "facetable",
                type: {
                    name: "Boolean"
                }
            },
            analyzer: {
                serializedName: "analyzer",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            searchAnalyzer: {
                serializedName: "searchAnalyzer",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            indexAnalyzer: {
                serializedName: "indexAnalyzer",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            vectorSearchDimensions: {
                constraints: {
                    InclusiveMaximum: 2048,
                    InclusiveMinimum: 2
                },
                serializedName: "dimensions",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            vectorSearchProfileName: {
                serializedName: "vectorSearchProfile",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            synonymMaps: {
                serializedName: "synonymMaps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            fields: {
                serializedName: "fields",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchField"
                        }
                    }
                }
            }
        }
    }
};
const ScoringProfile = {
    type: {
        name: "Composite",
        className: "ScoringProfile",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            textWeights: {
                serializedName: "text",
                type: {
                    name: "Composite",
                    className: "TextWeights"
                }
            },
            functions: {
                serializedName: "functions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScoringFunction"
                        }
                    }
                }
            },
            functionAggregation: {
                serializedName: "functionAggregation",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "sum",
                        "average",
                        "minimum",
                        "maximum",
                        "firstMatching"
                    ]
                }
            }
        }
    }
};
const TextWeights = {
    type: {
        name: "Composite",
        className: "TextWeights",
        modelProperties: {
            weights: {
                serializedName: "weights",
                required: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            }
        }
    }
};
const ScoringFunction = {
    type: {
        name: "Composite",
        className: "ScoringFunction",
        uberParent: "ScoringFunction",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            fieldName: {
                serializedName: "fieldName",
                required: true,
                type: {
                    name: "String"
                }
            },
            boost: {
                serializedName: "boost",
                required: true,
                type: {
                    name: "Number"
                }
            },
            interpolation: {
                serializedName: "interpolation",
                type: {
                    name: "Enum",
                    allowedValues: ["linear", "constant", "quadratic", "logarithmic"]
                }
            }
        }
    }
};
const CorsOptions = {
    type: {
        name: "Composite",
        className: "CorsOptions",
        modelProperties: {
            allowedOrigins: {
                serializedName: "allowedOrigins",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            maxAgeInSeconds: {
                serializedName: "maxAgeInSeconds",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Suggester = {
    type: {
        name: "Composite",
        className: "Suggester",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            searchMode: {
                defaultValue: "analyzingInfixMatching",
                isConstant: true,
                serializedName: "searchMode",
                type: {
                    name: "String"
                }
            },
            sourceFields: {
                serializedName: "sourceFields",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const LexicalAnalyzer = {
    type: {
        name: "Composite",
        className: "LexicalAnalyzer",
        uberParent: "LexicalAnalyzer",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LexicalTokenizer = {
    type: {
        name: "Composite",
        className: "LexicalTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TokenFilter = {
    type: {
        name: "Composite",
        className: "TokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CharFilter = {
    type: {
        name: "Composite",
        className: "CharFilter",
        uberParent: "CharFilter",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Similarity = {
    type: {
        name: "Composite",
        className: "Similarity",
        uberParent: "Similarity",
        polymorphicDiscriminator: {
            serializedName: "@odata\\.type",
            clientName: "odatatype"
        },
        modelProperties: {
            odatatype: {
                serializedName: "@odata\\.type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SemanticSearch = {
    type: {
        name: "Composite",
        className: "SemanticSearch",
        modelProperties: {
            defaultConfigurationName: {
                serializedName: "defaultConfiguration",
                type: {
                    name: "String"
                }
            },
            configurations: {
                serializedName: "configurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SemanticConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const SemanticConfiguration = {
    type: {
        name: "Composite",
        className: "SemanticConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            prioritizedFields: {
                serializedName: "prioritizedFields",
                type: {
                    name: "Composite",
                    className: "SemanticPrioritizedFields"
                }
            }
        }
    }
};
const SemanticPrioritizedFields = {
    type: {
        name: "Composite",
        className: "SemanticPrioritizedFields",
        modelProperties: {
            titleField: {
                serializedName: "titleField",
                type: {
                    name: "Composite",
                    className: "SemanticField"
                }
            },
            contentFields: {
                serializedName: "prioritizedContentFields",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SemanticField"
                        }
                    }
                }
            },
            keywordsFields: {
                serializedName: "prioritizedKeywordsFields",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SemanticField"
                        }
                    }
                }
            }
        }
    }
};
const SemanticField = {
    type: {
        name: "Composite",
        className: "SemanticField",
        modelProperties: {
            name: {
                serializedName: "fieldName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VectorSearch = {
    type: {
        name: "Composite",
        className: "VectorSearch",
        modelProperties: {
            profiles: {
                serializedName: "profiles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VectorSearchProfile"
                        }
                    }
                }
            },
            algorithms: {
                serializedName: "algorithms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VectorSearchAlgorithmConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const VectorSearchProfile = {
    type: {
        name: "Composite",
        className: "VectorSearchProfile",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            algorithmConfigurationName: {
                serializedName: "algorithm",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VectorSearchAlgorithmConfiguration = {
    type: {
        name: "Composite",
        className: "VectorSearchAlgorithmConfiguration",
        uberParent: "VectorSearchAlgorithmConfiguration",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListIndexesResult = {
    type: {
        name: "Composite",
        className: "ListIndexesResult",
        modelProperties: {
            indexes: {
                serializedName: "value",
                required: true,
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndex"
                        }
                    }
                }
            }
        }
    }
};
const GetIndexStatisticsResult = {
    type: {
        name: "Composite",
        className: "GetIndexStatisticsResult",
        modelProperties: {
            documentCount: {
                serializedName: "documentCount",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            storageSize: {
                serializedName: "storageSize",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            vectorIndexSize: {
                serializedName: "vectorIndexSize",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AnalyzeRequest = {
    type: {
        name: "Composite",
        className: "AnalyzeRequest",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            analyzer: {
                serializedName: "analyzer",
                type: {
                    name: "String"
                }
            },
            tokenizer: {
                serializedName: "tokenizer",
                type: {
                    name: "String"
                }
            },
            tokenFilters: {
                serializedName: "tokenFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            charFilters: {
                serializedName: "charFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AnalyzeResult = {
    type: {
        name: "Composite",
        className: "AnalyzeResult",
        modelProperties: {
            tokens: {
                serializedName: "tokens",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AnalyzedTokenInfo"
                        }
                    }
                }
            }
        }
    }
};
const AnalyzedTokenInfo = {
    type: {
        name: "Composite",
        className: "AnalyzedTokenInfo",
        modelProperties: {
            token: {
                serializedName: "token",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startOffset: {
                serializedName: "startOffset",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            endOffset: {
                serializedName: "endOffset",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            position: {
                serializedName: "position",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServiceStatistics = {
    type: {
        name: "Composite",
        className: "ServiceStatistics",
        modelProperties: {
            counters: {
                serializedName: "counters",
                type: {
                    name: "Composite",
                    className: "ServiceCounters"
                }
            },
            limits: {
                serializedName: "limits",
                type: {
                    name: "Composite",
                    className: "ServiceLimits"
                }
            }
        }
    }
};
const ServiceCounters = {
    type: {
        name: "Composite",
        className: "ServiceCounters",
        modelProperties: {
            documentCounter: {
                serializedName: "documentCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            indexCounter: {
                serializedName: "indexesCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            indexerCounter: {
                serializedName: "indexersCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            dataSourceCounter: {
                serializedName: "dataSourcesCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            storageSizeCounter: {
                serializedName: "storageSize",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            synonymMapCounter: {
                serializedName: "synonymMaps",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            skillsetCounter: {
                serializedName: "skillsetCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            vectorIndexSizeCounter: {
                serializedName: "vectorIndexSize",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            }
        }
    }
};
const ResourceCounter = {
    type: {
        name: "Composite",
        className: "ResourceCounter",
        modelProperties: {
            usage: {
                serializedName: "usage",
                required: true,
                type: {
                    name: "Number"
                }
            },
            quota: {
                serializedName: "quota",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServiceLimits = {
    type: {
        name: "Composite",
        className: "ServiceLimits",
        modelProperties: {
            maxFieldsPerIndex: {
                serializedName: "maxFieldsPerIndex",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            maxFieldNestingDepthPerIndex: {
                serializedName: "maxFieldNestingDepthPerIndex",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            maxComplexCollectionFieldsPerIndex: {
                serializedName: "maxComplexCollectionFieldsPerIndex",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            maxComplexObjectsInCollectionsPerDocument: {
                serializedName: "maxComplexObjectsInCollectionsPerDocument",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const HnswParameters = {
    type: {
        name: "Composite",
        className: "HnswParameters",
        modelProperties: {
            m: {
                defaultValue: 4,
                constraints: {
                    InclusiveMaximum: 10,
                    InclusiveMinimum: 4
                },
                serializedName: "m",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            efConstruction: {
                defaultValue: 400,
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 100
                },
                serializedName: "efConstruction",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            efSearch: {
                defaultValue: 500,
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 100
                },
                serializedName: "efSearch",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            metric: {
                serializedName: "metric",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExhaustiveKnnParameters = {
    type: {
        name: "Composite",
        className: "ExhaustiveKnnParameters",
        modelProperties: {
            metric: {
                serializedName: "metric",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DistanceScoringParameters = {
    type: {
        name: "Composite",
        className: "DistanceScoringParameters",
        modelProperties: {
            referencePointParameter: {
                serializedName: "referencePointParameter",
                required: true,
                type: {
                    name: "String"
                }
            },
            boostingDistance: {
                serializedName: "boostingDistance",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const FreshnessScoringParameters = {
    type: {
        name: "Composite",
        className: "FreshnessScoringParameters",
        modelProperties: {
            boostingDuration: {
                serializedName: "boostingDuration",
                required: true,
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const MagnitudeScoringParameters = {
    type: {
        name: "Composite",
        className: "MagnitudeScoringParameters",
        modelProperties: {
            boostingRangeStart: {
                serializedName: "boostingRangeStart",
                required: true,
                type: {
                    name: "Number"
                }
            },
            boostingRangeEnd: {
                serializedName: "boostingRangeEnd",
                required: true,
                type: {
                    name: "Number"
                }
            },
            shouldBoostBeyondRangeByConstant: {
                serializedName: "constantBoostBeyondRange",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const TagScoringParameters = {
    type: {
        name: "Composite",
        className: "TagScoringParameters",
        modelProperties: {
            tagsParameter: {
                serializedName: "tagsParameter",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomEntity = {
    type: {
        name: "Composite",
        className: "CustomEntity",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            subtype: {
                serializedName: "subtype",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            caseSensitive: {
                serializedName: "caseSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            accentSensitive: {
                serializedName: "accentSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            fuzzyEditDistance: {
                serializedName: "fuzzyEditDistance",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            defaultCaseSensitive: {
                serializedName: "defaultCaseSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            defaultAccentSensitive: {
                serializedName: "defaultAccentSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            defaultFuzzyEditDistance: {
                serializedName: "defaultFuzzyEditDistance",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            aliases: {
                serializedName: "aliases",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomEntityAlias"
                        }
                    }
                }
            }
        }
    }
};
const CustomEntityAlias = {
    type: {
        name: "Composite",
        className: "CustomEntityAlias",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            caseSensitive: {
                serializedName: "caseSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            accentSensitive: {
                serializedName: "accentSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            fuzzyEditDistance: {
                serializedName: "fuzzyEditDistance",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const HighWaterMarkChangeDetectionPolicy = {
    serializedName: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
    type: {
        name: "Composite",
        className: "HighWaterMarkChangeDetectionPolicy",
        uberParent: "DataChangeDetectionPolicy",
        polymorphicDiscriminator: DataChangeDetectionPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DataChangeDetectionPolicy.type.modelProperties), { highWaterMarkColumnName: {
                serializedName: "highWaterMarkColumnName",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SqlIntegratedChangeTrackingPolicy = {
    serializedName: "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy",
    type: {
        name: "Composite",
        className: "SqlIntegratedChangeTrackingPolicy",
        uberParent: "DataChangeDetectionPolicy",
        polymorphicDiscriminator: DataChangeDetectionPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, DataChangeDetectionPolicy.type.modelProperties)
    }
};
const SoftDeleteColumnDeletionDetectionPolicy = {
    serializedName: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
    type: {
        name: "Composite",
        className: "SoftDeleteColumnDeletionDetectionPolicy",
        uberParent: "DataDeletionDetectionPolicy",
        polymorphicDiscriminator: DataDeletionDetectionPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DataDeletionDetectionPolicy.type.modelProperties), { softDeleteColumnName: {
                serializedName: "softDeleteColumnName",
                type: {
                    name: "String"
                }
            }, softDeleteMarkerValue: {
                serializedName: "softDeleteMarkerValue",
                type: {
                    name: "String"
                }
            } })
    }
};
const ConditionalSkill = {
    serializedName: "#Microsoft.Skills.Util.ConditionalSkill",
    type: {
        name: "Composite",
        className: "ConditionalSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, SearchIndexerSkill.type.modelProperties)
    }
};
const KeyPhraseExtractionSkill = {
    serializedName: "#Microsoft.Skills.Text.KeyPhraseExtractionSkill",
    type: {
        name: "Composite",
        className: "KeyPhraseExtractionSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, maxKeyPhraseCount: {
                serializedName: "maxKeyPhraseCount",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, modelVersion: {
                serializedName: "modelVersion",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const OcrSkill = {
    serializedName: "#Microsoft.Skills.Vision.OcrSkill",
    type: {
        name: "Composite",
        className: "OcrSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, shouldDetectOrientation: {
                defaultValue: false,
                serializedName: "detectOrientation",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ImageAnalysisSkill = {
    serializedName: "#Microsoft.Skills.Vision.ImageAnalysisSkill",
    type: {
        name: "Composite",
        className: "ImageAnalysisSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, visualFeatures: {
                serializedName: "visualFeatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const LanguageDetectionSkill = {
    serializedName: "#Microsoft.Skills.Text.LanguageDetectionSkill",
    type: {
        name: "Composite",
        className: "LanguageDetectionSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultCountryHint: {
                serializedName: "defaultCountryHint",
                nullable: true,
                type: {
                    name: "String"
                }
            }, modelVersion: {
                serializedName: "modelVersion",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ShaperSkill = {
    serializedName: "#Microsoft.Skills.Util.ShaperSkill",
    type: {
        name: "Composite",
        className: "ShaperSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, SearchIndexerSkill.type.modelProperties)
    }
};
const MergeSkill = {
    serializedName: "#Microsoft.Skills.Text.MergeSkill",
    type: {
        name: "Composite",
        className: "MergeSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { insertPreTag: {
                defaultValue: " ",
                serializedName: "insertPreTag",
                type: {
                    name: "String"
                }
            }, insertPostTag: {
                defaultValue: " ",
                serializedName: "insertPostTag",
                type: {
                    name: "String"
                }
            } })
    }
};
const EntityRecognitionSkill = {
    serializedName: "#Microsoft.Skills.Text.EntityRecognitionSkill",
    type: {
        name: "Composite",
        className: "EntityRecognitionSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { categories: {
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, includeTypelessEntities: {
                serializedName: "includeTypelessEntities",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            }, minimumPrecision: {
                serializedName: "minimumPrecision",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const SentimentSkill = {
    serializedName: "#Microsoft.Skills.Text.SentimentSkill",
    type: {
        name: "Composite",
        className: "SentimentSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            } })
    }
};
const SentimentSkillV3 = {
    serializedName: "#Microsoft.Skills.Text.V3.SentimentSkill",
    type: {
        name: "Composite",
        className: "SentimentSkillV3",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                nullable: true,
                type: {
                    name: "String"
                }
            }, includeOpinionMining: {
                defaultValue: false,
                serializedName: "includeOpinionMining",
                type: {
                    name: "Boolean"
                }
            }, modelVersion: {
                serializedName: "modelVersion",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EntityLinkingSkill = {
    serializedName: "#Microsoft.Skills.Text.V3.EntityLinkingSkill",
    type: {
        name: "Composite",
        className: "EntityLinkingSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                nullable: true,
                type: {
                    name: "String"
                }
            }, minimumPrecision: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "minimumPrecision",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, modelVersion: {
                serializedName: "modelVersion",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EntityRecognitionSkillV3 = {
    serializedName: "#Microsoft.Skills.Text.V3.EntityRecognitionSkill",
    type: {
        name: "Composite",
        className: "EntityRecognitionSkillV3",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { categories: {
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                nullable: true,
                type: {
                    name: "String"
                }
            }, minimumPrecision: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "minimumPrecision",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, modelVersion: {
                serializedName: "modelVersion",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PIIDetectionSkill = {
    serializedName: "#Microsoft.Skills.Text.PIIDetectionSkill",
    type: {
        name: "Composite",
        className: "PIIDetectionSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                nullable: true,
                type: {
                    name: "String"
                }
            }, minimumPrecision: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "minimumPrecision",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, maskingMode: {
                serializedName: "maskingMode",
                type: {
                    name: "String"
                }
            }, maskingCharacter: {
                constraints: {
                    MaxLength: 1
                },
                serializedName: "maskingCharacter",
                nullable: true,
                type: {
                    name: "String"
                }
            }, modelVersion: {
                serializedName: "modelVersion",
                nullable: true,
                type: {
                    name: "String"
                }
            }, categories: {
                serializedName: "piiCategories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, domain: {
                serializedName: "domain",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SplitSkill = {
    serializedName: "#Microsoft.Skills.Text.SplitSkill",
    type: {
        name: "Composite",
        className: "SplitSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, textSplitMode: {
                serializedName: "textSplitMode",
                type: {
                    name: "String"
                }
            }, maxPageLength: {
                serializedName: "maximumPageLength",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const CustomEntityLookupSkill = {
    serializedName: "#Microsoft.Skills.Text.CustomEntityLookupSkill",
    type: {
        name: "Composite",
        className: "CustomEntityLookupSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                nullable: true,
                type: {
                    name: "String"
                }
            }, entitiesDefinitionUri: {
                serializedName: "entitiesDefinitionUri",
                nullable: true,
                type: {
                    name: "String"
                }
            }, inlineEntitiesDefinition: {
                serializedName: "inlineEntitiesDefinition",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomEntity"
                        }
                    }
                }
            }, globalDefaultCaseSensitive: {
                serializedName: "globalDefaultCaseSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            }, globalDefaultAccentSensitive: {
                serializedName: "globalDefaultAccentSensitive",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            }, globalDefaultFuzzyEditDistance: {
                serializedName: "globalDefaultFuzzyEditDistance",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const TextTranslationSkill = {
    serializedName: "#Microsoft.Skills.Text.TranslationSkill",
    type: {
        name: "Composite",
        className: "TextTranslationSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultToLanguageCode: {
                serializedName: "defaultToLanguageCode",
                required: true,
                type: {
                    name: "String"
                }
            }, defaultFromLanguageCode: {
                serializedName: "defaultFromLanguageCode",
                type: {
                    name: "String"
                }
            }, suggestedFrom: {
                serializedName: "suggestedFrom",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DocumentExtractionSkill = {
    serializedName: "#Microsoft.Skills.Util.DocumentExtractionSkill",
    type: {
        name: "Composite",
        className: "DocumentExtractionSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { parsingMode: {
                serializedName: "parsingMode",
                nullable: true,
                type: {
                    name: "String"
                }
            }, dataToExtract: {
                serializedName: "dataToExtract",
                nullable: true,
                type: {
                    name: "String"
                }
            }, configuration: {
                serializedName: "configuration",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const WebApiSkill = {
    serializedName: "#Microsoft.Skills.Custom.WebApiSkill",
    type: {
        name: "Composite",
        className: "WebApiSkill",
        uberParent: "SearchIndexerSkill",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { uri: {
                serializedName: "uri",
                required: true,
                type: {
                    name: "String"
                }
            }, httpHeaders: {
                serializedName: "httpHeaders",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, httpMethod: {
                serializedName: "httpMethod",
                type: {
                    name: "String"
                }
            }, timeout: {
                serializedName: "timeout",
                type: {
                    name: "TimeSpan"
                }
            }, batchSize: {
                serializedName: "batchSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, degreeOfParallelism: {
                serializedName: "degreeOfParallelism",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const DefaultCognitiveServicesAccount = {
    serializedName: "#Microsoft.Azure.Search.DefaultCognitiveServices",
    type: {
        name: "Composite",
        className: "DefaultCognitiveServicesAccount",
        uberParent: "CognitiveServicesAccount",
        polymorphicDiscriminator: CognitiveServicesAccount.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, CognitiveServicesAccount.type.modelProperties)
    }
};
const CognitiveServicesAccountKey = {
    serializedName: "#Microsoft.Azure.Search.CognitiveServicesByKey",
    type: {
        name: "Composite",
        className: "CognitiveServicesAccountKey",
        uberParent: "CognitiveServicesAccount",
        polymorphicDiscriminator: CognitiveServicesAccount.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CognitiveServicesAccount.type.modelProperties), { key: {
                serializedName: "key",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SearchIndexerKnowledgeStoreTableProjectionSelector = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStoreTableProjectionSelector",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerKnowledgeStoreProjectionSelector.type.modelProperties), { tableName: {
                serializedName: "tableName",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SearchIndexerKnowledgeStoreBlobProjectionSelector = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStoreBlobProjectionSelector",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerKnowledgeStoreProjectionSelector.type.modelProperties), { storageContainer: {
                serializedName: "storageContainer",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DistanceScoringFunction = {
    serializedName: "distance",
    type: {
        name: "Composite",
        className: "DistanceScoringFunction",
        uberParent: "ScoringFunction",
        polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScoringFunction.type.modelProperties), { parameters: {
                serializedName: "distance",
                type: {
                    name: "Composite",
                    className: "DistanceScoringParameters"
                }
            } })
    }
};
const FreshnessScoringFunction = {
    serializedName: "freshness",
    type: {
        name: "Composite",
        className: "FreshnessScoringFunction",
        uberParent: "ScoringFunction",
        polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScoringFunction.type.modelProperties), { parameters: {
                serializedName: "freshness",
                type: {
                    name: "Composite",
                    className: "FreshnessScoringParameters"
                }
            } })
    }
};
const MagnitudeScoringFunction = {
    serializedName: "magnitude",
    type: {
        name: "Composite",
        className: "MagnitudeScoringFunction",
        uberParent: "ScoringFunction",
        polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScoringFunction.type.modelProperties), { parameters: {
                serializedName: "magnitude",
                type: {
                    name: "Composite",
                    className: "MagnitudeScoringParameters"
                }
            } })
    }
};
const TagScoringFunction = {
    serializedName: "tag",
    type: {
        name: "Composite",
        className: "TagScoringFunction",
        uberParent: "ScoringFunction",
        polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScoringFunction.type.modelProperties), { parameters: {
                serializedName: "tag",
                type: {
                    name: "Composite",
                    className: "TagScoringParameters"
                }
            } })
    }
};
const CustomAnalyzer = {
    serializedName: "#Microsoft.Azure.Search.CustomAnalyzer",
    type: {
        name: "Composite",
        className: "CustomAnalyzer",
        uberParent: "LexicalAnalyzer",
        polymorphicDiscriminator: LexicalAnalyzer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalAnalyzer.type.modelProperties), { tokenizerName: {
                serializedName: "tokenizer",
                required: true,
                type: {
                    name: "String"
                }
            }, tokenFilters: {
                serializedName: "tokenFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, charFilters: {
                serializedName: "charFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const PatternAnalyzer = {
    serializedName: "#Microsoft.Azure.Search.PatternAnalyzer",
    type: {
        name: "Composite",
        className: "PatternAnalyzer",
        uberParent: "LexicalAnalyzer",
        polymorphicDiscriminator: LexicalAnalyzer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalAnalyzer.type.modelProperties), { lowerCaseTerms: {
                defaultValue: true,
                serializedName: "lowercase",
                type: {
                    name: "Boolean"
                }
            }, pattern: {
                defaultValue: "W+",
                serializedName: "pattern",
                type: {
                    name: "String"
                }
            }, flags: {
                serializedName: "flags",
                type: {
                    name: "String"
                }
            }, stopwords: {
                serializedName: "stopwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const LuceneStandardAnalyzer = {
    serializedName: "#Microsoft.Azure.Search.StandardAnalyzer",
    type: {
        name: "Composite",
        className: "LuceneStandardAnalyzer",
        uberParent: "LexicalAnalyzer",
        polymorphicDiscriminator: LexicalAnalyzer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalAnalyzer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            }, stopwords: {
                serializedName: "stopwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StopAnalyzer = {
    serializedName: "#Microsoft.Azure.Search.StopAnalyzer",
    type: {
        name: "Composite",
        className: "StopAnalyzer",
        uberParent: "LexicalAnalyzer",
        polymorphicDiscriminator: LexicalAnalyzer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalAnalyzer.type.modelProperties), { stopwords: {
                serializedName: "stopwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ClassicTokenizer = {
    serializedName: "#Microsoft.Azure.Search.ClassicTokenizer",
    type: {
        name: "Composite",
        className: "ClassicTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            } })
    }
};
const EdgeNGramTokenizer = {
    serializedName: "#Microsoft.Azure.Search.EdgeNGramTokenizer",
    type: {
        name: "Composite",
        className: "EdgeNGramTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { minGram: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "minGram",
                type: {
                    name: "Number"
                }
            }, maxGram: {
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxGram",
                type: {
                    name: "Number"
                }
            }, tokenChars: {
                serializedName: "tokenChars",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "letter",
                                "digit",
                                "whitespace",
                                "punctuation",
                                "symbol"
                            ]
                        }
                    }
                }
            } })
    }
};
const KeywordTokenizer = {
    serializedName: "#Microsoft.Azure.Search.KeywordTokenizer",
    type: {
        name: "Composite",
        className: "KeywordTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { bufferSize: {
                defaultValue: 256,
                serializedName: "bufferSize",
                type: {
                    name: "Number"
                }
            } })
    }
};
const KeywordTokenizerV2 = {
    serializedName: "#Microsoft.Azure.Search.KeywordTokenizerV2",
    type: {
        name: "Composite",
        className: "KeywordTokenizerV2",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 256,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            } })
    }
};
const MicrosoftLanguageTokenizer = {
    serializedName: "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer",
    type: {
        name: "Composite",
        className: "MicrosoftLanguageTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            }, isSearchTokenizer: {
                defaultValue: false,
                serializedName: "isSearchTokenizer",
                type: {
                    name: "Boolean"
                }
            }, language: {
                serializedName: "language",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "bangla",
                        "bulgarian",
                        "catalan",
                        "chineseSimplified",
                        "chineseTraditional",
                        "croatian",
                        "czech",
                        "danish",
                        "dutch",
                        "english",
                        "french",
                        "german",
                        "greek",
                        "gujarati",
                        "hindi",
                        "icelandic",
                        "indonesian",
                        "italian",
                        "japanese",
                        "kannada",
                        "korean",
                        "malay",
                        "malayalam",
                        "marathi",
                        "norwegianBokmaal",
                        "polish",
                        "portuguese",
                        "portugueseBrazilian",
                        "punjabi",
                        "romanian",
                        "russian",
                        "serbianCyrillic",
                        "serbianLatin",
                        "slovenian",
                        "spanish",
                        "swedish",
                        "tamil",
                        "telugu",
                        "thai",
                        "ukrainian",
                        "urdu",
                        "vietnamese"
                    ]
                }
            } })
    }
};
const MicrosoftLanguageStemmingTokenizer = {
    serializedName: "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer",
    type: {
        name: "Composite",
        className: "MicrosoftLanguageStemmingTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            }, isSearchTokenizer: {
                defaultValue: false,
                serializedName: "isSearchTokenizer",
                type: {
                    name: "Boolean"
                }
            }, language: {
                serializedName: "language",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "arabic",
                        "bangla",
                        "bulgarian",
                        "catalan",
                        "croatian",
                        "czech",
                        "danish",
                        "dutch",
                        "english",
                        "estonian",
                        "finnish",
                        "french",
                        "german",
                        "greek",
                        "gujarati",
                        "hebrew",
                        "hindi",
                        "hungarian",
                        "icelandic",
                        "indonesian",
                        "italian",
                        "kannada",
                        "latvian",
                        "lithuanian",
                        "malay",
                        "malayalam",
                        "marathi",
                        "norwegianBokmaal",
                        "polish",
                        "portuguese",
                        "portugueseBrazilian",
                        "punjabi",
                        "romanian",
                        "russian",
                        "serbianCyrillic",
                        "serbianLatin",
                        "slovak",
                        "slovenian",
                        "spanish",
                        "swedish",
                        "tamil",
                        "telugu",
                        "turkish",
                        "ukrainian",
                        "urdu"
                    ]
                }
            } })
    }
};
const NGramTokenizer = {
    serializedName: "#Microsoft.Azure.Search.NGramTokenizer",
    type: {
        name: "Composite",
        className: "NGramTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { minGram: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "minGram",
                type: {
                    name: "Number"
                }
            }, maxGram: {
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxGram",
                type: {
                    name: "Number"
                }
            }, tokenChars: {
                serializedName: "tokenChars",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "letter",
                                "digit",
                                "whitespace",
                                "punctuation",
                                "symbol"
                            ]
                        }
                    }
                }
            } })
    }
};
const PathHierarchyTokenizerV2 = {
    serializedName: "#Microsoft.Azure.Search.PathHierarchyTokenizerV2",
    type: {
        name: "Composite",
        className: "PathHierarchyTokenizerV2",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { delimiter: {
                defaultValue: "/",
                serializedName: "delimiter",
                type: {
                    name: "String"
                }
            }, replacement: {
                defaultValue: "/",
                serializedName: "replacement",
                type: {
                    name: "String"
                }
            }, maxTokenLength: {
                defaultValue: 300,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            }, reverseTokenOrder: {
                defaultValue: false,
                serializedName: "reverse",
                type: {
                    name: "Boolean"
                }
            }, numberOfTokensToSkip: {
                defaultValue: 0,
                serializedName: "skip",
                type: {
                    name: "Number"
                }
            } })
    }
};
const PatternTokenizer = {
    serializedName: "#Microsoft.Azure.Search.PatternTokenizer",
    type: {
        name: "Composite",
        className: "PatternTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { pattern: {
                defaultValue: "W+",
                serializedName: "pattern",
                type: {
                    name: "String"
                }
            }, flags: {
                serializedName: "flags",
                type: {
                    name: "String"
                }
            }, group: {
                defaultValue: -1,
                serializedName: "group",
                type: {
                    name: "Number"
                }
            } })
    }
};
const LuceneStandardTokenizer = {
    serializedName: "#Microsoft.Azure.Search.StandardTokenizer",
    type: {
        name: "Composite",
        className: "LuceneStandardTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            } })
    }
};
const LuceneStandardTokenizerV2 = {
    serializedName: "#Microsoft.Azure.Search.StandardTokenizerV2",
    type: {
        name: "Composite",
        className: "LuceneStandardTokenizerV2",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            } })
    }
};
const UaxUrlEmailTokenizer = {
    serializedName: "#Microsoft.Azure.Search.UaxUrlEmailTokenizer",
    type: {
        name: "Composite",
        className: "UaxUrlEmailTokenizer",
        uberParent: "LexicalTokenizer",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxTokenLength",
                type: {
                    name: "Number"
                }
            } })
    }
};
const AsciiFoldingTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter",
    type: {
        name: "Composite",
        className: "AsciiFoldingTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { preserveOriginal: {
                defaultValue: false,
                serializedName: "preserveOriginal",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const CjkBigramTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.CjkBigramTokenFilter",
    type: {
        name: "Composite",
        className: "CjkBigramTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { ignoreScripts: {
                serializedName: "ignoreScripts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: ["han", "hiragana", "katakana", "hangul"]
                        }
                    }
                }
            }, outputUnigrams: {
                defaultValue: false,
                serializedName: "outputUnigrams",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const CommonGramTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.CommonGramTokenFilter",
    type: {
        name: "Composite",
        className: "CommonGramTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { commonWords: {
                serializedName: "commonWords",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, ignoreCase: {
                defaultValue: false,
                serializedName: "ignoreCase",
                type: {
                    name: "Boolean"
                }
            }, useQueryMode: {
                defaultValue: false,
                serializedName: "queryMode",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DictionaryDecompounderTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter",
    type: {
        name: "Composite",
        className: "DictionaryDecompounderTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { wordList: {
                serializedName: "wordList",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, minWordSize: {
                defaultValue: 5,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "minWordSize",
                type: {
                    name: "Number"
                }
            }, minSubwordSize: {
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "minSubwordSize",
                type: {
                    name: "Number"
                }
            }, maxSubwordSize: {
                defaultValue: 15,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxSubwordSize",
                type: {
                    name: "Number"
                }
            }, onlyLongestMatch: {
                defaultValue: false,
                serializedName: "onlyLongestMatch",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const EdgeNGramTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.EdgeNGramTokenFilter",
    type: {
        name: "Composite",
        className: "EdgeNGramTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minGram: {
                defaultValue: 1,
                serializedName: "minGram",
                type: {
                    name: "Number"
                }
            }, maxGram: {
                defaultValue: 2,
                serializedName: "maxGram",
                type: {
                    name: "Number"
                }
            }, side: {
                serializedName: "side",
                type: {
                    name: "Enum",
                    allowedValues: ["front", "back"]
                }
            } })
    }
};
const EdgeNGramTokenFilterV2 = {
    serializedName: "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2",
    type: {
        name: "Composite",
        className: "EdgeNGramTokenFilterV2",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minGram: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "minGram",
                type: {
                    name: "Number"
                }
            }, maxGram: {
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxGram",
                type: {
                    name: "Number"
                }
            }, side: {
                serializedName: "side",
                type: {
                    name: "Enum",
                    allowedValues: ["front", "back"]
                }
            } })
    }
};
const ElisionTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.ElisionTokenFilter",
    type: {
        name: "Composite",
        className: "ElisionTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { articles: {
                serializedName: "articles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const KeepTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.KeepTokenFilter",
    type: {
        name: "Composite",
        className: "KeepTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { keepWords: {
                serializedName: "keepWords",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, lowerCaseKeepWords: {
                defaultValue: false,
                serializedName: "keepWordsCase",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const KeywordMarkerTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.KeywordMarkerTokenFilter",
    type: {
        name: "Composite",
        className: "KeywordMarkerTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { keywords: {
                serializedName: "keywords",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, ignoreCase: {
                defaultValue: false,
                serializedName: "ignoreCase",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const LengthTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.LengthTokenFilter",
    type: {
        name: "Composite",
        className: "LengthTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minLength: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "min",
                type: {
                    name: "Number"
                }
            }, maxLength: {
                defaultValue: 300,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "max",
                type: {
                    name: "Number"
                }
            } })
    }
};
const LimitTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.LimitTokenFilter",
    type: {
        name: "Composite",
        className: "LimitTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { maxTokenCount: {
                defaultValue: 1,
                serializedName: "maxTokenCount",
                type: {
                    name: "Number"
                }
            }, consumeAllTokens: {
                defaultValue: false,
                serializedName: "consumeAllTokens",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const NGramTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.NGramTokenFilter",
    type: {
        name: "Composite",
        className: "NGramTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minGram: {
                defaultValue: 1,
                serializedName: "minGram",
                type: {
                    name: "Number"
                }
            }, maxGram: {
                defaultValue: 2,
                serializedName: "maxGram",
                type: {
                    name: "Number"
                }
            } })
    }
};
const NGramTokenFilterV2 = {
    serializedName: "#Microsoft.Azure.Search.NGramTokenFilterV2",
    type: {
        name: "Composite",
        className: "NGramTokenFilterV2",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minGram: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "minGram",
                type: {
                    name: "Number"
                }
            }, maxGram: {
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "maxGram",
                type: {
                    name: "Number"
                }
            } })
    }
};
const PatternCaptureTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.PatternCaptureTokenFilter",
    type: {
        name: "Composite",
        className: "PatternCaptureTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { patterns: {
                serializedName: "patterns",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, preserveOriginal: {
                defaultValue: true,
                serializedName: "preserveOriginal",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const PatternReplaceTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.PatternReplaceTokenFilter",
    type: {
        name: "Composite",
        className: "PatternReplaceTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { pattern: {
                serializedName: "pattern",
                required: true,
                type: {
                    name: "String"
                }
            }, replacement: {
                serializedName: "replacement",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PhoneticTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.PhoneticTokenFilter",
    type: {
        name: "Composite",
        className: "PhoneticTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { encoder: {
                serializedName: "encoder",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "metaphone",
                        "doubleMetaphone",
                        "soundex",
                        "refinedSoundex",
                        "caverphone1",
                        "caverphone2",
                        "cologne",
                        "nysiis",
                        "koelnerPhonetik",
                        "haasePhonetik",
                        "beiderMorse"
                    ]
                }
            }, replaceOriginalTokens: {
                defaultValue: true,
                serializedName: "replace",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ShingleTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.ShingleTokenFilter",
    type: {
        name: "Composite",
        className: "ShingleTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { maxShingleSize: {
                defaultValue: 2,
                constraints: {
                    InclusiveMinimum: 2
                },
                serializedName: "maxShingleSize",
                type: {
                    name: "Number"
                }
            }, minShingleSize: {
                defaultValue: 2,
                constraints: {
                    InclusiveMinimum: 2
                },
                serializedName: "minShingleSize",
                type: {
                    name: "Number"
                }
            }, outputUnigrams: {
                defaultValue: true,
                serializedName: "outputUnigrams",
                type: {
                    name: "Boolean"
                }
            }, outputUnigramsIfNoShingles: {
                defaultValue: false,
                serializedName: "outputUnigramsIfNoShingles",
                type: {
                    name: "Boolean"
                }
            }, tokenSeparator: {
                defaultValue: " ",
                serializedName: "tokenSeparator",
                type: {
                    name: "String"
                }
            }, filterToken: {
                defaultValue: "_",
                serializedName: "filterToken",
                type: {
                    name: "String"
                }
            } })
    }
};
const SnowballTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.SnowballTokenFilter",
    type: {
        name: "Composite",
        className: "SnowballTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { language: {
                serializedName: "language",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "armenian",
                        "basque",
                        "catalan",
                        "danish",
                        "dutch",
                        "english",
                        "finnish",
                        "french",
                        "german",
                        "german2",
                        "hungarian",
                        "italian",
                        "kp",
                        "lovins",
                        "norwegian",
                        "porter",
                        "portuguese",
                        "romanian",
                        "russian",
                        "spanish",
                        "swedish",
                        "turkish"
                    ]
                }
            } })
    }
};
const StemmerTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.StemmerTokenFilter",
    type: {
        name: "Composite",
        className: "StemmerTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { language: {
                serializedName: "language",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "arabic",
                        "armenian",
                        "basque",
                        "brazilian",
                        "bulgarian",
                        "catalan",
                        "czech",
                        "danish",
                        "dutch",
                        "dutchKp",
                        "english",
                        "lightEnglish",
                        "minimalEnglish",
                        "possessiveEnglish",
                        "porter2",
                        "lovins",
                        "finnish",
                        "lightFinnish",
                        "french",
                        "lightFrench",
                        "minimalFrench",
                        "galician",
                        "minimalGalician",
                        "german",
                        "german2",
                        "lightGerman",
                        "minimalGerman",
                        "greek",
                        "hindi",
                        "hungarian",
                        "lightHungarian",
                        "indonesian",
                        "irish",
                        "italian",
                        "lightItalian",
                        "sorani",
                        "latvian",
                        "norwegian",
                        "lightNorwegian",
                        "minimalNorwegian",
                        "lightNynorsk",
                        "minimalNynorsk",
                        "portuguese",
                        "lightPortuguese",
                        "minimalPortuguese",
                        "portugueseRslp",
                        "romanian",
                        "russian",
                        "lightRussian",
                        "spanish",
                        "lightSpanish",
                        "swedish",
                        "lightSwedish",
                        "turkish"
                    ]
                }
            } })
    }
};
const StemmerOverrideTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.StemmerOverrideTokenFilter",
    type: {
        name: "Composite",
        className: "StemmerOverrideTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { rules: {
                serializedName: "rules",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StopwordsTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.StopwordsTokenFilter",
    type: {
        name: "Composite",
        className: "StopwordsTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { stopwords: {
                serializedName: "stopwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, stopwordsList: {
                serializedName: "stopwordsList",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "arabic",
                        "armenian",
                        "basque",
                        "brazilian",
                        "bulgarian",
                        "catalan",
                        "czech",
                        "danish",
                        "dutch",
                        "english",
                        "finnish",
                        "french",
                        "galician",
                        "german",
                        "greek",
                        "hindi",
                        "hungarian",
                        "indonesian",
                        "irish",
                        "italian",
                        "latvian",
                        "norwegian",
                        "persian",
                        "portuguese",
                        "romanian",
                        "russian",
                        "sorani",
                        "spanish",
                        "swedish",
                        "thai",
                        "turkish"
                    ]
                }
            }, ignoreCase: {
                defaultValue: false,
                serializedName: "ignoreCase",
                type: {
                    name: "Boolean"
                }
            }, removeTrailingStopWords: {
                defaultValue: true,
                serializedName: "removeTrailing",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const SynonymTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.SynonymTokenFilter",
    type: {
        name: "Composite",
        className: "SynonymTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { synonyms: {
                serializedName: "synonyms",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, ignoreCase: {
                defaultValue: false,
                serializedName: "ignoreCase",
                type: {
                    name: "Boolean"
                }
            }, expand: {
                defaultValue: true,
                serializedName: "expand",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const TruncateTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.TruncateTokenFilter",
    type: {
        name: "Composite",
        className: "TruncateTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { length: {
                defaultValue: 300,
                constraints: {
                    InclusiveMaximum: 300
                },
                serializedName: "length",
                type: {
                    name: "Number"
                }
            } })
    }
};
const UniqueTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.UniqueTokenFilter",
    type: {
        name: "Composite",
        className: "UniqueTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { onlyOnSamePosition: {
                defaultValue: false,
                serializedName: "onlyOnSamePosition",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const WordDelimiterTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.WordDelimiterTokenFilter",
    type: {
        name: "Composite",
        className: "WordDelimiterTokenFilter",
        uberParent: "TokenFilter",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { generateWordParts: {
                defaultValue: true,
                serializedName: "generateWordParts",
                type: {
                    name: "Boolean"
                }
            }, generateNumberParts: {
                defaultValue: true,
                serializedName: "generateNumberParts",
                type: {
                    name: "Boolean"
                }
            }, catenateWords: {
                defaultValue: false,
                serializedName: "catenateWords",
                type: {
                    name: "Boolean"
                }
            }, catenateNumbers: {
                defaultValue: false,
                serializedName: "catenateNumbers",
                type: {
                    name: "Boolean"
                }
            }, catenateAll: {
                defaultValue: false,
                serializedName: "catenateAll",
                type: {
                    name: "Boolean"
                }
            }, splitOnCaseChange: {
                defaultValue: true,
                serializedName: "splitOnCaseChange",
                type: {
                    name: "Boolean"
                }
            }, preserveOriginal: {
                defaultValue: false,
                serializedName: "preserveOriginal",
                type: {
                    name: "Boolean"
                }
            }, splitOnNumerics: {
                defaultValue: true,
                serializedName: "splitOnNumerics",
                type: {
                    name: "Boolean"
                }
            }, stemEnglishPossessive: {
                defaultValue: true,
                serializedName: "stemEnglishPossessive",
                type: {
                    name: "Boolean"
                }
            }, protectedWords: {
                serializedName: "protectedWords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const MappingCharFilter = {
    serializedName: "#Microsoft.Azure.Search.MappingCharFilter",
    type: {
        name: "Composite",
        className: "MappingCharFilter",
        uberParent: "CharFilter",
        polymorphicDiscriminator: CharFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CharFilter.type.modelProperties), { mappings: {
                serializedName: "mappings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const PatternReplaceCharFilter = {
    serializedName: "#Microsoft.Azure.Search.PatternReplaceCharFilter",
    type: {
        name: "Composite",
        className: "PatternReplaceCharFilter",
        uberParent: "CharFilter",
        polymorphicDiscriminator: CharFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CharFilter.type.modelProperties), { pattern: {
                serializedName: "pattern",
                required: true,
                type: {
                    name: "String"
                }
            }, replacement: {
                serializedName: "replacement",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ClassicSimilarity = {
    serializedName: "#Microsoft.Azure.Search.ClassicSimilarity",
    type: {
        name: "Composite",
        className: "ClassicSimilarity",
        uberParent: "Similarity",
        polymorphicDiscriminator: Similarity.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, Similarity.type.modelProperties)
    }
};
const BM25Similarity = {
    serializedName: "#Microsoft.Azure.Search.BM25Similarity",
    type: {
        name: "Composite",
        className: "BM25Similarity",
        uberParent: "Similarity",
        polymorphicDiscriminator: Similarity.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Similarity.type.modelProperties), { k1: {
                serializedName: "k1",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, b: {
                serializedName: "b",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const HnswAlgorithmConfiguration = {
    serializedName: "hnsw",
    type: {
        name: "Composite",
        className: "HnswAlgorithmConfiguration",
        uberParent: "VectorSearchAlgorithmConfiguration",
        polymorphicDiscriminator: VectorSearchAlgorithmConfiguration.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, VectorSearchAlgorithmConfiguration.type.modelProperties), { parameters: {
                serializedName: "hnswParameters",
                type: {
                    name: "Composite",
                    className: "HnswParameters"
                }
            } })
    }
};
const ExhaustiveKnnAlgorithmConfiguration = {
    serializedName: "exhaustiveKnn",
    type: {
        name: "Composite",
        className: "ExhaustiveKnnAlgorithmConfiguration",
        uberParent: "VectorSearchAlgorithmConfiguration",
        polymorphicDiscriminator: VectorSearchAlgorithmConfiguration.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, VectorSearchAlgorithmConfiguration.type.modelProperties), { parameters: {
                serializedName: "exhaustiveKnnParameters",
                type: {
                    name: "Composite",
                    className: "ExhaustiveKnnParameters"
                }
            } })
    }
};
const SearchIndexerKnowledgeStoreObjectProjectionSelector = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStoreObjectProjectionSelector",
        modelProperties: Object.assign({}, SearchIndexerKnowledgeStoreBlobProjectionSelector.type.modelProperties)
    }
};
const SearchIndexerKnowledgeStoreFileProjectionSelector = {
    type: {
        name: "Composite",
        className: "SearchIndexerKnowledgeStoreFileProjectionSelector",
        modelProperties: Object.assign({}, SearchIndexerKnowledgeStoreBlobProjectionSelector.type.modelProperties)
    }
};
let discriminators = {
    DataChangeDetectionPolicy: DataChangeDetectionPolicy,
    DataDeletionDetectionPolicy: DataDeletionDetectionPolicy,
    SearchIndexerSkill: SearchIndexerSkill,
    CognitiveServicesAccount: CognitiveServicesAccount,
    ScoringFunction: ScoringFunction,
    LexicalAnalyzer: LexicalAnalyzer,
    LexicalTokenizer: LexicalTokenizer,
    TokenFilter: TokenFilter,
    CharFilter: CharFilter,
    Similarity: Similarity,
    VectorSearchAlgorithmConfiguration: VectorSearchAlgorithmConfiguration,
    "DataChangeDetectionPolicy.#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy": HighWaterMarkChangeDetectionPolicy,
    "DataChangeDetectionPolicy.#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy": SqlIntegratedChangeTrackingPolicy,
    "DataDeletionDetectionPolicy.#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy": SoftDeleteColumnDeletionDetectionPolicy,
    "SearchIndexerSkill.#Microsoft.Skills.Util.ConditionalSkill": ConditionalSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.KeyPhraseExtractionSkill": KeyPhraseExtractionSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Vision.OcrSkill": OcrSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Vision.ImageAnalysisSkill": ImageAnalysisSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.LanguageDetectionSkill": LanguageDetectionSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Util.ShaperSkill": ShaperSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.MergeSkill": MergeSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.EntityRecognitionSkill": EntityRecognitionSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.SentimentSkill": SentimentSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.V3.SentimentSkill": SentimentSkillV3,
    "SearchIndexerSkill.#Microsoft.Skills.Text.V3.EntityLinkingSkill": EntityLinkingSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.V3.EntityRecognitionSkill": EntityRecognitionSkillV3,
    "SearchIndexerSkill.#Microsoft.Skills.Text.PIIDetectionSkill": PIIDetectionSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.SplitSkill": SplitSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.CustomEntityLookupSkill": CustomEntityLookupSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Text.TranslationSkill": TextTranslationSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Util.DocumentExtractionSkill": DocumentExtractionSkill,
    "SearchIndexerSkill.#Microsoft.Skills.Custom.WebApiSkill": WebApiSkill,
    "CognitiveServicesAccount.#Microsoft.Azure.Search.DefaultCognitiveServices": DefaultCognitiveServicesAccount,
    "CognitiveServicesAccount.#Microsoft.Azure.Search.CognitiveServicesByKey": CognitiveServicesAccountKey,
    "ScoringFunction.distance": DistanceScoringFunction,
    "ScoringFunction.freshness": FreshnessScoringFunction,
    "ScoringFunction.magnitude": MagnitudeScoringFunction,
    "ScoringFunction.tag": TagScoringFunction,
    "LexicalAnalyzer.#Microsoft.Azure.Search.CustomAnalyzer": CustomAnalyzer,
    "LexicalAnalyzer.#Microsoft.Azure.Search.PatternAnalyzer": PatternAnalyzer,
    "LexicalAnalyzer.#Microsoft.Azure.Search.StandardAnalyzer": LuceneStandardAnalyzer,
    "LexicalAnalyzer.#Microsoft.Azure.Search.StopAnalyzer": StopAnalyzer,
    "LexicalTokenizer.#Microsoft.Azure.Search.ClassicTokenizer": ClassicTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.EdgeNGramTokenizer": EdgeNGramTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.KeywordTokenizer": KeywordTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.KeywordTokenizerV2": KeywordTokenizerV2,
    "LexicalTokenizer.#Microsoft.Azure.Search.MicrosoftLanguageTokenizer": MicrosoftLanguageTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer": MicrosoftLanguageStemmingTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.NGramTokenizer": NGramTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.PathHierarchyTokenizerV2": PathHierarchyTokenizerV2,
    "LexicalTokenizer.#Microsoft.Azure.Search.PatternTokenizer": PatternTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.StandardTokenizer": LuceneStandardTokenizer,
    "LexicalTokenizer.#Microsoft.Azure.Search.StandardTokenizerV2": LuceneStandardTokenizerV2,
    "LexicalTokenizer.#Microsoft.Azure.Search.UaxUrlEmailTokenizer": UaxUrlEmailTokenizer,
    "TokenFilter.#Microsoft.Azure.Search.AsciiFoldingTokenFilter": AsciiFoldingTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.CjkBigramTokenFilter": CjkBigramTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.CommonGramTokenFilter": CommonGramTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter": DictionaryDecompounderTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.EdgeNGramTokenFilter": EdgeNGramTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.EdgeNGramTokenFilterV2": EdgeNGramTokenFilterV2,
    "TokenFilter.#Microsoft.Azure.Search.ElisionTokenFilter": ElisionTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.KeepTokenFilter": KeepTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.KeywordMarkerTokenFilter": KeywordMarkerTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.LengthTokenFilter": LengthTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.LimitTokenFilter": LimitTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.NGramTokenFilter": NGramTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.NGramTokenFilterV2": NGramTokenFilterV2,
    "TokenFilter.#Microsoft.Azure.Search.PatternCaptureTokenFilter": PatternCaptureTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.PatternReplaceTokenFilter": PatternReplaceTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.PhoneticTokenFilter": PhoneticTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.ShingleTokenFilter": ShingleTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.SnowballTokenFilter": SnowballTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.StemmerTokenFilter": StemmerTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.StemmerOverrideTokenFilter": StemmerOverrideTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.StopwordsTokenFilter": StopwordsTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.SynonymTokenFilter": SynonymTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.TruncateTokenFilter": TruncateTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.UniqueTokenFilter": UniqueTokenFilter,
    "TokenFilter.#Microsoft.Azure.Search.WordDelimiterTokenFilter": WordDelimiterTokenFilter,
    "CharFilter.#Microsoft.Azure.Search.MappingCharFilter": MappingCharFilter,
    "CharFilter.#Microsoft.Azure.Search.PatternReplaceCharFilter": PatternReplaceCharFilter,
    "Similarity.#Microsoft.Azure.Search.ClassicSimilarity": ClassicSimilarity,
    "Similarity.#Microsoft.Azure.Search.BM25Similarity": BM25Similarity,
    "VectorSearchAlgorithmConfiguration.hnsw": HnswAlgorithmConfiguration,
    "VectorSearchAlgorithmConfiguration.exhaustiveKnn": ExhaustiveKnnAlgorithmConfiguration
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AnalyzeRequest: AnalyzeRequest,
    AnalyzeResult: AnalyzeResult,
    AnalyzedTokenInfo: AnalyzedTokenInfo,
    AsciiFoldingTokenFilter: AsciiFoldingTokenFilter,
    AzureActiveDirectoryApplicationCredentials: AzureActiveDirectoryApplicationCredentials,
    BM25Similarity: BM25Similarity,
    CharFilter: CharFilter,
    CjkBigramTokenFilter: CjkBigramTokenFilter,
    ClassicSimilarity: ClassicSimilarity,
    ClassicTokenizer: ClassicTokenizer,
    CognitiveServicesAccount: CognitiveServicesAccount,
    CognitiveServicesAccountKey: CognitiveServicesAccountKey,
    CommonGramTokenFilter: CommonGramTokenFilter,
    ConditionalSkill: ConditionalSkill,
    CorsOptions: CorsOptions,
    CustomAnalyzer: CustomAnalyzer,
    CustomEntity: CustomEntity,
    CustomEntityAlias: CustomEntityAlias,
    CustomEntityLookupSkill: CustomEntityLookupSkill,
    DataChangeDetectionPolicy: DataChangeDetectionPolicy,
    DataDeletionDetectionPolicy: DataDeletionDetectionPolicy,
    DataSourceCredentials: DataSourceCredentials,
    DefaultCognitiveServicesAccount: DefaultCognitiveServicesAccount,
    DictionaryDecompounderTokenFilter: DictionaryDecompounderTokenFilter,
    DistanceScoringFunction: DistanceScoringFunction,
    DistanceScoringParameters: DistanceScoringParameters,
    DocumentExtractionSkill: DocumentExtractionSkill,
    EdgeNGramTokenFilter: EdgeNGramTokenFilter,
    EdgeNGramTokenFilterV2: EdgeNGramTokenFilterV2,
    EdgeNGramTokenizer: EdgeNGramTokenizer,
    ElisionTokenFilter: ElisionTokenFilter,
    EntityLinkingSkill: EntityLinkingSkill,
    EntityRecognitionSkill: EntityRecognitionSkill,
    EntityRecognitionSkillV3: EntityRecognitionSkillV3,
    ExhaustiveKnnAlgorithmConfiguration: ExhaustiveKnnAlgorithmConfiguration,
    ExhaustiveKnnParameters: ExhaustiveKnnParameters,
    FieldMapping: FieldMapping,
    FieldMappingFunction: FieldMappingFunction,
    FreshnessScoringFunction: FreshnessScoringFunction,
    FreshnessScoringParameters: FreshnessScoringParameters,
    GetIndexStatisticsResult: GetIndexStatisticsResult,
    HighWaterMarkChangeDetectionPolicy: HighWaterMarkChangeDetectionPolicy,
    HnswAlgorithmConfiguration: HnswAlgorithmConfiguration,
    HnswParameters: HnswParameters,
    ImageAnalysisSkill: ImageAnalysisSkill,
    IndexerExecutionResult: IndexerExecutionResult,
    IndexingParameters: IndexingParameters,
    IndexingParametersConfiguration: IndexingParametersConfiguration,
    IndexingSchedule: IndexingSchedule,
    InputFieldMappingEntry: InputFieldMappingEntry,
    KeepTokenFilter: KeepTokenFilter,
    KeyPhraseExtractionSkill: KeyPhraseExtractionSkill,
    KeywordMarkerTokenFilter: KeywordMarkerTokenFilter,
    KeywordTokenizer: KeywordTokenizer,
    KeywordTokenizerV2: KeywordTokenizerV2,
    LanguageDetectionSkill: LanguageDetectionSkill,
    LengthTokenFilter: LengthTokenFilter,
    LexicalAnalyzer: LexicalAnalyzer,
    LexicalTokenizer: LexicalTokenizer,
    LimitTokenFilter: LimitTokenFilter,
    ListDataSourcesResult: ListDataSourcesResult,
    ListIndexersResult: ListIndexersResult,
    ListIndexesResult: ListIndexesResult,
    ListSkillsetsResult: ListSkillsetsResult,
    ListSynonymMapsResult: ListSynonymMapsResult,
    LuceneStandardAnalyzer: LuceneStandardAnalyzer,
    LuceneStandardTokenizer: LuceneStandardTokenizer,
    LuceneStandardTokenizerV2: LuceneStandardTokenizerV2,
    MagnitudeScoringFunction: MagnitudeScoringFunction,
    MagnitudeScoringParameters: MagnitudeScoringParameters,
    MappingCharFilter: MappingCharFilter,
    MergeSkill: MergeSkill,
    MicrosoftLanguageStemmingTokenizer: MicrosoftLanguageStemmingTokenizer,
    MicrosoftLanguageTokenizer: MicrosoftLanguageTokenizer,
    NGramTokenFilter: NGramTokenFilter,
    NGramTokenFilterV2: NGramTokenFilterV2,
    NGramTokenizer: NGramTokenizer,
    OcrSkill: OcrSkill,
    OutputFieldMappingEntry: OutputFieldMappingEntry,
    PIIDetectionSkill: PIIDetectionSkill,
    PathHierarchyTokenizerV2: PathHierarchyTokenizerV2,
    PatternAnalyzer: PatternAnalyzer,
    PatternCaptureTokenFilter: PatternCaptureTokenFilter,
    PatternReplaceCharFilter: PatternReplaceCharFilter,
    PatternReplaceTokenFilter: PatternReplaceTokenFilter,
    PatternTokenizer: PatternTokenizer,
    PhoneticTokenFilter: PhoneticTokenFilter,
    ResourceCounter: ResourceCounter,
    ScoringFunction: ScoringFunction,
    ScoringProfile: ScoringProfile,
    SearchError: SearchError,
    SearchField: SearchField,
    SearchIndex: SearchIndex,
    SearchIndexer: SearchIndexer,
    SearchIndexerDataContainer: SearchIndexerDataContainer,
    SearchIndexerDataSource: SearchIndexerDataSource,
    SearchIndexerError: SearchIndexerError,
    SearchIndexerKnowledgeStore: SearchIndexerKnowledgeStore,
    SearchIndexerKnowledgeStoreBlobProjectionSelector: SearchIndexerKnowledgeStoreBlobProjectionSelector,
    SearchIndexerKnowledgeStoreFileProjectionSelector: SearchIndexerKnowledgeStoreFileProjectionSelector,
    SearchIndexerKnowledgeStoreObjectProjectionSelector: SearchIndexerKnowledgeStoreObjectProjectionSelector,
    SearchIndexerKnowledgeStoreProjection: SearchIndexerKnowledgeStoreProjection,
    SearchIndexerKnowledgeStoreProjectionSelector: SearchIndexerKnowledgeStoreProjectionSelector,
    SearchIndexerKnowledgeStoreTableProjectionSelector: SearchIndexerKnowledgeStoreTableProjectionSelector,
    SearchIndexerLimits: SearchIndexerLimits,
    SearchIndexerSkill: SearchIndexerSkill,
    SearchIndexerSkillset: SearchIndexerSkillset,
    SearchIndexerStatus: SearchIndexerStatus,
    SearchIndexerWarning: SearchIndexerWarning,
    SearchResourceEncryptionKey: SearchResourceEncryptionKey,
    SemanticConfiguration: SemanticConfiguration,
    SemanticField: SemanticField,
    SemanticPrioritizedFields: SemanticPrioritizedFields,
    SemanticSearch: SemanticSearch,
    SentimentSkill: SentimentSkill,
    SentimentSkillV3: SentimentSkillV3,
    ServiceCounters: ServiceCounters,
    ServiceLimits: ServiceLimits,
    ServiceStatistics: ServiceStatistics,
    ShaperSkill: ShaperSkill,
    ShingleTokenFilter: ShingleTokenFilter,
    Similarity: Similarity,
    SnowballTokenFilter: SnowballTokenFilter,
    SoftDeleteColumnDeletionDetectionPolicy: SoftDeleteColumnDeletionDetectionPolicy,
    SplitSkill: SplitSkill,
    SqlIntegratedChangeTrackingPolicy: SqlIntegratedChangeTrackingPolicy,
    StemmerOverrideTokenFilter: StemmerOverrideTokenFilter,
    StemmerTokenFilter: StemmerTokenFilter,
    StopAnalyzer: StopAnalyzer,
    StopwordsTokenFilter: StopwordsTokenFilter,
    Suggester: Suggester,
    SynonymMap: SynonymMap,
    SynonymTokenFilter: SynonymTokenFilter,
    TagScoringFunction: TagScoringFunction,
    TagScoringParameters: TagScoringParameters,
    TextTranslationSkill: TextTranslationSkill,
    TextWeights: TextWeights,
    TokenFilter: TokenFilter,
    TruncateTokenFilter: TruncateTokenFilter,
    UaxUrlEmailTokenizer: UaxUrlEmailTokenizer,
    UniqueTokenFilter: UniqueTokenFilter,
    VectorSearch: VectorSearch,
    VectorSearchAlgorithmConfiguration: VectorSearchAlgorithmConfiguration,
    VectorSearchProfile: VectorSearchProfile,
    WebApiSkill: WebApiSkill,
    WordDelimiterTokenFilter: WordDelimiterTokenFilter,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const dataSource = {
    parameterPath: "dataSource",
    mapper: SearchIndexerDataSource
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const dataSourceName = {
    parameterPath: "dataSourceName",
    mapper: {
        serializedName: "dataSourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const ifMatch = {
    parameterPath: ["options", "ifMatch"],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const ifNoneMatch = {
    parameterPath: ["options", "ifNoneMatch"],
    mapper: {
        serializedName: "If-None-Match",
        type: {
            name: "String"
        }
    }
};
const prefer = {
    parameterPath: "prefer",
    mapper: {
        defaultValue: "return=representation",
        isConstant: true,
        serializedName: "Prefer",
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const select = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$select",
        type: {
            name: "String"
        }
    }
};
const indexerName = {
    parameterPath: "indexerName",
    mapper: {
        serializedName: "indexerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const indexer = {
    parameterPath: "indexer",
    mapper: SearchIndexer
};
const skillset = {
    parameterPath: "skillset",
    mapper: SearchIndexerSkillset
};
const skillsetName = {
    parameterPath: "skillsetName",
    mapper: {
        serializedName: "skillsetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const synonymMap = {
    parameterPath: "synonymMap",
    mapper: SynonymMap
};
const synonymMapName = {
    parameterPath: "synonymMapName",
    mapper: {
        serializedName: "synonymMapName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const index = {
    parameterPath: "index",
    mapper: SearchIndex
};
const indexName = {
    parameterPath: "indexName",
    mapper: {
        serializedName: "indexName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const allowIndexDowntime = {
    parameterPath: ["options", "allowIndexDowntime"],
    mapper: {
        serializedName: "allowIndexDowntime",
        type: {
            name: "Boolean"
        }
    }
};
const request = {
    parameterPath: "request",
    mapper: AnalyzeRequest
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing DataSources operations. */
class DataSourcesImpl {
    /**
     * Initialize a new instance of the class DataSources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new datasource or updates a datasource if it already exists.
     * @param dataSourceName The name of the datasource to create or update.
     * @param dataSource The definition of the datasource to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(dataSourceName, dataSource, options) {
        return this.client.sendOperationRequest({ dataSourceName, dataSource, options }, createOrUpdateOperationSpec$4);
    }
    /**
     * Deletes a datasource.
     * @param dataSourceName The name of the datasource to delete.
     * @param options The options parameters.
     */
    delete(dataSourceName, options) {
        return this.client.sendOperationRequest({ dataSourceName, options }, deleteOperationSpec$4);
    }
    /**
     * Retrieves a datasource definition.
     * @param dataSourceName The name of the datasource to retrieve.
     * @param options The options parameters.
     */
    get(dataSourceName, options) {
        return this.client.sendOperationRequest({ dataSourceName, options }, getOperationSpec$4);
    }
    /**
     * Lists all datasources available for a search service.
     * @param options The options parameters.
     */
    list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$4);
    }
    /**
     * Creates a new datasource.
     * @param dataSource The definition of the datasource to create.
     * @param options The options parameters.
     */
    create(dataSource, options) {
        return this.client.sendOperationRequest({ dataSource, options }, createOperationSpec$4);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$4 = {
    path: "/datasources('{dataSourceName}')",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SearchIndexerDataSource
        },
        201: {
            bodyMapper: SearchIndexerDataSource
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: dataSource,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, dataSourceName],
    headerParameters: [
        contentType,
        accept,
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$4 = {
    path: "/datasources('{dataSourceName}')",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, dataSourceName],
    headerParameters: [
        accept,
        ifMatch,
        ifNoneMatch
    ],
    serializer: serializer$5
};
const getOperationSpec$4 = {
    path: "/datasources('{dataSourceName}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchIndexerDataSource
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, dataSourceName],
    headerParameters: [accept],
    serializer: serializer$5
};
const listOperationSpec$4 = {
    path: "/datasources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListDataSourcesResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion, select],
    urlParameters: [endpoint],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOperationSpec$4 = {
    path: "/datasources",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: SearchIndexerDataSource
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: dataSource,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Indexers operations. */
class IndexersImpl {
    /**
     * Initialize a new instance of the class Indexers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Resets the change tracking state associated with an indexer.
     * @param indexerName The name of the indexer to reset.
     * @param options The options parameters.
     */
    reset(indexerName, options) {
        return this.client.sendOperationRequest({ indexerName, options }, resetOperationSpec);
    }
    /**
     * Runs an indexer on-demand.
     * @param indexerName The name of the indexer to run.
     * @param options The options parameters.
     */
    run(indexerName, options) {
        return this.client.sendOperationRequest({ indexerName, options }, runOperationSpec);
    }
    /**
     * Creates a new indexer or updates an indexer if it already exists.
     * @param indexerName The name of the indexer to create or update.
     * @param indexer The definition of the indexer to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(indexerName, indexer, options) {
        return this.client.sendOperationRequest({ indexerName, indexer, options }, createOrUpdateOperationSpec$3);
    }
    /**
     * Deletes an indexer.
     * @param indexerName The name of the indexer to delete.
     * @param options The options parameters.
     */
    delete(indexerName, options) {
        return this.client.sendOperationRequest({ indexerName, options }, deleteOperationSpec$3);
    }
    /**
     * Retrieves an indexer definition.
     * @param indexerName The name of the indexer to retrieve.
     * @param options The options parameters.
     */
    get(indexerName, options) {
        return this.client.sendOperationRequest({ indexerName, options }, getOperationSpec$3);
    }
    /**
     * Lists all indexers available for a search service.
     * @param options The options parameters.
     */
    list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$3);
    }
    /**
     * Creates a new indexer.
     * @param indexer The definition of the indexer to create.
     * @param options The options parameters.
     */
    create(indexer, options) {
        return this.client.sendOperationRequest({ indexer, options }, createOperationSpec$3);
    }
    /**
     * Returns the current status and execution history of an indexer.
     * @param indexerName The name of the indexer for which to retrieve status.
     * @param options The options parameters.
     */
    getStatus(indexerName, options) {
        return this.client.sendOperationRequest({ indexerName, options }, getStatusOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const resetOperationSpec = {
    path: "/indexers('{indexerName}')/search.reset",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexerName],
    headerParameters: [accept],
    serializer: serializer$4
};
const runOperationSpec = {
    path: "/indexers('{indexerName}')/search.run",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexerName],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOrUpdateOperationSpec$3 = {
    path: "/indexers('{indexerName}')",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SearchIndexer
        },
        201: {
            bodyMapper: SearchIndexer
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: indexer,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexerName],
    headerParameters: [
        contentType,
        accept,
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec$3 = {
    path: "/indexers('{indexerName}')",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexerName],
    headerParameters: [
        accept,
        ifMatch,
        ifNoneMatch
    ],
    serializer: serializer$4
};
const getOperationSpec$3 = {
    path: "/indexers('{indexerName}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchIndexer
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexerName],
    headerParameters: [accept],
    serializer: serializer$4
};
const listOperationSpec$3 = {
    path: "/indexers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListIndexersResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion, select],
    urlParameters: [endpoint],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOperationSpec$3 = {
    path: "/indexers",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: SearchIndexer
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: indexer,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$4
};
const getStatusOperationSpec = {
    path: "/indexers('{indexerName}')/search.status",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchIndexerStatus
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexerName],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Skillsets operations. */
class SkillsetsImpl {
    /**
     * Initialize a new instance of the class Skillsets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new skillset in a search service or updates the skillset if it already exists.
     * @param skillsetName The name of the skillset to create or update.
     * @param skillset The skillset containing one or more skills to create or update in a search service.
     * @param options The options parameters.
     */
    createOrUpdate(skillsetName, skillset, options) {
        return this.client.sendOperationRequest({ skillsetName, skillset, options }, createOrUpdateOperationSpec$2);
    }
    /**
     * Deletes a skillset in a search service.
     * @param skillsetName The name of the skillset to delete.
     * @param options The options parameters.
     */
    delete(skillsetName, options) {
        return this.client.sendOperationRequest({ skillsetName, options }, deleteOperationSpec$2);
    }
    /**
     * Retrieves a skillset in a search service.
     * @param skillsetName The name of the skillset to retrieve.
     * @param options The options parameters.
     */
    get(skillsetName, options) {
        return this.client.sendOperationRequest({ skillsetName, options }, getOperationSpec$2);
    }
    /**
     * List all skillsets in a search service.
     * @param options The options parameters.
     */
    list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * Creates a new skillset in a search service.
     * @param skillset The skillset containing one or more skills to create in a search service.
     * @param options The options parameters.
     */
    create(skillset, options) {
        return this.client.sendOperationRequest({ skillset, options }, createOperationSpec$2);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$2 = {
    path: "/skillsets('{skillsetName}')",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SearchIndexerSkillset
        },
        201: {
            bodyMapper: SearchIndexerSkillset
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: skillset,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, skillsetName],
    headerParameters: [
        contentType,
        accept,
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$2 = {
    path: "/skillsets('{skillsetName}')",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, skillsetName],
    headerParameters: [
        accept,
        ifMatch,
        ifNoneMatch
    ],
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/skillsets('{skillsetName}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchIndexerSkillset
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, skillsetName],
    headerParameters: [accept],
    serializer: serializer$3
};
const listOperationSpec$2 = {
    path: "/skillsets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListSkillsetsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion, select],
    urlParameters: [endpoint],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOperationSpec$2 = {
    path: "/skillsets",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: SearchIndexerSkillset
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: skillset,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SynonymMaps operations. */
class SynonymMapsImpl {
    /**
     * Initialize a new instance of the class SynonymMaps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new synonym map or updates a synonym map if it already exists.
     * @param synonymMapName The name of the synonym map to create or update.
     * @param synonymMap The definition of the synonym map to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(synonymMapName, synonymMap, options) {
        return this.client.sendOperationRequest({ synonymMapName, synonymMap, options }, createOrUpdateOperationSpec$1);
    }
    /**
     * Deletes a synonym map.
     * @param synonymMapName The name of the synonym map to delete.
     * @param options The options parameters.
     */
    delete(synonymMapName, options) {
        return this.client.sendOperationRequest({ synonymMapName, options }, deleteOperationSpec$1);
    }
    /**
     * Retrieves a synonym map definition.
     * @param synonymMapName The name of the synonym map to retrieve.
     * @param options The options parameters.
     */
    get(synonymMapName, options) {
        return this.client.sendOperationRequest({ synonymMapName, options }, getOperationSpec$1);
    }
    /**
     * Lists all synonym maps available for a search service.
     * @param options The options parameters.
     */
    list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * Creates a new synonym map.
     * @param synonymMap The definition of the synonym map to create.
     * @param options The options parameters.
     */
    create(synonymMap, options) {
        return this.client.sendOperationRequest({ synonymMap, options }, createOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$1 = {
    path: "/synonymmaps('{synonymMapName}')",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SynonymMap
        },
        201: {
            bodyMapper: SynonymMap
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: synonymMap,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, synonymMapName],
    headerParameters: [
        contentType,
        accept,
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$1 = {
    path: "/synonymmaps('{synonymMapName}')",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, synonymMapName],
    headerParameters: [
        accept,
        ifMatch,
        ifNoneMatch
    ],
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/synonymmaps('{synonymMapName}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SynonymMap
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, synonymMapName],
    headerParameters: [accept],
    serializer: serializer$2
};
const listOperationSpec$1 = {
    path: "/synonymmaps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListSynonymMapsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion, select],
    urlParameters: [endpoint],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOperationSpec$1 = {
    path: "/synonymmaps",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: SynonymMap
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: synonymMap,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Indexes operations. */
class IndexesImpl {
    /**
     * Initialize a new instance of the class Indexes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new search index.
     * @param index The definition of the index to create.
     * @param options The options parameters.
     */
    create(index, options) {
        return this.client.sendOperationRequest({ index, options }, createOperationSpec);
    }
    /**
     * Lists all indexes available for a search service.
     * @param options The options parameters.
     */
    list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * Creates a new search index or updates an index if it already exists.
     * @param indexName The definition of the index to create or update.
     * @param index The definition of the index to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(indexName, index, options) {
        return this.client.sendOperationRequest({ indexName, index, options }, createOrUpdateOperationSpec);
    }
    /**
     * Deletes a search index and all the documents it contains. This operation is permanent, with no
     * recovery option. Make sure you have a master copy of your index definition, data ingestion code, and
     * a backup of the primary data source in case you need to re-build the index.
     * @param indexName The name of the index to delete.
     * @param options The options parameters.
     */
    delete(indexName, options) {
        return this.client.sendOperationRequest({ indexName, options }, deleteOperationSpec);
    }
    /**
     * Retrieves an index definition.
     * @param indexName The name of the index to retrieve.
     * @param options The options parameters.
     */
    get(indexName, options) {
        return this.client.sendOperationRequest({ indexName, options }, getOperationSpec);
    }
    /**
     * Returns statistics for the given index, including a document count and storage usage.
     * @param indexName The name of the index for which to retrieve statistics.
     * @param options The options parameters.
     */
    getStatistics(indexName, options) {
        return this.client.sendOperationRequest({ indexName, options }, getStatisticsOperationSpec);
    }
    /**
     * Shows how an analyzer breaks text into tokens.
     * @param indexName The name of the index for which to test an analyzer.
     * @param request The text and analyzer or analysis components to test.
     * @param options The options parameters.
     */
    analyze(indexName, request, options) {
        return this.client.sendOperationRequest({ indexName, request, options }, analyzeOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec = {
    path: "/indexes",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: SearchIndex
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: index,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$1
};
const listOperationSpec = {
    path: "/indexes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListIndexesResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion, select],
    urlParameters: [endpoint],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec = {
    path: "/indexes('{indexName}')",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SearchIndex
        },
        201: {
            bodyMapper: SearchIndex
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: index,
    queryParameters: [apiVersion, allowIndexDowntime],
    urlParameters: [endpoint, indexName],
    headerParameters: [
        contentType,
        accept,
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec = {
    path: "/indexes('{indexName}')",
    httpMethod: "DELETE",
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexName],
    headerParameters: [
        accept,
        ifMatch,
        ifNoneMatch
    ],
    serializer: serializer$1
};
const getOperationSpec = {
    path: "/indexes('{indexName}')",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchIndex
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexName],
    headerParameters: [accept],
    serializer: serializer$1
};
const getStatisticsOperationSpec = {
    path: "/indexes('{indexName}')/search.stats",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetIndexStatisticsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexName],
    headerParameters: [accept],
    serializer: serializer$1
};
const analyzeOperationSpec = {
    path: "/indexes('{indexName}')/search.analyze",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AnalyzeResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    requestBody: request,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, indexName],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class SearchServiceClient extends coreHttpCompat__namespace.ExtendedServiceClient {
    /**
     * Initializes a new instance of the SearchServiceClient class.
     * @param endpoint The endpoint URL of the search service.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(endpoint, apiVersion, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        if (apiVersion === undefined) {
            throw new Error("'apiVersion' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-search-documents/12.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        this.apiVersion = apiVersion;
        this.dataSources = new DataSourcesImpl(this);
        this.indexers = new IndexersImpl(this);
        this.skillsets = new SkillsetsImpl(this);
        this.synonymMaps = new SynonymMapsImpl(this);
        this.indexes = new IndexesImpl(this);
        this.addCustomApiVersionPolicy(apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Gets service level statistics for a search service.
     * @param options The options parameters.
     */
    getServiceStatistics(options) {
        return this.sendOperationRequest({ options }, getServiceStatisticsOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getServiceStatisticsOperationSpec = {
    path: "/servicestats",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceStatistics
        },
        default: {
            bodyMapper: SearchError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept],
    serializer
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Class to perform operations to manage
 * (create, update, list/delete)
 * indexes, & synonymmaps.
 */
class SearchIndexClient {
    /**
     * Creates an instance of SearchIndexClient.
     *
     * Example usage:
     * ```ts
     * const { SearchIndexClient, AzureKeyCredential } = require("@azure/search-documents");
     *
     * const client = new SearchIndexClient(
     *   "<endpoint>",
     *   new AzureKeyCredential("<Admin Key>");
     * );
     * ```
     * @param endpoint - The endpoint of the search service
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Search Index client.
     */
    constructor(endpoint, credential, options = {}) {
        var _a, _b;
        /**
         * The API version to use when communicating with the service.
         */
        this.serviceVersion = defaultServiceVersion;
        /**
         * The API version to use when communicating with the service.
         * @deprecated use {@Link serviceVersion} instead
         */
        this.apiVersion = defaultServiceVersion;
        this.endpoint = endpoint;
        this.credential = credential;
        this.options = options;
        const internalClientPipelineOptions = Object.assign(Object.assign({}, this.options), {
            loggingOptions: {
                logger: logger.info,
                additionalAllowedHeaderNames: [
                    "elapsed-time",
                    "Location",
                    "OData-MaxVersion",
                    "OData-Version",
                    "Prefer",
                    "throttle-reason",
                ],
            },
        });
        this.serviceVersion =
            (_b = (_a = this.options.serviceVersion) !== null && _a !== void 0 ? _a : this.options.apiVersion) !== null && _b !== void 0 ? _b : defaultServiceVersion;
        this.apiVersion = this.serviceVersion;
        this.client = new SearchServiceClient(this.endpoint, this.serviceVersion, internalClientPipelineOptions);
        if (coreAuth.isTokenCredential(credential)) {
            const scope = this.options.audience
                ? `${this.options.audience}/.default`
                : `${exports.KnownSearchAudience.AzurePublicCloud}/.default`;
            this.client.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({ credential, scopes: scope }));
        }
        else {
            this.client.pipeline.addPolicy(createSearchApiKeyCredentialPolicy(credential));
        }
        this.client.pipeline.addPolicy(createOdataMetadataPolicy("minimal"));
    }
    listIndexesPage(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listIndexesPage_1() {
            const { span, updatedOptions } = createSpan("SearchIndexClient-listIndexesPage", options);
            try {
                const result = yield tslib.__await(this.client.indexes.list(updatedOptions));
                const mapped = result.indexes.map(generatedIndexToPublicIndex);
                yield yield tslib.__await(mapped);
            }
            catch (e) {
                span.setStatus({
                    status: "error",
                    error: e.message,
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listIndexesAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listIndexesAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listIndexesPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves a list of existing indexes in the service.
     * @param options - Options to the list index operation.
     */
    listIndexes(options = {}) {
        const iter = this.listIndexesAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listIndexesPage(options);
            },
        };
    }
    listIndexesNamesPage(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listIndexesNamesPage_1() {
            const { span, updatedOptions } = createSpan("SearchIndexClient-listIndexesNamesPage", options);
            try {
                const result = yield tslib.__await(this.client.indexes.list(Object.assign(Object.assign({}, updatedOptions), { select: "name" })));
                const mapped = result.indexes.map((idx) => idx.name);
                yield yield tslib.__await(mapped);
            }
            catch (e) {
                span.setStatus({
                    status: "error",
                    error: e.message,
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listIndexesNamesAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listIndexesNamesAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listIndexesNamesPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves a list of names of existing indexes in the service.
     * @param options - Options to the list index operation.
     */
    listIndexesNames(options = {}) {
        const iter = this.listIndexesNamesAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listIndexesNamesPage(options);
            },
        };
    }
    /**
     * Retrieves a list of existing SynonymMaps in the service.
     * @param options - Options to the list SynonymMaps operation.
     */
    async listSynonymMaps(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-listSynonymMaps", options);
        try {
            const result = await this.client.synonymMaps.list(updatedOptions);
            return result.synonymMaps.map(generatedSynonymMapToPublicSynonymMap);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of names of existing SynonymMaps in the service.
     * @param options - Options to the list SynonymMaps operation.
     */
    async listSynonymMapsNames(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-listSynonymMapsNames", options);
        try {
            const result = await this.client.synonymMaps.list(Object.assign(Object.assign({}, updatedOptions), { select: "name" }));
            return result.synonymMaps.map((sm) => sm.name);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves information about an index.
     * @param indexName - The name of the index.
     * @param options - Additional optional arguments.
     */
    async getIndex(indexName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-getIndex", options);
        try {
            const result = await this.client.indexes.get(indexName, updatedOptions);
            return generatedIndexToPublicIndex(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves information about a SynonymMap.
     * @param synonymMapName - The name of the SynonymMap.
     * @param options - Additional optional arguments.
     */
    async getSynonymMap(synonymMapName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-getSynonymMaps", options);
        try {
            const result = await this.client.synonymMaps.get(synonymMapName, updatedOptions);
            return generatedSynonymMapToPublicSynonymMap(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new index.
     * @param index - The information describing the index to be created.
     * @param options - Additional optional arguments.
     */
    async createIndex(index, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-createIndex", options);
        try {
            const result = await this.client.indexes.create(publicIndexToGeneratedIndex(index), updatedOptions);
            return generatedIndexToPublicIndex(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new SynonymMap in a search service.
     * @param synonymMap - The synonymMap definition to create in a search service.
     * @param options - Additional optional arguments.
     */
    async createSynonymMap(synonymMap, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-createSynonymMaps", options);
        try {
            const result = await this.client.synonymMaps.create(publicSynonymMapToGeneratedSynonymMap(synonymMap), updatedOptions);
            return generatedSynonymMapToPublicSynonymMap(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new index or modifies an existing one.
     * @param index - The information describing the index to be created.
     * @param options - Additional optional arguments.
     */
    async createOrUpdateIndex(index, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-createOrUpdateIndex", options);
        try {
            const etag = options.onlyIfUnchanged ? index.etag : undefined;
            const result = await this.client.indexes.createOrUpdate(index.name, publicIndexToGeneratedIndex(index), Object.assign(Object.assign({}, updatedOptions), { ifMatch: etag }));
            return generatedIndexToPublicIndex(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new SynonymMap or modifies an existing one.
     * @param synonymMap - The information describing the SynonymMap to be created.
     * @param options - Additional optional arguments.
     */
    async createOrUpdateSynonymMap(synonymMap, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-createOrUpdateSynonymMap", options);
        try {
            const etag = options.onlyIfUnchanged ? synonymMap.etag : undefined;
            const result = await this.client.synonymMaps.createOrUpdate(synonymMap.name, publicSynonymMapToGeneratedSynonymMap(synonymMap), Object.assign(Object.assign({}, updatedOptions), { ifMatch: etag }));
            return generatedSynonymMapToPublicSynonymMap(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes an existing index.
     * @param indexName - Index/Name of the index to delete.
     * @param options - Additional optional arguments.
     */
    async deleteIndex(index, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-deleteIndex", options);
        try {
            const indexName = typeof index === "string" ? index : index.name;
            const etag = typeof index === "string" ? undefined : options.onlyIfUnchanged ? index.etag : undefined;
            await this.client.indexes.delete(indexName, Object.assign(Object.assign({}, updatedOptions), { ifMatch: etag }));
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes an existing SynonymMap.
     * @param synonymMapName - SynonymMap/Name of the synonymMap to delete.
     * @param options - Additional optional arguments.
     */
    async deleteSynonymMap(synonymMap, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-deleteSynonymMap", options);
        try {
            const synonymMapName = typeof synonymMap === "string" ? synonymMap : synonymMap.name;
            const etag = typeof synonymMap === "string"
                ? undefined
                : options.onlyIfUnchanged
                    ? synonymMap.etag
                    : undefined;
            await this.client.synonymMaps.delete(synonymMapName, Object.assign(Object.assign({}, updatedOptions), { ifMatch: etag }));
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves statistics about an index, such as the count of documents and the size
     * of index storage.
     * @param indexName - The name of the index.
     * @param options - Additional optional arguments.
     */
    async getIndexStatistics(indexName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-getIndexStatistics", options);
        try {
            const result = await this.client.indexes.getStatistics(indexName, updatedOptions);
            return result;
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Calls an analyzer or tokenizer manually on provided text.
     * @param indexName - The name of the index that contains the field to analyze
     * @param text - The text to break into tokens.
     * @param options - Additional arguments
     */
    async analyzeText(indexName, options) {
        const { abortSignal, requestOptions, tracingOptions, analyzerName: analyzer, tokenizerName: tokenizer } = options, restOptions = tslib.__rest(options, ["abortSignal", "requestOptions", "tracingOptions", "analyzerName", "tokenizerName"]);
        const operationOptions = {
            abortSignal,
            requestOptions,
            tracingOptions,
        };
        const { span, updatedOptions } = createSpan("SearchIndexClient-analyzeText", operationOptions);
        try {
            const result = await this.client.indexes.analyze(indexName, Object.assign(Object.assign({}, restOptions), { analyzer, tokenizer }), updatedOptions);
            return result;
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves statistics about the service, such as the count of documents, index, etc.
     * @param options - Additional optional arguments.
     */
    async getServiceStatistics(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexClient-getServiceStatistics", options);
        try {
            const result = await this.client.getServiceStatistics(updatedOptions);
            return result;
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves the SearchClient corresponding to this SearchIndexClient
     * @param indexName - Name of the index
     * @param options - SearchClient Options
     * @typeParam TModel - An optional type that represents the documents stored in
     * the search index. For the best typing experience, all non-key fields should
     * be marked optional and nullable, and the key property should have the
     * non-nullable type `string`.
     */
    getSearchClient(indexName, options) {
        return new SearchClient(this.endpoint, indexName, this.credential, options || this.options);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Class to perform operations to manage
 * (create, update, list/delete)
 * indexers, datasources & skillsets.
 */
class SearchIndexerClient {
    /**
     * Creates an instance of SearchIndexerClient.
     *
     * Example usage:
     * ```ts
     * const { SearchIndexerClient, AzureKeyCredential } = require("@azure/search-documents");
     *
     * const client = new SearchIndexerClient(
     *   "<endpoint>",
     *   new AzureKeyCredential("<Admin Key>");
     * );
     * ```
     * @param endpoint - The endpoint of the search service
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Search client.
     */
    constructor(endpoint, credential, options = {}) {
        var _a, _b;
        /**
         * The API version to use when communicating with the service.
         */
        this.serviceVersion = defaultServiceVersion;
        /**
         * The API version to use when communicating with the service.
         * @deprecated use {@Link serviceVersion} instead
         */
        this.apiVersion = defaultServiceVersion;
        this.endpoint = endpoint;
        const internalClientPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
                additionalAllowedHeaderNames: [
                    "elapsed-time",
                    "Location",
                    "OData-MaxVersion",
                    "OData-Version",
                    "Prefer",
                    "throttle-reason",
                ],
            },
        });
        this.serviceVersion =
            (_b = (_a = options.serviceVersion) !== null && _a !== void 0 ? _a : options.apiVersion) !== null && _b !== void 0 ? _b : defaultServiceVersion;
        this.apiVersion = this.serviceVersion;
        this.client = new SearchServiceClient(this.endpoint, this.serviceVersion, internalClientPipelineOptions);
        if (coreAuth.isTokenCredential(credential)) {
            const scope = options.audience
                ? `${options.audience}/.default`
                : `${exports.KnownSearchAudience.AzurePublicCloud}/.default`;
            this.client.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({ credential, scopes: scope }));
        }
        else {
            this.client.pipeline.addPolicy(createSearchApiKeyCredentialPolicy(credential));
        }
        this.client.pipeline.addPolicy(createOdataMetadataPolicy("minimal"));
    }
    /**
     * Retrieves a list of existing indexers in the service.
     * @param options - Options to the list indexers operation.
     */
    async listIndexers(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-listIndexers", options);
        try {
            const result = await this.client.indexers.list(updatedOptions);
            return result.indexers.map(generatedSearchIndexerToPublicSearchIndexer);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of names of existing indexers in the service.
     * @param options - Options to the list indexers operation.
     */
    async listIndexersNames(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-listIndexersNames", options);
        try {
            const result = await this.client.indexers.list(Object.assign(Object.assign({}, updatedOptions), { select: "name" }));
            return result.indexers.map((idx) => idx.name);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of existing data sources in the service.
     * @param options - Options to the list indexers operation.
     */
    async listDataSourceConnections(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-listDataSourceConnections", options);
        try {
            const result = await this.client.dataSources.list(updatedOptions);
            return result.dataSources.map(generatedDataSourceToPublicDataSource);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of names of existing data sources in the service.
     * @param options - Options to the list indexers operation.
     */
    async listDataSourceConnectionsNames(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-listDataSourceConnectionsNames", options);
        try {
            const result = await this.client.dataSources.list(Object.assign(Object.assign({}, updatedOptions), { select: "name" }));
            return result.dataSources.map((ds) => ds.name);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of existing Skillsets in the service.
     * @param options - Options to the list Skillsets operation.
     */
    async listSkillsets(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-listSkillsets", options);
        try {
            const result = await this.client.skillsets.list(updatedOptions);
            return result.skillsets.map(generatedSkillsetToPublicSkillset);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves a list of names of existing Skillsets in the service.
     * @param options - Options to the list Skillsets operation.
     */
    async listSkillsetsNames(options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-listSkillsetsNames", options);
        try {
            const result = await this.client.skillsets.list(Object.assign(Object.assign({}, updatedOptions), { select: "name" }));
            return result.skillsets.map((sks) => sks.name);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves information about an Indexer.
     * @param indexerName - The name of the Indexer.
     * @param options - Additional optional arguments.
     */
    async getIndexer(indexerName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-getIndexer", options);
        try {
            const result = await this.client.indexers.get(indexerName, updatedOptions);
            return generatedSearchIndexerToPublicSearchIndexer(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves information about a DataSource
     * @param dataSourceName - The name of the DataSource
     * @param options - Additional optional arguments
     */
    async getDataSourceConnection(dataSourceConnectionName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-getDataSourceConnection", options);
        try {
            const result = await this.client.dataSources.get(dataSourceConnectionName, updatedOptions);
            return generatedDataSourceToPublicDataSource(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves information about an Skillset.
     * @param indexName - The name of the Skillset.
     * @param options - Additional optional arguments.
     */
    async getSkillset(skillsetName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-getSkillset", options);
        try {
            const result = await this.client.skillsets.get(skillsetName, updatedOptions);
            return generatedSkillsetToPublicSkillset(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new indexer in a search service.
     * @param indexer - The indexer definition to create in a search service.
     * @param options - Additional optional arguments.
     */
    async createIndexer(indexer, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-createIndexer", options);
        try {
            const result = await this.client.indexers.create(publicSearchIndexerToGeneratedSearchIndexer(indexer), updatedOptions);
            return generatedSearchIndexerToPublicSearchIndexer(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new dataSource in a search service.
     * @param dataSourceConnection - The dataSource definition to create in a search service.
     * @param options - Additional optional arguments.
     */
    async createDataSourceConnection(dataSourceConnection, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-createDataSourceConnection", options);
        try {
            const result = await this.client.dataSources.create(publicDataSourceToGeneratedDataSource(dataSourceConnection), updatedOptions);
            return generatedDataSourceToPublicDataSource(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new skillset in a search service.
     * @param skillset - The skillset containing one or more skills to create in a search service.
     * @param options - Additional optional arguments.
     */
    async createSkillset(skillset, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-createSkillset", options);
        try {
            const result = await this.client.skillsets.create(publicSkillsetToGeneratedSkillset(skillset), updatedOptions);
            return generatedSkillsetToPublicSkillset(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new indexer or modifies an existing one.
     * @param indexer - The information describing the indexer to be created/updated.
     * @param options - Additional optional arguments.
     */
    async createOrUpdateIndexer(indexer, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-createOrUpdateIndexer", options);
        try {
            const etag = options.onlyIfUnchanged ? indexer.etag : undefined;
            const result = await this.client.indexers.createOrUpdate(indexer.name, publicSearchIndexerToGeneratedSearchIndexer(indexer), Object.assign(Object.assign({}, updatedOptions), { ifMatch: etag }));
            return generatedSearchIndexerToPublicSearchIndexer(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new datasource or modifies an existing one.
     * @param dataSourceConnection - The information describing the datasource to be created/updated.
     * @param options - Additional optional arguments.
     */
    async createOrUpdateDataSourceConnection(dataSourceConnection, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-createOrUpdateDataSourceConnection", options);
        try {
            const etag = options.onlyIfUnchanged ? dataSourceConnection.etag : undefined;
            const result = await this.client.dataSources.createOrUpdate(dataSourceConnection.name, publicDataSourceToGeneratedDataSource(dataSourceConnection), Object.assign(Object.assign({}, updatedOptions), { ifMatch: etag }));
            return generatedDataSourceToPublicDataSource(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new Skillset or modifies an existing one.
     * @param skillset - The information describing the index to be created.
     * @param options - Additional optional arguments.
     */
    async createOrUpdateSkillset(skillset, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-createOrUpdateSkillset", options);
        try {
            const etag = options.onlyIfUnchanged ? skillset.etag : undefined;
            const result = await this.client.skillsets.createOrUpdate(skillset.name, publicSkillsetToGeneratedSkillset(skillset), Object.assign(Object.assign({}, updatedOptions), { ifMatch: etag }));
            return generatedSkillsetToPublicSkillset(result);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes an existing indexer.
     * @param indexer - Indexer/Name of the indexer to delete.
     * @param options - Additional optional arguments.
     */
    async deleteIndexer(indexer, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-deleteIndexer", options);
        try {
            const indexerName = typeof indexer === "string" ? indexer : indexer.name;
            const etag = typeof indexer === "string"
                ? undefined
                : options.onlyIfUnchanged
                    ? indexer.etag
                    : undefined;
            await this.client.indexers.delete(indexerName, Object.assign(Object.assign({}, updatedOptions), { ifMatch: etag }));
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes an existing datasource.
     * @param dataSource - Datasource/Name of the datasource to delete.
     * @param options - Additional optional arguments.
     */
    async deleteDataSourceConnection(dataSourceConnection, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-deleteDataSourceConnection", options);
        try {
            const dataSourceConnectionName = typeof dataSourceConnection === "string" ? dataSourceConnection : dataSourceConnection.name;
            const etag = typeof dataSourceConnection === "string"
                ? undefined
                : options.onlyIfUnchanged
                    ? dataSourceConnection.etag
                    : undefined;
            await this.client.dataSources.delete(dataSourceConnectionName, Object.assign(Object.assign({}, updatedOptions), { ifMatch: etag }));
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes an existing Skillset.
     * @param skillset - Skillset/Name of the Skillset to delete.
     * @param options - Additional optional arguments.
     */
    async deleteSkillset(skillset, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-deleteSkillset", options);
        try {
            const skillsetName = typeof skillset === "string" ? skillset : skillset.name;
            const etag = typeof skillset === "string"
                ? undefined
                : options.onlyIfUnchanged
                    ? skillset.etag
                    : undefined;
            await this.client.skillsets.delete(skillsetName, Object.assign(Object.assign({}, updatedOptions), { ifMatch: etag }));
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns the current status and execution history of an indexer.
     * @param indexerName - The name of the indexer.
     * @param options - Additional optional arguments.
     */
    async getIndexerStatus(indexerName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-getIndexerStatus", options);
        try {
            const result = await this.client.indexers.getStatus(indexerName, updatedOptions);
            return result;
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Resets the change tracking state associated with an indexer.
     * @param indexerName - The name of the indexer to reset.
     * @param options - Additional optional arguments.
     */
    async resetIndexer(indexerName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-resetIndexer", options);
        try {
            await this.client.indexers.reset(indexerName, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Runs an indexer on-demand.
     * @param indexerName - The name of the indexer to run.
     * @param options - Additional optional arguments.
     */
    async runIndexer(indexerName, options = {}) {
        const { span, updatedOptions } = createSpan("SearchIndexerClient-runIndexer", options);
        try {
            await this.client.indexers.run(indexerName, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                status: "error",
                error: e.message,
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function formatNullAndUndefined(input) {
    if (input === null || input === undefined) {
        return "null";
    }
    return input;
}
function escapeQuotesIfString(input, previous) {
    let result = input;
    if (typeof input === "string") {
        result = input.replace(/'/g, "''");
        // check if we need to escape this literal
        if (!previous.trim().endsWith("'")) {
            result = `'${result}'`;
        }
    }
    return result;
}
/**
 * Escapes an odata filter expression to avoid errors with quoting string literals.
 * Example usage:
 * ```ts
 * const baseRateMax = 200;
 * const ratingMin = 4;
 * const filter = odata`Rooms/any(room: room/BaseRate lt ${baseRateMax}) and Rating ge ${ratingMin}`;
 * ```
 * For more information on supported syntax see: https://docs.microsoft.com/en-us/azure/search/search-query-odata-filter
 * @param strings - Array of strings for the expression
 * @param values - Array of values for the expression
 */
function odata(strings, ...values) {
    const results = [];
    for (let i = 0; i < strings.length; i++) {
        results.push(strings[i]);
        if (i < values.length) {
            if (values[i] === null || values[i] === undefined) {
                results.push(formatNullAndUndefined(values[i]));
            }
            else {
                results.push(escapeQuotesIfString(values[i], strings[i]));
            }
        }
    }
    return results.join("");
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ApiVersion20231101} that the service accepts. */
var KnownApiVersion20231101;
(function (KnownApiVersion20231101) {
    /** Api Version '2023-11-01' */
    KnownApiVersion20231101["TwoThousandTwentyThree1101"] = "2023-11-01";
})(KnownApiVersion20231101 || (KnownApiVersion20231101 = {}));
/** Known values of {@link SearchIndexerDataSourceType} that the service accepts. */
exports.KnownSearchIndexerDataSourceType = void 0;
(function (KnownSearchIndexerDataSourceType) {
    /** Indicates an Azure SQL datasource. */
    KnownSearchIndexerDataSourceType["AzureSql"] = "azuresql";
    /** Indicates a CosmosDB datasource. */
    KnownSearchIndexerDataSourceType["CosmosDb"] = "cosmosdb";
    /** Indicates an Azure Blob datasource. */
    KnownSearchIndexerDataSourceType["AzureBlob"] = "azureblob";
    /** Indicates an Azure Table datasource. */
    KnownSearchIndexerDataSourceType["AzureTable"] = "azuretable";
    /** Indicates a MySql datasource. */
    KnownSearchIndexerDataSourceType["MySql"] = "mysql";
    /** Indicates an ADLS Gen2 datasource. */
    KnownSearchIndexerDataSourceType["AdlsGen2"] = "adlsgen2";
})(exports.KnownSearchIndexerDataSourceType || (exports.KnownSearchIndexerDataSourceType = {}));
/** Known values of {@link BlobIndexerParsingMode} that the service accepts. */
exports.KnownBlobIndexerParsingMode = void 0;
(function (KnownBlobIndexerParsingMode) {
    /** Set to default for normal file processing. */
    KnownBlobIndexerParsingMode["Default"] = "default";
    /** Set to text to improve indexing performance on plain text files in blob storage. */
    KnownBlobIndexerParsingMode["Text"] = "text";
    /** Set to delimitedText when blobs are plain CSV files. */
    KnownBlobIndexerParsingMode["DelimitedText"] = "delimitedText";
    /** Set to json to extract structured content from JSON files. */
    KnownBlobIndexerParsingMode["Json"] = "json";
    /** Set to jsonArray to extract individual elements of a JSON array as separate documents. */
    KnownBlobIndexerParsingMode["JsonArray"] = "jsonArray";
    /** Set to jsonLines to extract individual JSON entities, separated by a new line, as separate documents. */
    KnownBlobIndexerParsingMode["JsonLines"] = "jsonLines";
})(exports.KnownBlobIndexerParsingMode || (exports.KnownBlobIndexerParsingMode = {}));
/** Known values of {@link BlobIndexerDataToExtract} that the service accepts. */
exports.KnownBlobIndexerDataToExtract = void 0;
(function (KnownBlobIndexerDataToExtract) {
    /** Indexes just the standard blob properties and user-specified metadata. */
    KnownBlobIndexerDataToExtract["StorageMetadata"] = "storageMetadata";
    /** Extracts metadata provided by the Azure blob storage subsystem and the content-type specific metadata (for example, metadata unique to just .png files are indexed). */
    KnownBlobIndexerDataToExtract["AllMetadata"] = "allMetadata";
    /** Extracts all metadata and textual content from each blob. */
    KnownBlobIndexerDataToExtract["ContentAndMetadata"] = "contentAndMetadata";
})(exports.KnownBlobIndexerDataToExtract || (exports.KnownBlobIndexerDataToExtract = {}));
/** Known values of {@link BlobIndexerImageAction} that the service accepts. */
exports.KnownBlobIndexerImageAction = void 0;
(function (KnownBlobIndexerImageAction) {
    /** Ignores embedded images or image files in the data set.  This is the default. */
    KnownBlobIndexerImageAction["None"] = "none";
    /** Extracts text from images (for example, the word "STOP" from a traffic stop sign), and embeds it into the content field.  This action requires that "dataToExtract" is set to "contentAndMetadata".  A normalized image refers to additional processing resulting in uniform image output, sized and rotated to promote consistent rendering when you include images in visual search results. This information is generated for each image when you use this option. */
    KnownBlobIndexerImageAction["GenerateNormalizedImages"] = "generateNormalizedImages";
    /** Extracts text from images (for example, the word "STOP" from a traffic stop sign), and embeds it into the content field, but treats PDF files differently in that each page will be rendered as an image and normalized accordingly, instead of extracting embedded images.  Non-PDF file types will be treated the same as if "generateNormalizedImages" was set. */
    KnownBlobIndexerImageAction["GenerateNormalizedImagePerPage"] = "generateNormalizedImagePerPage";
})(exports.KnownBlobIndexerImageAction || (exports.KnownBlobIndexerImageAction = {}));
/** Known values of {@link BlobIndexerPDFTextRotationAlgorithm} that the service accepts. */
exports.KnownBlobIndexerPDFTextRotationAlgorithm = void 0;
(function (KnownBlobIndexerPDFTextRotationAlgorithm) {
    /** Leverages normal text extraction.  This is the default. */
    KnownBlobIndexerPDFTextRotationAlgorithm["None"] = "none";
    /** May produce better and more readable text extraction from PDF files that have rotated text within them.  Note that there may be a small performance speed impact when this parameter is used.  This parameter only applies to PDF files, and only to PDFs with embedded text.  If the rotated text appears within an embedded image in the PDF, this parameter does not apply. */
    KnownBlobIndexerPDFTextRotationAlgorithm["DetectAngles"] = "detectAngles";
})(exports.KnownBlobIndexerPDFTextRotationAlgorithm || (exports.KnownBlobIndexerPDFTextRotationAlgorithm = {}));
/** Known values of {@link IndexerExecutionEnvironment} that the service accepts. */
var KnownIndexerExecutionEnvironment;
(function (KnownIndexerExecutionEnvironment) {
    /** Indicates that the search service can determine where the indexer should execute. This is the default environment when nothing is specified and is the recommended value. */
    KnownIndexerExecutionEnvironment["Standard"] = "standard";
    /** Indicates that the indexer should run with the environment provisioned specifically for the search service. This should only be specified as the execution environment if the indexer needs to access resources securely over shared private link resources. */
    KnownIndexerExecutionEnvironment["Private"] = "private";
})(KnownIndexerExecutionEnvironment || (KnownIndexerExecutionEnvironment = {}));
/** Known values of {@link SearchFieldDataType} that the service accepts. */
var KnownSearchFieldDataType;
(function (KnownSearchFieldDataType) {
    /** Indicates that a field contains a string. */
    KnownSearchFieldDataType["String"] = "Edm.String";
    /** Indicates that a field contains a 32-bit signed integer. */
    KnownSearchFieldDataType["Int32"] = "Edm.Int32";
    /** Indicates that a field contains a 64-bit signed integer. */
    KnownSearchFieldDataType["Int64"] = "Edm.Int64";
    /** Indicates that a field contains an IEEE double-precision floating point number. */
    KnownSearchFieldDataType["Double"] = "Edm.Double";
    /** Indicates that a field contains a Boolean value (true or false). */
    KnownSearchFieldDataType["Boolean"] = "Edm.Boolean";
    /** Indicates that a field contains a date\/time value, including timezone information. */
    KnownSearchFieldDataType["DateTimeOffset"] = "Edm.DateTimeOffset";
    /** Indicates that a field contains a geo-location in terms of longitude and latitude. */
    KnownSearchFieldDataType["GeographyPoint"] = "Edm.GeographyPoint";
    /** Indicates that a field contains one or more complex objects that in turn have sub-fields of other types. */
    KnownSearchFieldDataType["Complex"] = "Edm.ComplexType";
    /** Indicates that a field contains a single-precision floating point number. This is only valid when used with Collection(Edm.Single). */
    KnownSearchFieldDataType["Single"] = "Edm.Single";
})(KnownSearchFieldDataType || (KnownSearchFieldDataType = {}));
/** Known values of {@link LexicalAnalyzerName} that the service accepts. */
var KnownLexicalAnalyzerName;
(function (KnownLexicalAnalyzerName) {
    /** Microsoft analyzer for Arabic. */
    KnownLexicalAnalyzerName["ArMicrosoft"] = "ar.microsoft";
    /** Lucene analyzer for Arabic. */
    KnownLexicalAnalyzerName["ArLucene"] = "ar.lucene";
    /** Lucene analyzer for Armenian. */
    KnownLexicalAnalyzerName["HyLucene"] = "hy.lucene";
    /** Microsoft analyzer for Bangla. */
    KnownLexicalAnalyzerName["BnMicrosoft"] = "bn.microsoft";
    /** Lucene analyzer for Basque. */
    KnownLexicalAnalyzerName["EuLucene"] = "eu.lucene";
    /** Microsoft analyzer for Bulgarian. */
    KnownLexicalAnalyzerName["BgMicrosoft"] = "bg.microsoft";
    /** Lucene analyzer for Bulgarian. */
    KnownLexicalAnalyzerName["BgLucene"] = "bg.lucene";
    /** Microsoft analyzer for Catalan. */
    KnownLexicalAnalyzerName["CaMicrosoft"] = "ca.microsoft";
    /** Lucene analyzer for Catalan. */
    KnownLexicalAnalyzerName["CaLucene"] = "ca.lucene";
    /** Microsoft analyzer for Chinese (Simplified). */
    KnownLexicalAnalyzerName["ZhHansMicrosoft"] = "zh-Hans.microsoft";
    /** Lucene analyzer for Chinese (Simplified). */
    KnownLexicalAnalyzerName["ZhHansLucene"] = "zh-Hans.lucene";
    /** Microsoft analyzer for Chinese (Traditional). */
    KnownLexicalAnalyzerName["ZhHantMicrosoft"] = "zh-Hant.microsoft";
    /** Lucene analyzer for Chinese (Traditional). */
    KnownLexicalAnalyzerName["ZhHantLucene"] = "zh-Hant.lucene";
    /** Microsoft analyzer for Croatian. */
    KnownLexicalAnalyzerName["HrMicrosoft"] = "hr.microsoft";
    /** Microsoft analyzer for Czech. */
    KnownLexicalAnalyzerName["CsMicrosoft"] = "cs.microsoft";
    /** Lucene analyzer for Czech. */
    KnownLexicalAnalyzerName["CsLucene"] = "cs.lucene";
    /** Microsoft analyzer for Danish. */
    KnownLexicalAnalyzerName["DaMicrosoft"] = "da.microsoft";
    /** Lucene analyzer for Danish. */
    KnownLexicalAnalyzerName["DaLucene"] = "da.lucene";
    /** Microsoft analyzer for Dutch. */
    KnownLexicalAnalyzerName["NlMicrosoft"] = "nl.microsoft";
    /** Lucene analyzer for Dutch. */
    KnownLexicalAnalyzerName["NlLucene"] = "nl.lucene";
    /** Microsoft analyzer for English. */
    KnownLexicalAnalyzerName["EnMicrosoft"] = "en.microsoft";
    /** Lucene analyzer for English. */
    KnownLexicalAnalyzerName["EnLucene"] = "en.lucene";
    /** Microsoft analyzer for Estonian. */
    KnownLexicalAnalyzerName["EtMicrosoft"] = "et.microsoft";
    /** Microsoft analyzer for Finnish. */
    KnownLexicalAnalyzerName["FiMicrosoft"] = "fi.microsoft";
    /** Lucene analyzer for Finnish. */
    KnownLexicalAnalyzerName["FiLucene"] = "fi.lucene";
    /** Microsoft analyzer for French. */
    KnownLexicalAnalyzerName["FrMicrosoft"] = "fr.microsoft";
    /** Lucene analyzer for French. */
    KnownLexicalAnalyzerName["FrLucene"] = "fr.lucene";
    /** Lucene analyzer for Galician. */
    KnownLexicalAnalyzerName["GlLucene"] = "gl.lucene";
    /** Microsoft analyzer for German. */
    KnownLexicalAnalyzerName["DeMicrosoft"] = "de.microsoft";
    /** Lucene analyzer for German. */
    KnownLexicalAnalyzerName["DeLucene"] = "de.lucene";
    /** Microsoft analyzer for Greek. */
    KnownLexicalAnalyzerName["ElMicrosoft"] = "el.microsoft";
    /** Lucene analyzer for Greek. */
    KnownLexicalAnalyzerName["ElLucene"] = "el.lucene";
    /** Microsoft analyzer for Gujarati. */
    KnownLexicalAnalyzerName["GuMicrosoft"] = "gu.microsoft";
    /** Microsoft analyzer for Hebrew. */
    KnownLexicalAnalyzerName["HeMicrosoft"] = "he.microsoft";
    /** Microsoft analyzer for Hindi. */
    KnownLexicalAnalyzerName["HiMicrosoft"] = "hi.microsoft";
    /** Lucene analyzer for Hindi. */
    KnownLexicalAnalyzerName["HiLucene"] = "hi.lucene";
    /** Microsoft analyzer for Hungarian. */
    KnownLexicalAnalyzerName["HuMicrosoft"] = "hu.microsoft";
    /** Lucene analyzer for Hungarian. */
    KnownLexicalAnalyzerName["HuLucene"] = "hu.lucene";
    /** Microsoft analyzer for Icelandic. */
    KnownLexicalAnalyzerName["IsMicrosoft"] = "is.microsoft";
    /** Microsoft analyzer for Indonesian (Bahasa). */
    KnownLexicalAnalyzerName["IdMicrosoft"] = "id.microsoft";
    /** Lucene analyzer for Indonesian. */
    KnownLexicalAnalyzerName["IdLucene"] = "id.lucene";
    /** Lucene analyzer for Irish. */
    KnownLexicalAnalyzerName["GaLucene"] = "ga.lucene";
    /** Microsoft analyzer for Italian. */
    KnownLexicalAnalyzerName["ItMicrosoft"] = "it.microsoft";
    /** Lucene analyzer for Italian. */
    KnownLexicalAnalyzerName["ItLucene"] = "it.lucene";
    /** Microsoft analyzer for Japanese. */
    KnownLexicalAnalyzerName["JaMicrosoft"] = "ja.microsoft";
    /** Lucene analyzer for Japanese. */
    KnownLexicalAnalyzerName["JaLucene"] = "ja.lucene";
    /** Microsoft analyzer for Kannada. */
    KnownLexicalAnalyzerName["KnMicrosoft"] = "kn.microsoft";
    /** Microsoft analyzer for Korean. */
    KnownLexicalAnalyzerName["KoMicrosoft"] = "ko.microsoft";
    /** Lucene analyzer for Korean. */
    KnownLexicalAnalyzerName["KoLucene"] = "ko.lucene";
    /** Microsoft analyzer for Latvian. */
    KnownLexicalAnalyzerName["LvMicrosoft"] = "lv.microsoft";
    /** Lucene analyzer for Latvian. */
    KnownLexicalAnalyzerName["LvLucene"] = "lv.lucene";
    /** Microsoft analyzer for Lithuanian. */
    KnownLexicalAnalyzerName["LtMicrosoft"] = "lt.microsoft";
    /** Microsoft analyzer for Malayalam. */
    KnownLexicalAnalyzerName["MlMicrosoft"] = "ml.microsoft";
    /** Microsoft analyzer for Malay (Latin). */
    KnownLexicalAnalyzerName["MsMicrosoft"] = "ms.microsoft";
    /** Microsoft analyzer for Marathi. */
    KnownLexicalAnalyzerName["MrMicrosoft"] = "mr.microsoft";
    /** Microsoft analyzer for Norwegian (Bokmål). */
    KnownLexicalAnalyzerName["NbMicrosoft"] = "nb.microsoft";
    /** Lucene analyzer for Norwegian. */
    KnownLexicalAnalyzerName["NoLucene"] = "no.lucene";
    /** Lucene analyzer for Persian. */
    KnownLexicalAnalyzerName["FaLucene"] = "fa.lucene";
    /** Microsoft analyzer for Polish. */
    KnownLexicalAnalyzerName["PlMicrosoft"] = "pl.microsoft";
    /** Lucene analyzer for Polish. */
    KnownLexicalAnalyzerName["PlLucene"] = "pl.lucene";
    /** Microsoft analyzer for Portuguese (Brazil). */
    KnownLexicalAnalyzerName["PtBrMicrosoft"] = "pt-BR.microsoft";
    /** Lucene analyzer for Portuguese (Brazil). */
    KnownLexicalAnalyzerName["PtBrLucene"] = "pt-BR.lucene";
    /** Microsoft analyzer for Portuguese (Portugal). */
    KnownLexicalAnalyzerName["PtPtMicrosoft"] = "pt-PT.microsoft";
    /** Lucene analyzer for Portuguese (Portugal). */
    KnownLexicalAnalyzerName["PtPtLucene"] = "pt-PT.lucene";
    /** Microsoft analyzer for Punjabi. */
    KnownLexicalAnalyzerName["PaMicrosoft"] = "pa.microsoft";
    /** Microsoft analyzer for Romanian. */
    KnownLexicalAnalyzerName["RoMicrosoft"] = "ro.microsoft";
    /** Lucene analyzer for Romanian. */
    KnownLexicalAnalyzerName["RoLucene"] = "ro.lucene";
    /** Microsoft analyzer for Russian. */
    KnownLexicalAnalyzerName["RuMicrosoft"] = "ru.microsoft";
    /** Lucene analyzer for Russian. */
    KnownLexicalAnalyzerName["RuLucene"] = "ru.lucene";
    /** Microsoft analyzer for Serbian (Cyrillic). */
    KnownLexicalAnalyzerName["SrCyrillicMicrosoft"] = "sr-cyrillic.microsoft";
    /** Microsoft analyzer for Serbian (Latin). */
    KnownLexicalAnalyzerName["SrLatinMicrosoft"] = "sr-latin.microsoft";
    /** Microsoft analyzer for Slovak. */
    KnownLexicalAnalyzerName["SkMicrosoft"] = "sk.microsoft";
    /** Microsoft analyzer for Slovenian. */
    KnownLexicalAnalyzerName["SlMicrosoft"] = "sl.microsoft";
    /** Microsoft analyzer for Spanish. */
    KnownLexicalAnalyzerName["EsMicrosoft"] = "es.microsoft";
    /** Lucene analyzer for Spanish. */
    KnownLexicalAnalyzerName["EsLucene"] = "es.lucene";
    /** Microsoft analyzer for Swedish. */
    KnownLexicalAnalyzerName["SvMicrosoft"] = "sv.microsoft";
    /** Lucene analyzer for Swedish. */
    KnownLexicalAnalyzerName["SvLucene"] = "sv.lucene";
    /** Microsoft analyzer for Tamil. */
    KnownLexicalAnalyzerName["TaMicrosoft"] = "ta.microsoft";
    /** Microsoft analyzer for Telugu. */
    KnownLexicalAnalyzerName["TeMicrosoft"] = "te.microsoft";
    /** Microsoft analyzer for Thai. */
    KnownLexicalAnalyzerName["ThMicrosoft"] = "th.microsoft";
    /** Lucene analyzer for Thai. */
    KnownLexicalAnalyzerName["ThLucene"] = "th.lucene";
    /** Microsoft analyzer for Turkish. */
    KnownLexicalAnalyzerName["TrMicrosoft"] = "tr.microsoft";
    /** Lucene analyzer for Turkish. */
    KnownLexicalAnalyzerName["TrLucene"] = "tr.lucene";
    /** Microsoft analyzer for Ukrainian. */
    KnownLexicalAnalyzerName["UkMicrosoft"] = "uk.microsoft";
    /** Microsoft analyzer for Urdu. */
    KnownLexicalAnalyzerName["UrMicrosoft"] = "ur.microsoft";
    /** Microsoft analyzer for Vietnamese. */
    KnownLexicalAnalyzerName["ViMicrosoft"] = "vi.microsoft";
    /** Standard Lucene analyzer. */
    KnownLexicalAnalyzerName["StandardLucene"] = "standard.lucene";
    /** Standard ASCII Folding Lucene analyzer. See https:\//docs.microsoft.com\/rest\/api\/searchservice\/Custom-analyzers-in-Azure-Search#Analyzers */
    KnownLexicalAnalyzerName["StandardAsciiFoldingLucene"] = "standardasciifolding.lucene";
    /** Treats the entire content of a field as a single token. This is useful for data like zip codes, ids, and some product names. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/KeywordAnalyzer.html */
    KnownLexicalAnalyzerName["Keyword"] = "keyword";
    /** Flexibly separates text into terms via a regular expression pattern. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/PatternAnalyzer.html */
    KnownLexicalAnalyzerName["Pattern"] = "pattern";
    /** Divides text at non-letters and converts them to lower case. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/SimpleAnalyzer.html */
    KnownLexicalAnalyzerName["Simple"] = "simple";
    /** Divides text at non-letters; Applies the lowercase and stopword token filters. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/StopAnalyzer.html */
    KnownLexicalAnalyzerName["Stop"] = "stop";
    /** An analyzer that uses the whitespace tokenizer. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/WhitespaceAnalyzer.html */
    KnownLexicalAnalyzerName["Whitespace"] = "whitespace";
})(KnownLexicalAnalyzerName || (KnownLexicalAnalyzerName = {}));
/** Known values of {@link VectorSearchAlgorithmKind} that the service accepts. */
var KnownVectorSearchAlgorithmKind;
(function (KnownVectorSearchAlgorithmKind) {
    /** HNSW (Hierarchical Navigable Small World), a type of approximate nearest neighbors algorithm. */
    KnownVectorSearchAlgorithmKind["Hnsw"] = "hnsw";
    /** Exhaustive KNN algorithm which will perform brute-force search. */
    KnownVectorSearchAlgorithmKind["ExhaustiveKnn"] = "exhaustiveKnn";
})(KnownVectorSearchAlgorithmKind || (KnownVectorSearchAlgorithmKind = {}));
/** Known values of {@link VectorSearchAlgorithmMetric} that the service accepts. */
var KnownVectorSearchAlgorithmMetric;
(function (KnownVectorSearchAlgorithmMetric) {
    /** Cosine */
    KnownVectorSearchAlgorithmMetric["Cosine"] = "cosine";
    /** Euclidean */
    KnownVectorSearchAlgorithmMetric["Euclidean"] = "euclidean";
    /** DotProduct */
    KnownVectorSearchAlgorithmMetric["DotProduct"] = "dotProduct";
})(KnownVectorSearchAlgorithmMetric || (KnownVectorSearchAlgorithmMetric = {}));
/** Known values of {@link KeyPhraseExtractionSkillLanguage} that the service accepts. */
exports.KnownKeyPhraseExtractionSkillLanguage = void 0;
(function (KnownKeyPhraseExtractionSkillLanguage) {
    /** Danish */
    KnownKeyPhraseExtractionSkillLanguage["Da"] = "da";
    /** Dutch */
    KnownKeyPhraseExtractionSkillLanguage["Nl"] = "nl";
    /** English */
    KnownKeyPhraseExtractionSkillLanguage["En"] = "en";
    /** Finnish */
    KnownKeyPhraseExtractionSkillLanguage["Fi"] = "fi";
    /** French */
    KnownKeyPhraseExtractionSkillLanguage["Fr"] = "fr";
    /** German */
    KnownKeyPhraseExtractionSkillLanguage["De"] = "de";
    /** Italian */
    KnownKeyPhraseExtractionSkillLanguage["It"] = "it";
    /** Japanese */
    KnownKeyPhraseExtractionSkillLanguage["Ja"] = "ja";
    /** Korean */
    KnownKeyPhraseExtractionSkillLanguage["Ko"] = "ko";
    /** Norwegian (Bokmaal) */
    KnownKeyPhraseExtractionSkillLanguage["No"] = "no";
    /** Polish */
    KnownKeyPhraseExtractionSkillLanguage["Pl"] = "pl";
    /** Portuguese (Portugal) */
    KnownKeyPhraseExtractionSkillLanguage["PtPT"] = "pt-PT";
    /** Portuguese (Brazil) */
    KnownKeyPhraseExtractionSkillLanguage["PtBR"] = "pt-BR";
    /** Russian */
    KnownKeyPhraseExtractionSkillLanguage["Ru"] = "ru";
    /** Spanish */
    KnownKeyPhraseExtractionSkillLanguage["Es"] = "es";
    /** Swedish */
    KnownKeyPhraseExtractionSkillLanguage["Sv"] = "sv";
})(exports.KnownKeyPhraseExtractionSkillLanguage || (exports.KnownKeyPhraseExtractionSkillLanguage = {}));
/** Known values of {@link OcrSkillLanguage} that the service accepts. */
exports.KnownOcrSkillLanguage = void 0;
(function (KnownOcrSkillLanguage) {
    /** Afrikaans */
    KnownOcrSkillLanguage["Af"] = "af";
    /** Albanian */
    KnownOcrSkillLanguage["Sq"] = "sq";
    /** Angika (Devanagiri) */
    KnownOcrSkillLanguage["Anp"] = "anp";
    /** Arabic */
    KnownOcrSkillLanguage["Ar"] = "ar";
    /** Asturian */
    KnownOcrSkillLanguage["Ast"] = "ast";
    /** Awadhi-Hindi (Devanagiri) */
    KnownOcrSkillLanguage["Awa"] = "awa";
    /** Azerbaijani (Latin) */
    KnownOcrSkillLanguage["Az"] = "az";
    /** Bagheli */
    KnownOcrSkillLanguage["Bfy"] = "bfy";
    /** Basque */
    KnownOcrSkillLanguage["Eu"] = "eu";
    /** Belarusian (Cyrillic and Latin) */
    KnownOcrSkillLanguage["Be"] = "be";
    /** Belarusian (Cyrillic) */
    KnownOcrSkillLanguage["BeCyrl"] = "be-cyrl";
    /** Belarusian (Latin) */
    KnownOcrSkillLanguage["BeLatn"] = "be-latn";
    /** Bhojpuri-Hindi (Devanagiri) */
    KnownOcrSkillLanguage["Bho"] = "bho";
    /** Bislama */
    KnownOcrSkillLanguage["Bi"] = "bi";
    /** Bodo (Devanagiri) */
    KnownOcrSkillLanguage["Brx"] = "brx";
    /** Bosnian Latin */
    KnownOcrSkillLanguage["Bs"] = "bs";
    /** Brajbha */
    KnownOcrSkillLanguage["Bra"] = "bra";
    /** Breton */
    KnownOcrSkillLanguage["Br"] = "br";
    /** Bulgarian */
    KnownOcrSkillLanguage["Bg"] = "bg";
    /** Bundeli */
    KnownOcrSkillLanguage["Bns"] = "bns";
    /** Buryat (Cyrillic) */
    KnownOcrSkillLanguage["Bua"] = "bua";
    /** Catalan */
    KnownOcrSkillLanguage["Ca"] = "ca";
    /** Cebuano */
    KnownOcrSkillLanguage["Ceb"] = "ceb";
    /** Chamling */
    KnownOcrSkillLanguage["Rab"] = "rab";
    /** Chamorro */
    KnownOcrSkillLanguage["Ch"] = "ch";
    /** Chhattisgarhi (Devanagiri) */
    KnownOcrSkillLanguage["Hne"] = "hne";
    /** Chinese Simplified */
    KnownOcrSkillLanguage["ZhHans"] = "zh-Hans";
    /** Chinese Traditional */
    KnownOcrSkillLanguage["ZhHant"] = "zh-Hant";
    /** Cornish */
    KnownOcrSkillLanguage["Kw"] = "kw";
    /** Corsican */
    KnownOcrSkillLanguage["Co"] = "co";
    /** Crimean Tatar (Latin) */
    KnownOcrSkillLanguage["Crh"] = "crh";
    /** Croatian */
    KnownOcrSkillLanguage["Hr"] = "hr";
    /** Czech */
    KnownOcrSkillLanguage["Cs"] = "cs";
    /** Danish */
    KnownOcrSkillLanguage["Da"] = "da";
    /** Dari */
    KnownOcrSkillLanguage["Prs"] = "prs";
    /** Dhimal (Devanagiri) */
    KnownOcrSkillLanguage["Dhi"] = "dhi";
    /** Dogri (Devanagiri) */
    KnownOcrSkillLanguage["Doi"] = "doi";
    /** Dutch */
    KnownOcrSkillLanguage["Nl"] = "nl";
    /** English */
    KnownOcrSkillLanguage["En"] = "en";
    /** Erzya (Cyrillic) */
    KnownOcrSkillLanguage["Myv"] = "myv";
    /** Estonian */
    KnownOcrSkillLanguage["Et"] = "et";
    /** Faroese */
    KnownOcrSkillLanguage["Fo"] = "fo";
    /** Fijian */
    KnownOcrSkillLanguage["Fj"] = "fj";
    /** Filipino */
    KnownOcrSkillLanguage["Fil"] = "fil";
    /** Finnish */
    KnownOcrSkillLanguage["Fi"] = "fi";
    /** French */
    KnownOcrSkillLanguage["Fr"] = "fr";
    /** Frulian */
    KnownOcrSkillLanguage["Fur"] = "fur";
    /** Gagauz (Latin) */
    KnownOcrSkillLanguage["Gag"] = "gag";
    /** Galician */
    KnownOcrSkillLanguage["Gl"] = "gl";
    /** German */
    KnownOcrSkillLanguage["De"] = "de";
    /** Gilbertese */
    KnownOcrSkillLanguage["Gil"] = "gil";
    /** Gondi (Devanagiri) */
    KnownOcrSkillLanguage["Gon"] = "gon";
    /** Greek */
    KnownOcrSkillLanguage["El"] = "el";
    /** Greenlandic */
    KnownOcrSkillLanguage["Kl"] = "kl";
    /** Gurung (Devanagiri) */
    KnownOcrSkillLanguage["Gvr"] = "gvr";
    /** Haitian Creole */
    KnownOcrSkillLanguage["Ht"] = "ht";
    /** Halbi (Devanagiri) */
    KnownOcrSkillLanguage["Hlb"] = "hlb";
    /** Hani */
    KnownOcrSkillLanguage["Hni"] = "hni";
    /** Haryanvi */
    KnownOcrSkillLanguage["Bgc"] = "bgc";
    /** Hawaiian */
    KnownOcrSkillLanguage["Haw"] = "haw";
    /** Hindi */
    KnownOcrSkillLanguage["Hi"] = "hi";
    /** Hmong Daw (Latin) */
    KnownOcrSkillLanguage["Mww"] = "mww";
    /** Ho (Devanagiri) */
    KnownOcrSkillLanguage["Hoc"] = "hoc";
    /** Hungarian */
    KnownOcrSkillLanguage["Hu"] = "hu";
    /** Icelandic */
    KnownOcrSkillLanguage["Is"] = "is";
    /** Inari Sami */
    KnownOcrSkillLanguage["Smn"] = "smn";
    /** Indonesian */
    KnownOcrSkillLanguage["Id"] = "id";
    /** Interlingua */
    KnownOcrSkillLanguage["Ia"] = "ia";
    /** Inuktitut (Latin) */
    KnownOcrSkillLanguage["Iu"] = "iu";
    /** Irish */
    KnownOcrSkillLanguage["Ga"] = "ga";
    /** Italian */
    KnownOcrSkillLanguage["It"] = "it";
    /** Japanese */
    KnownOcrSkillLanguage["Ja"] = "ja";
    /** Jaunsari (Devanagiri) */
    KnownOcrSkillLanguage["Jns"] = "Jns";
    /** Javanese */
    KnownOcrSkillLanguage["Jv"] = "jv";
    /** Kabuverdianu */
    KnownOcrSkillLanguage["Kea"] = "kea";
    /** Kachin (Latin) */
    KnownOcrSkillLanguage["Kac"] = "kac";
    /** Kangri (Devanagiri) */
    KnownOcrSkillLanguage["Xnr"] = "xnr";
    /** Karachay-Balkar */
    KnownOcrSkillLanguage["Krc"] = "krc";
    /** Kara-Kalpak (Cyrillic) */
    KnownOcrSkillLanguage["KaaCyrl"] = "kaa-cyrl";
    /** Kara-Kalpak (Latin) */
    KnownOcrSkillLanguage["Kaa"] = "kaa";
    /** Kashubian */
    KnownOcrSkillLanguage["Csb"] = "csb";
    /** Kazakh (Cyrillic) */
    KnownOcrSkillLanguage["KkCyrl"] = "kk-cyrl";
    /** Kazakh (Latin) */
    KnownOcrSkillLanguage["KkLatn"] = "kk-latn";
    /** Khaling */
    KnownOcrSkillLanguage["Klr"] = "klr";
    /** Khasi */
    KnownOcrSkillLanguage["Kha"] = "kha";
    /** K'iche' */
    KnownOcrSkillLanguage["Quc"] = "quc";
    /** Korean */
    KnownOcrSkillLanguage["Ko"] = "ko";
    /** Korku */
    KnownOcrSkillLanguage["Kfq"] = "kfq";
    /** Koryak */
    KnownOcrSkillLanguage["Kpy"] = "kpy";
    /** Kosraean */
    KnownOcrSkillLanguage["Kos"] = "kos";
    /** Kumyk (Cyrillic) */
    KnownOcrSkillLanguage["Kum"] = "kum";
    /** Kurdish (Arabic) */
    KnownOcrSkillLanguage["KuArab"] = "ku-arab";
    /** Kurdish (Latin) */
    KnownOcrSkillLanguage["KuLatn"] = "ku-latn";
    /** Kurukh (Devanagiri) */
    KnownOcrSkillLanguage["Kru"] = "kru";
    /** Kyrgyz (Cyrillic) */
    KnownOcrSkillLanguage["Ky"] = "ky";
    /** Lakota */
    KnownOcrSkillLanguage["Lkt"] = "lkt";
    /** Latin */
    KnownOcrSkillLanguage["La"] = "la";
    /** Lithuanian */
    KnownOcrSkillLanguage["Lt"] = "lt";
    /** Lower Sorbian */
    KnownOcrSkillLanguage["Dsb"] = "dsb";
    /** Lule Sami */
    KnownOcrSkillLanguage["Smj"] = "smj";
    /** Luxembourgish */
    KnownOcrSkillLanguage["Lb"] = "lb";
    /** Mahasu Pahari (Devanagiri) */
    KnownOcrSkillLanguage["Bfz"] = "bfz";
    /** Malay (Latin) */
    KnownOcrSkillLanguage["Ms"] = "ms";
    /** Maltese */
    KnownOcrSkillLanguage["Mt"] = "mt";
    /** Malto (Devanagiri) */
    KnownOcrSkillLanguage["Kmj"] = "kmj";
    /** Manx */
    KnownOcrSkillLanguage["Gv"] = "gv";
    /** Maori */
    KnownOcrSkillLanguage["Mi"] = "mi";
    /** Marathi */
    KnownOcrSkillLanguage["Mr"] = "mr";
    /** Mongolian (Cyrillic) */
    KnownOcrSkillLanguage["Mn"] = "mn";
    /** Montenegrin (Cyrillic) */
    KnownOcrSkillLanguage["CnrCyrl"] = "cnr-cyrl";
    /** Montenegrin (Latin) */
    KnownOcrSkillLanguage["CnrLatn"] = "cnr-latn";
    /** Neapolitan */
    KnownOcrSkillLanguage["Nap"] = "nap";
    /** Nepali */
    KnownOcrSkillLanguage["Ne"] = "ne";
    /** Niuean */
    KnownOcrSkillLanguage["Niu"] = "niu";
    /** Nogay */
    KnownOcrSkillLanguage["Nog"] = "nog";
    /** Northern Sami (Latin) */
    KnownOcrSkillLanguage["Sme"] = "sme";
    /** Norwegian */
    KnownOcrSkillLanguage["Nb"] = "nb";
    /** Norwegian */
    KnownOcrSkillLanguage["No"] = "no";
    /** Occitan */
    KnownOcrSkillLanguage["Oc"] = "oc";
    /** Ossetic */
    KnownOcrSkillLanguage["Os"] = "os";
    /** Pashto */
    KnownOcrSkillLanguage["Ps"] = "ps";
    /** Persian */
    KnownOcrSkillLanguage["Fa"] = "fa";
    /** Polish */
    KnownOcrSkillLanguage["Pl"] = "pl";
    /** Portuguese */
    KnownOcrSkillLanguage["Pt"] = "pt";
    /** Punjabi (Arabic) */
    KnownOcrSkillLanguage["Pa"] = "pa";
    /** Ripuarian */
    KnownOcrSkillLanguage["Ksh"] = "ksh";
    /** Romanian */
    KnownOcrSkillLanguage["Ro"] = "ro";
    /** Romansh */
    KnownOcrSkillLanguage["Rm"] = "rm";
    /** Russian */
    KnownOcrSkillLanguage["Ru"] = "ru";
    /** Sadri (Devanagiri) */
    KnownOcrSkillLanguage["Sck"] = "sck";
    /** Samoan (Latin) */
    KnownOcrSkillLanguage["Sm"] = "sm";
    /** Sanskrit (Devanagiri) */
    KnownOcrSkillLanguage["Sa"] = "sa";
    /** Santali (Devanagiri) */
    KnownOcrSkillLanguage["Sat"] = "sat";
    /** Scots */
    KnownOcrSkillLanguage["Sco"] = "sco";
    /** Scottish Gaelic */
    KnownOcrSkillLanguage["Gd"] = "gd";
    /** Serbian (Latin) */
    KnownOcrSkillLanguage["Sr"] = "sr";
    /** Serbian (Cyrillic) */
    KnownOcrSkillLanguage["SrCyrl"] = "sr-Cyrl";
    /** Serbian (Latin) */
    KnownOcrSkillLanguage["SrLatn"] = "sr-Latn";
    /** Sherpa (Devanagiri) */
    KnownOcrSkillLanguage["Xsr"] = "xsr";
    /** Sirmauri (Devanagiri) */
    KnownOcrSkillLanguage["Srx"] = "srx";
    /** Skolt Sami */
    KnownOcrSkillLanguage["Sms"] = "sms";
    /** Slovak */
    KnownOcrSkillLanguage["Sk"] = "sk";
    /** Slovenian */
    KnownOcrSkillLanguage["Sl"] = "sl";
    /** Somali (Arabic) */
    KnownOcrSkillLanguage["So"] = "so";
    /** Southern Sami */
    KnownOcrSkillLanguage["Sma"] = "sma";
    /** Spanish */
    KnownOcrSkillLanguage["Es"] = "es";
    /** Swahili (Latin) */
    KnownOcrSkillLanguage["Sw"] = "sw";
    /** Swedish */
    KnownOcrSkillLanguage["Sv"] = "sv";
    /** Tajik (Cyrillic) */
    KnownOcrSkillLanguage["Tg"] = "tg";
    /** Tatar (Latin) */
    KnownOcrSkillLanguage["Tt"] = "tt";
    /** Tetum */
    KnownOcrSkillLanguage["Tet"] = "tet";
    /** Thangmi */
    KnownOcrSkillLanguage["Thf"] = "thf";
    /** Tongan */
    KnownOcrSkillLanguage["To"] = "to";
    /** Turkish */
    KnownOcrSkillLanguage["Tr"] = "tr";
    /** Turkmen (Latin) */
    KnownOcrSkillLanguage["Tk"] = "tk";
    /** Tuvan */
    KnownOcrSkillLanguage["Tyv"] = "tyv";
    /** Upper Sorbian */
    KnownOcrSkillLanguage["Hsb"] = "hsb";
    /** Urdu */
    KnownOcrSkillLanguage["Ur"] = "ur";
    /** Uyghur (Arabic) */
    KnownOcrSkillLanguage["Ug"] = "ug";
    /** Uzbek (Arabic) */
    KnownOcrSkillLanguage["UzArab"] = "uz-arab";
    /** Uzbek (Cyrillic) */
    KnownOcrSkillLanguage["UzCyrl"] = "uz-cyrl";
    /** Uzbek (Latin) */
    KnownOcrSkillLanguage["Uz"] = "uz";
    /** Volapük */
    KnownOcrSkillLanguage["Vo"] = "vo";
    /** Walser */
    KnownOcrSkillLanguage["Wae"] = "wae";
    /** Welsh */
    KnownOcrSkillLanguage["Cy"] = "cy";
    /** Western Frisian */
    KnownOcrSkillLanguage["Fy"] = "fy";
    /** Yucatec Maya */
    KnownOcrSkillLanguage["Yua"] = "yua";
    /** Zhuang */
    KnownOcrSkillLanguage["Za"] = "za";
    /** Zulu */
    KnownOcrSkillLanguage["Zu"] = "zu";
    /** Unknown (All) */
    KnownOcrSkillLanguage["Unk"] = "unk";
})(exports.KnownOcrSkillLanguage || (exports.KnownOcrSkillLanguage = {}));
/** Known values of {@link ImageAnalysisSkillLanguage} that the service accepts. */
exports.KnownImageAnalysisSkillLanguage = void 0;
(function (KnownImageAnalysisSkillLanguage) {
    /** Arabic */
    KnownImageAnalysisSkillLanguage["Ar"] = "ar";
    /** Azerbaijani */
    KnownImageAnalysisSkillLanguage["Az"] = "az";
    /** Bulgarian */
    KnownImageAnalysisSkillLanguage["Bg"] = "bg";
    /** Bosnian Latin */
    KnownImageAnalysisSkillLanguage["Bs"] = "bs";
    /** Catalan */
    KnownImageAnalysisSkillLanguage["Ca"] = "ca";
    /** Czech */
    KnownImageAnalysisSkillLanguage["Cs"] = "cs";
    /** Welsh */
    KnownImageAnalysisSkillLanguage["Cy"] = "cy";
    /** Danish */
    KnownImageAnalysisSkillLanguage["Da"] = "da";
    /** German */
    KnownImageAnalysisSkillLanguage["De"] = "de";
    /** Greek */
    KnownImageAnalysisSkillLanguage["El"] = "el";
    /** English */
    KnownImageAnalysisSkillLanguage["En"] = "en";
    /** Spanish */
    KnownImageAnalysisSkillLanguage["Es"] = "es";
    /** Estonian */
    KnownImageAnalysisSkillLanguage["Et"] = "et";
    /** Basque */
    KnownImageAnalysisSkillLanguage["Eu"] = "eu";
    /** Finnish */
    KnownImageAnalysisSkillLanguage["Fi"] = "fi";
    /** French */
    KnownImageAnalysisSkillLanguage["Fr"] = "fr";
    /** Irish */
    KnownImageAnalysisSkillLanguage["Ga"] = "ga";
    /** Galician */
    KnownImageAnalysisSkillLanguage["Gl"] = "gl";
    /** Hebrew */
    KnownImageAnalysisSkillLanguage["He"] = "he";
    /** Hindi */
    KnownImageAnalysisSkillLanguage["Hi"] = "hi";
    /** Croatian */
    KnownImageAnalysisSkillLanguage["Hr"] = "hr";
    /** Hungarian */
    KnownImageAnalysisSkillLanguage["Hu"] = "hu";
    /** Indonesian */
    KnownImageAnalysisSkillLanguage["Id"] = "id";
    /** Italian */
    KnownImageAnalysisSkillLanguage["It"] = "it";
    /** Japanese */
    KnownImageAnalysisSkillLanguage["Ja"] = "ja";
    /** Kazakh */
    KnownImageAnalysisSkillLanguage["Kk"] = "kk";
    /** Korean */
    KnownImageAnalysisSkillLanguage["Ko"] = "ko";
    /** Lithuanian */
    KnownImageAnalysisSkillLanguage["Lt"] = "lt";
    /** Latvian */
    KnownImageAnalysisSkillLanguage["Lv"] = "lv";
    /** Macedonian */
    KnownImageAnalysisSkillLanguage["Mk"] = "mk";
    /** Malay Malaysia */
    KnownImageAnalysisSkillLanguage["Ms"] = "ms";
    /** Norwegian (Bokmal) */
    KnownImageAnalysisSkillLanguage["Nb"] = "nb";
    /** Dutch */
    KnownImageAnalysisSkillLanguage["Nl"] = "nl";
    /** Polish */
    KnownImageAnalysisSkillLanguage["Pl"] = "pl";
    /** Dari */
    KnownImageAnalysisSkillLanguage["Prs"] = "prs";
    /** Portuguese-Brazil */
    KnownImageAnalysisSkillLanguage["PtBR"] = "pt-BR";
    /** Portuguese-Portugal */
    KnownImageAnalysisSkillLanguage["Pt"] = "pt";
    /** Portuguese-Portugal */
    KnownImageAnalysisSkillLanguage["PtPT"] = "pt-PT";
    /** Romanian */
    KnownImageAnalysisSkillLanguage["Ro"] = "ro";
    /** Russian */
    KnownImageAnalysisSkillLanguage["Ru"] = "ru";
    /** Slovak */
    KnownImageAnalysisSkillLanguage["Sk"] = "sk";
    /** Slovenian */
    KnownImageAnalysisSkillLanguage["Sl"] = "sl";
    /** Serbian - Cyrillic RS */
    KnownImageAnalysisSkillLanguage["SrCyrl"] = "sr-Cyrl";
    /** Serbian - Latin RS */
    KnownImageAnalysisSkillLanguage["SrLatn"] = "sr-Latn";
    /** Swedish */
    KnownImageAnalysisSkillLanguage["Sv"] = "sv";
    /** Thai */
    KnownImageAnalysisSkillLanguage["Th"] = "th";
    /** Turkish */
    KnownImageAnalysisSkillLanguage["Tr"] = "tr";
    /** Ukrainian */
    KnownImageAnalysisSkillLanguage["Uk"] = "uk";
    /** Vietnamese */
    KnownImageAnalysisSkillLanguage["Vi"] = "vi";
    /** Chinese Simplified */
    KnownImageAnalysisSkillLanguage["Zh"] = "zh";
    /** Chinese Simplified */
    KnownImageAnalysisSkillLanguage["ZhHans"] = "zh-Hans";
    /** Chinese Traditional */
    KnownImageAnalysisSkillLanguage["ZhHant"] = "zh-Hant";
})(exports.KnownImageAnalysisSkillLanguage || (exports.KnownImageAnalysisSkillLanguage = {}));
/** Known values of {@link VisualFeature} that the service accepts. */
exports.KnownVisualFeature = void 0;
(function (KnownVisualFeature) {
    /** Visual features recognized as adult persons. */
    KnownVisualFeature["Adult"] = "adult";
    /** Visual features recognized as commercial brands. */
    KnownVisualFeature["Brands"] = "brands";
    /** Categories. */
    KnownVisualFeature["Categories"] = "categories";
    /** Description. */
    KnownVisualFeature["Description"] = "description";
    /** Visual features recognized as people faces. */
    KnownVisualFeature["Faces"] = "faces";
    /** Visual features recognized as objects. */
    KnownVisualFeature["Objects"] = "objects";
    /** Tags. */
    KnownVisualFeature["Tags"] = "tags";
})(exports.KnownVisualFeature || (exports.KnownVisualFeature = {}));
/** Known values of {@link ImageDetail} that the service accepts. */
exports.KnownImageDetail = void 0;
(function (KnownImageDetail) {
    /** Details recognized as celebrities. */
    KnownImageDetail["Celebrities"] = "celebrities";
    /** Details recognized as landmarks. */
    KnownImageDetail["Landmarks"] = "landmarks";
})(exports.KnownImageDetail || (exports.KnownImageDetail = {}));
/** Known values of {@link EntityCategory} that the service accepts. */
exports.KnownEntityCategory = void 0;
(function (KnownEntityCategory) {
    /** Entities describing a physical location. */
    KnownEntityCategory["Location"] = "location";
    /** Entities describing an organization. */
    KnownEntityCategory["Organization"] = "organization";
    /** Entities describing a person. */
    KnownEntityCategory["Person"] = "person";
    /** Entities describing a quantity. */
    KnownEntityCategory["Quantity"] = "quantity";
    /** Entities describing a date and time. */
    KnownEntityCategory["Datetime"] = "datetime";
    /** Entities describing a URL. */
    KnownEntityCategory["Url"] = "url";
    /** Entities describing an email address. */
    KnownEntityCategory["Email"] = "email";
})(exports.KnownEntityCategory || (exports.KnownEntityCategory = {}));
/** Known values of {@link EntityRecognitionSkillLanguage} that the service accepts. */
exports.KnownEntityRecognitionSkillLanguage = void 0;
(function (KnownEntityRecognitionSkillLanguage) {
    /** Arabic */
    KnownEntityRecognitionSkillLanguage["Ar"] = "ar";
    /** Czech */
    KnownEntityRecognitionSkillLanguage["Cs"] = "cs";
    /** Chinese-Simplified */
    KnownEntityRecognitionSkillLanguage["ZhHans"] = "zh-Hans";
    /** Chinese-Traditional */
    KnownEntityRecognitionSkillLanguage["ZhHant"] = "zh-Hant";
    /** Danish */
    KnownEntityRecognitionSkillLanguage["Da"] = "da";
    /** Dutch */
    KnownEntityRecognitionSkillLanguage["Nl"] = "nl";
    /** English */
    KnownEntityRecognitionSkillLanguage["En"] = "en";
    /** Finnish */
    KnownEntityRecognitionSkillLanguage["Fi"] = "fi";
    /** French */
    KnownEntityRecognitionSkillLanguage["Fr"] = "fr";
    /** German */
    KnownEntityRecognitionSkillLanguage["De"] = "de";
    /** Greek */
    KnownEntityRecognitionSkillLanguage["El"] = "el";
    /** Hungarian */
    KnownEntityRecognitionSkillLanguage["Hu"] = "hu";
    /** Italian */
    KnownEntityRecognitionSkillLanguage["It"] = "it";
    /** Japanese */
    KnownEntityRecognitionSkillLanguage["Ja"] = "ja";
    /** Korean */
    KnownEntityRecognitionSkillLanguage["Ko"] = "ko";
    /** Norwegian (Bokmaal) */
    KnownEntityRecognitionSkillLanguage["No"] = "no";
    /** Polish */
    KnownEntityRecognitionSkillLanguage["Pl"] = "pl";
    /** Portuguese (Portugal) */
    KnownEntityRecognitionSkillLanguage["PtPT"] = "pt-PT";
    /** Portuguese (Brazil) */
    KnownEntityRecognitionSkillLanguage["PtBR"] = "pt-BR";
    /** Russian */
    KnownEntityRecognitionSkillLanguage["Ru"] = "ru";
    /** Spanish */
    KnownEntityRecognitionSkillLanguage["Es"] = "es";
    /** Swedish */
    KnownEntityRecognitionSkillLanguage["Sv"] = "sv";
    /** Turkish */
    KnownEntityRecognitionSkillLanguage["Tr"] = "tr";
})(exports.KnownEntityRecognitionSkillLanguage || (exports.KnownEntityRecognitionSkillLanguage = {}));
/** Known values of {@link SentimentSkillLanguage} that the service accepts. */
exports.KnownSentimentSkillLanguage = void 0;
(function (KnownSentimentSkillLanguage) {
    /** Danish */
    KnownSentimentSkillLanguage["Da"] = "da";
    /** Dutch */
    KnownSentimentSkillLanguage["Nl"] = "nl";
    /** English */
    KnownSentimentSkillLanguage["En"] = "en";
    /** Finnish */
    KnownSentimentSkillLanguage["Fi"] = "fi";
    /** French */
    KnownSentimentSkillLanguage["Fr"] = "fr";
    /** German */
    KnownSentimentSkillLanguage["De"] = "de";
    /** Greek */
    KnownSentimentSkillLanguage["El"] = "el";
    /** Italian */
    KnownSentimentSkillLanguage["It"] = "it";
    /** Norwegian (Bokmaal) */
    KnownSentimentSkillLanguage["No"] = "no";
    /** Polish */
    KnownSentimentSkillLanguage["Pl"] = "pl";
    /** Portuguese (Portugal) */
    KnownSentimentSkillLanguage["PtPT"] = "pt-PT";
    /** Russian */
    KnownSentimentSkillLanguage["Ru"] = "ru";
    /** Spanish */
    KnownSentimentSkillLanguage["Es"] = "es";
    /** Swedish */
    KnownSentimentSkillLanguage["Sv"] = "sv";
    /** Turkish */
    KnownSentimentSkillLanguage["Tr"] = "tr";
})(exports.KnownSentimentSkillLanguage || (exports.KnownSentimentSkillLanguage = {}));
/** Known values of {@link PIIDetectionSkillMaskingMode} that the service accepts. */
var KnownPIIDetectionSkillMaskingMode;
(function (KnownPIIDetectionSkillMaskingMode) {
    /** No masking occurs and the maskedText output will not be returned. */
    KnownPIIDetectionSkillMaskingMode["None"] = "none";
    /** Replaces the detected entities with the character given in the maskingCharacter parameter. The character will be repeated to the length of the detected entity so that the offsets will correctly correspond to both the input text as well as the output maskedText. */
    KnownPIIDetectionSkillMaskingMode["Replace"] = "replace";
})(KnownPIIDetectionSkillMaskingMode || (KnownPIIDetectionSkillMaskingMode = {}));
/** Known values of {@link SplitSkillLanguage} that the service accepts. */
exports.KnownSplitSkillLanguage = void 0;
(function (KnownSplitSkillLanguage) {
    /** Amharic */
    KnownSplitSkillLanguage["Am"] = "am";
    /** Bosnian */
    KnownSplitSkillLanguage["Bs"] = "bs";
    /** Czech */
    KnownSplitSkillLanguage["Cs"] = "cs";
    /** Danish */
    KnownSplitSkillLanguage["Da"] = "da";
    /** German */
    KnownSplitSkillLanguage["De"] = "de";
    /** English */
    KnownSplitSkillLanguage["En"] = "en";
    /** Spanish */
    KnownSplitSkillLanguage["Es"] = "es";
    /** Estonian */
    KnownSplitSkillLanguage["Et"] = "et";
    /** Finnish */
    KnownSplitSkillLanguage["Fi"] = "fi";
    /** French */
    KnownSplitSkillLanguage["Fr"] = "fr";
    /** Hebrew */
    KnownSplitSkillLanguage["He"] = "he";
    /** Hindi */
    KnownSplitSkillLanguage["Hi"] = "hi";
    /** Croatian */
    KnownSplitSkillLanguage["Hr"] = "hr";
    /** Hungarian */
    KnownSplitSkillLanguage["Hu"] = "hu";
    /** Indonesian */
    KnownSplitSkillLanguage["Id"] = "id";
    /** Icelandic */
    KnownSplitSkillLanguage["Is"] = "is";
    /** Italian */
    KnownSplitSkillLanguage["It"] = "it";
    /** Japanese */
    KnownSplitSkillLanguage["Ja"] = "ja";
    /** Korean */
    KnownSplitSkillLanguage["Ko"] = "ko";
    /** Latvian */
    KnownSplitSkillLanguage["Lv"] = "lv";
    /** Norwegian */
    KnownSplitSkillLanguage["Nb"] = "nb";
    /** Dutch */
    KnownSplitSkillLanguage["Nl"] = "nl";
    /** Polish */
    KnownSplitSkillLanguage["Pl"] = "pl";
    /** Portuguese (Portugal) */
    KnownSplitSkillLanguage["Pt"] = "pt";
    /** Portuguese (Brazil) */
    KnownSplitSkillLanguage["PtBr"] = "pt-br";
    /** Russian */
    KnownSplitSkillLanguage["Ru"] = "ru";
    /** Slovak */
    KnownSplitSkillLanguage["Sk"] = "sk";
    /** Slovenian */
    KnownSplitSkillLanguage["Sl"] = "sl";
    /** Serbian */
    KnownSplitSkillLanguage["Sr"] = "sr";
    /** Swedish */
    KnownSplitSkillLanguage["Sv"] = "sv";
    /** Turkish */
    KnownSplitSkillLanguage["Tr"] = "tr";
    /** Urdu */
    KnownSplitSkillLanguage["Ur"] = "ur";
    /** Chinese (Simplified) */
    KnownSplitSkillLanguage["Zh"] = "zh";
})(exports.KnownSplitSkillLanguage || (exports.KnownSplitSkillLanguage = {}));
/** Known values of {@link TextSplitMode} that the service accepts. */
exports.KnownTextSplitMode = void 0;
(function (KnownTextSplitMode) {
    /** Split the text into individual pages. */
    KnownTextSplitMode["Pages"] = "pages";
    /** Split the text into individual sentences. */
    KnownTextSplitMode["Sentences"] = "sentences";
})(exports.KnownTextSplitMode || (exports.KnownTextSplitMode = {}));
/** Known values of {@link CustomEntityLookupSkillLanguage} that the service accepts. */
exports.KnownCustomEntityLookupSkillLanguage = void 0;
(function (KnownCustomEntityLookupSkillLanguage) {
    /** Danish */
    KnownCustomEntityLookupSkillLanguage["Da"] = "da";
    /** German */
    KnownCustomEntityLookupSkillLanguage["De"] = "de";
    /** English */
    KnownCustomEntityLookupSkillLanguage["En"] = "en";
    /** Spanish */
    KnownCustomEntityLookupSkillLanguage["Es"] = "es";
    /** Finnish */
    KnownCustomEntityLookupSkillLanguage["Fi"] = "fi";
    /** French */
    KnownCustomEntityLookupSkillLanguage["Fr"] = "fr";
    /** Italian */
    KnownCustomEntityLookupSkillLanguage["It"] = "it";
    /** Korean */
    KnownCustomEntityLookupSkillLanguage["Ko"] = "ko";
    /** Portuguese */
    KnownCustomEntityLookupSkillLanguage["Pt"] = "pt";
})(exports.KnownCustomEntityLookupSkillLanguage || (exports.KnownCustomEntityLookupSkillLanguage = {}));
/** Known values of {@link TextTranslationSkillLanguage} that the service accepts. */
exports.KnownTextTranslationSkillLanguage = void 0;
(function (KnownTextTranslationSkillLanguage) {
    /** Afrikaans */
    KnownTextTranslationSkillLanguage["Af"] = "af";
    /** Arabic */
    KnownTextTranslationSkillLanguage["Ar"] = "ar";
    /** Bangla */
    KnownTextTranslationSkillLanguage["Bn"] = "bn";
    /** Bosnian (Latin) */
    KnownTextTranslationSkillLanguage["Bs"] = "bs";
    /** Bulgarian */
    KnownTextTranslationSkillLanguage["Bg"] = "bg";
    /** Cantonese (Traditional) */
    KnownTextTranslationSkillLanguage["Yue"] = "yue";
    /** Catalan */
    KnownTextTranslationSkillLanguage["Ca"] = "ca";
    /** Chinese Simplified */
    KnownTextTranslationSkillLanguage["ZhHans"] = "zh-Hans";
    /** Chinese Traditional */
    KnownTextTranslationSkillLanguage["ZhHant"] = "zh-Hant";
    /** Croatian */
    KnownTextTranslationSkillLanguage["Hr"] = "hr";
    /** Czech */
    KnownTextTranslationSkillLanguage["Cs"] = "cs";
    /** Danish */
    KnownTextTranslationSkillLanguage["Da"] = "da";
    /** Dutch */
    KnownTextTranslationSkillLanguage["Nl"] = "nl";
    /** English */
    KnownTextTranslationSkillLanguage["En"] = "en";
    /** Estonian */
    KnownTextTranslationSkillLanguage["Et"] = "et";
    /** Fijian */
    KnownTextTranslationSkillLanguage["Fj"] = "fj";
    /** Filipino */
    KnownTextTranslationSkillLanguage["Fil"] = "fil";
    /** Finnish */
    KnownTextTranslationSkillLanguage["Fi"] = "fi";
    /** French */
    KnownTextTranslationSkillLanguage["Fr"] = "fr";
    /** German */
    KnownTextTranslationSkillLanguage["De"] = "de";
    /** Greek */
    KnownTextTranslationSkillLanguage["El"] = "el";
    /** Haitian Creole */
    KnownTextTranslationSkillLanguage["Ht"] = "ht";
    /** Hebrew */
    KnownTextTranslationSkillLanguage["He"] = "he";
    /** Hindi */
    KnownTextTranslationSkillLanguage["Hi"] = "hi";
    /** Hmong Daw */
    KnownTextTranslationSkillLanguage["Mww"] = "mww";
    /** Hungarian */
    KnownTextTranslationSkillLanguage["Hu"] = "hu";
    /** Icelandic */
    KnownTextTranslationSkillLanguage["Is"] = "is";
    /** Indonesian */
    KnownTextTranslationSkillLanguage["Id"] = "id";
    /** Italian */
    KnownTextTranslationSkillLanguage["It"] = "it";
    /** Japanese */
    KnownTextTranslationSkillLanguage["Ja"] = "ja";
    /** Kiswahili */
    KnownTextTranslationSkillLanguage["Sw"] = "sw";
    /** Klingon */
    KnownTextTranslationSkillLanguage["Tlh"] = "tlh";
    /** Korean */
    KnownTextTranslationSkillLanguage["Ko"] = "ko";
    /** Latvian */
    KnownTextTranslationSkillLanguage["Lv"] = "lv";
    /** Lithuanian */
    KnownTextTranslationSkillLanguage["Lt"] = "lt";
    /** Malagasy */
    KnownTextTranslationSkillLanguage["Mg"] = "mg";
    /** Malay */
    KnownTextTranslationSkillLanguage["Ms"] = "ms";
    /** Maltese */
    KnownTextTranslationSkillLanguage["Mt"] = "mt";
    /** Norwegian */
    KnownTextTranslationSkillLanguage["Nb"] = "nb";
    /** Persian */
    KnownTextTranslationSkillLanguage["Fa"] = "fa";
    /** Polish */
    KnownTextTranslationSkillLanguage["Pl"] = "pl";
    /** Portuguese */
    KnownTextTranslationSkillLanguage["Pt"] = "pt";
    /** Queretaro Otomi */
    KnownTextTranslationSkillLanguage["Otq"] = "otq";
    /** Romanian */
    KnownTextTranslationSkillLanguage["Ro"] = "ro";
    /** Russian */
    KnownTextTranslationSkillLanguage["Ru"] = "ru";
    /** Samoan */
    KnownTextTranslationSkillLanguage["Sm"] = "sm";
    /** Serbian (Cyrillic) */
    KnownTextTranslationSkillLanguage["SrCyrl"] = "sr-Cyrl";
    /** Serbian (Latin) */
    KnownTextTranslationSkillLanguage["SrLatn"] = "sr-Latn";
    /** Slovak */
    KnownTextTranslationSkillLanguage["Sk"] = "sk";
    /** Slovenian */
    KnownTextTranslationSkillLanguage["Sl"] = "sl";
    /** Spanish */
    KnownTextTranslationSkillLanguage["Es"] = "es";
    /** Swedish */
    KnownTextTranslationSkillLanguage["Sv"] = "sv";
    /** Tahitian */
    KnownTextTranslationSkillLanguage["Ty"] = "ty";
    /** Tamil */
    KnownTextTranslationSkillLanguage["Ta"] = "ta";
    /** Telugu */
    KnownTextTranslationSkillLanguage["Te"] = "te";
    /** Thai */
    KnownTextTranslationSkillLanguage["Th"] = "th";
    /** Tongan */
    KnownTextTranslationSkillLanguage["To"] = "to";
    /** Turkish */
    KnownTextTranslationSkillLanguage["Tr"] = "tr";
    /** Ukrainian */
    KnownTextTranslationSkillLanguage["Uk"] = "uk";
    /** Urdu */
    KnownTextTranslationSkillLanguage["Ur"] = "ur";
    /** Vietnamese */
    KnownTextTranslationSkillLanguage["Vi"] = "vi";
    /** Welsh */
    KnownTextTranslationSkillLanguage["Cy"] = "cy";
    /** Yucatec Maya */
    KnownTextTranslationSkillLanguage["Yua"] = "yua";
})(exports.KnownTextTranslationSkillLanguage || (exports.KnownTextTranslationSkillLanguage = {}));
/** Known values of {@link LexicalTokenizerName} that the service accepts. */
exports.KnownTokenizerNames = void 0;
(function (KnownLexicalTokenizerName) {
    /** Grammar-based tokenizer that is suitable for processing most European-language documents. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/standard\/ClassicTokenizer.html */
    KnownLexicalTokenizerName["Classic"] = "classic";
    /** Tokenizes the input from an edge into n-grams of the given size(s). See https:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/ngram\/EdgeNGramTokenizer.html */
    KnownLexicalTokenizerName["EdgeNGram"] = "edgeNGram";
    /** Emits the entire input as a single token. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/KeywordTokenizer.html */
    KnownLexicalTokenizerName["Keyword"] = "keyword_v2";
    /** Divides text at non-letters. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/LetterTokenizer.html */
    KnownLexicalTokenizerName["Letter"] = "letter";
    /** Divides text at non-letters and converts them to lower case. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/LowerCaseTokenizer.html */
    KnownLexicalTokenizerName["Lowercase"] = "lowercase";
    /** Divides text using language-specific rules. */
    KnownLexicalTokenizerName["MicrosoftLanguageTokenizer"] = "microsoft_language_tokenizer";
    /** Divides text using language-specific rules and reduces words to their base forms. */
    KnownLexicalTokenizerName["MicrosoftLanguageStemmingTokenizer"] = "microsoft_language_stemming_tokenizer";
    /** Tokenizes the input into n-grams of the given size(s). See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/ngram\/NGramTokenizer.html */
    KnownLexicalTokenizerName["NGram"] = "nGram";
    /** Tokenizer for path-like hierarchies. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/path\/PathHierarchyTokenizer.html */
    KnownLexicalTokenizerName["PathHierarchy"] = "path_hierarchy_v2";
    /** Tokenizer that uses regex pattern matching to construct distinct tokens. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/pattern\/PatternTokenizer.html */
    KnownLexicalTokenizerName["Pattern"] = "pattern";
    /** Standard Lucene analyzer; Composed of the standard tokenizer, lowercase filter and stop filter. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/standard\/StandardTokenizer.html */
    KnownLexicalTokenizerName["Standard"] = "standard_v2";
    /** Tokenizes urls and emails as one token. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/standard\/UAX29URLEmailTokenizer.html */
    KnownLexicalTokenizerName["UaxUrlEmail"] = "uax_url_email";
    /** Divides text at whitespace. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/WhitespaceTokenizer.html */
    KnownLexicalTokenizerName["Whitespace"] = "whitespace";
})(exports.KnownTokenizerNames || (exports.KnownTokenizerNames = {}));
/** Known values of {@link TokenFilterName} that the service accepts. */
exports.KnownTokenFilterNames = void 0;
(function (KnownTokenFilterName) {
    /** A token filter that applies the Arabic normalizer to normalize the orthography. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/ar\/ArabicNormalizationFilter.html */
    KnownTokenFilterName["ArabicNormalization"] = "arabic_normalization";
    /** Strips all characters after an apostrophe (including the apostrophe itself). See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/tr\/ApostropheFilter.html */
    KnownTokenFilterName["Apostrophe"] = "apostrophe";
    /** Converts alphabetic, numeric, and symbolic Unicode characters which are not in the first 127 ASCII characters (the "Basic Latin" Unicode block) into their ASCII equivalents, if such equivalents exist. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/ASCIIFoldingFilter.html */
    KnownTokenFilterName["AsciiFolding"] = "asciifolding";
    /** Forms bigrams of CJK terms that are generated from the standard tokenizer. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/cjk\/CJKBigramFilter.html */
    KnownTokenFilterName["CjkBigram"] = "cjk_bigram";
    /** Normalizes CJK width differences. Folds fullwidth ASCII variants into the equivalent basic Latin, and half-width Katakana variants into the equivalent Kana. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/cjk\/CJKWidthFilter.html */
    KnownTokenFilterName["CjkWidth"] = "cjk_width";
    /** Removes English possessives, and dots from acronyms. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/standard\/ClassicFilter.html */
    KnownTokenFilterName["Classic"] = "classic";
    /** Construct bigrams for frequently occurring terms while indexing. Single terms are still indexed too, with bigrams overlaid. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/commongrams\/CommonGramsFilter.html */
    KnownTokenFilterName["CommonGram"] = "common_grams";
    /** Generates n-grams of the given size(s) starting from the front or the back of an input token. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/ngram\/EdgeNGramTokenFilter.html */
    KnownTokenFilterName["EdgeNGram"] = "edgeNGram_v2";
    /** Removes elisions. For example, "l'avion" (the plane) will be converted to "avion" (plane). See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/util\/ElisionFilter.html */
    KnownTokenFilterName["Elision"] = "elision";
    /** Normalizes German characters according to the heuristics of the German2 snowball algorithm. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/de\/GermanNormalizationFilter.html */
    KnownTokenFilterName["GermanNormalization"] = "german_normalization";
    /** Normalizes text in Hindi to remove some differences in spelling variations. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/hi\/HindiNormalizationFilter.html */
    KnownTokenFilterName["HindiNormalization"] = "hindi_normalization";
    /** Normalizes the Unicode representation of text in Indian languages. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/in\/IndicNormalizationFilter.html */
    KnownTokenFilterName["IndicNormalization"] = "indic_normalization";
    /** Emits each incoming token twice, once as keyword and once as non-keyword. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/KeywordRepeatFilter.html */
    KnownTokenFilterName["KeywordRepeat"] = "keyword_repeat";
    /** A high-performance kstem filter for English. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/en\/KStemFilter.html */
    KnownTokenFilterName["KStem"] = "kstem";
    /** Removes words that are too long or too short. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/LengthFilter.html */
    KnownTokenFilterName["Length"] = "length";
    /** Limits the number of tokens while indexing. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/LimitTokenCountFilter.html */
    KnownTokenFilterName["Limit"] = "limit";
    /** Normalizes token text to lower case. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/LowerCaseFilter.htm */
    KnownTokenFilterName["Lowercase"] = "lowercase";
    /** Generates n-grams of the given size(s). See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/ngram\/NGramTokenFilter.html */
    KnownTokenFilterName["NGram"] = "nGram_v2";
    /** Applies normalization for Persian. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/fa\/PersianNormalizationFilter.html */
    KnownTokenFilterName["PersianNormalization"] = "persian_normalization";
    /** Create tokens for phonetic matches. See https:\//lucene.apache.org\/core\/4_10_3\/analyzers-phonetic\/org\/apache\/lucene\/analysis\/phonetic\/package-tree.html */
    KnownTokenFilterName["Phonetic"] = "phonetic";
    /** Uses the Porter stemming algorithm to transform the token stream. See http:\//tartarus.org\/~martin\/PorterStemmer */
    KnownTokenFilterName["PorterStem"] = "porter_stem";
    /** Reverses the token string. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/reverse\/ReverseStringFilter.html */
    KnownTokenFilterName["Reverse"] = "reverse";
    /** Normalizes use of the interchangeable Scandinavian characters. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/ScandinavianNormalizationFilter.html */
    KnownTokenFilterName["ScandinavianNormalization"] = "scandinavian_normalization";
    /** Folds Scandinavian characters åÅäæÄÆ-&gt;a and öÖøØ-&gt;o. It also discriminates against use of double vowels aa, ae, ao, oe and oo, leaving just the first one. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/ScandinavianFoldingFilter.html */
    KnownTokenFilterName["ScandinavianFoldingNormalization"] = "scandinavian_folding";
    /** Creates combinations of tokens as a single token. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/shingle\/ShingleFilter.html */
    KnownTokenFilterName["Shingle"] = "shingle";
    /** A filter that stems words using a Snowball-generated stemmer. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/snowball\/SnowballFilter.html */
    KnownTokenFilterName["Snowball"] = "snowball";
    /** Normalizes the Unicode representation of Sorani text. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/ckb\/SoraniNormalizationFilter.html */
    KnownTokenFilterName["SoraniNormalization"] = "sorani_normalization";
    /** Language specific stemming filter. See https:\//docs.microsoft.com\/rest\/api\/searchservice\/Custom-analyzers-in-Azure-Search#TokenFilters */
    KnownTokenFilterName["Stemmer"] = "stemmer";
    /** Removes stop words from a token stream. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/StopFilter.html */
    KnownTokenFilterName["Stopwords"] = "stopwords";
    /** Trims leading and trailing whitespace from tokens. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/TrimFilter.html */
    KnownTokenFilterName["Trim"] = "trim";
    /** Truncates the terms to a specific length. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/TruncateTokenFilter.html */
    KnownTokenFilterName["Truncate"] = "truncate";
    /** Filters out tokens with same text as the previous token. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/RemoveDuplicatesTokenFilter.html */
    KnownTokenFilterName["Unique"] = "unique";
    /** Normalizes token text to upper case. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/UpperCaseFilter.html */
    KnownTokenFilterName["Uppercase"] = "uppercase";
    /** Splits words into subwords and performs optional transformations on subword groups. */
    KnownTokenFilterName["WordDelimiter"] = "word_delimiter";
})(exports.KnownTokenFilterNames || (exports.KnownTokenFilterNames = {}));
/** Known values of {@link CharFilterName} that the service accepts. */
exports.KnownCharFilterNames = void 0;
(function (KnownCharFilterName) {
    /** A character filter that attempts to strip out HTML constructs. See https:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/charfilter\/HTMLStripCharFilter.html */
    KnownCharFilterName["HtmlStrip"] = "html_strip";
})(exports.KnownCharFilterNames || (exports.KnownCharFilterNames = {}));
/** Known values of {@link RegexFlags} that the service accepts. */
exports.KnownRegexFlags = void 0;
(function (KnownRegexFlags) {
    /** Enables canonical equivalence. */
    KnownRegexFlags["CanonEq"] = "CANON_EQ";
    /** Enables case-insensitive matching. */
    KnownRegexFlags["CaseInsensitive"] = "CASE_INSENSITIVE";
    /** Permits whitespace and comments in the pattern. */
    KnownRegexFlags["Comments"] = "COMMENTS";
    /** Enables dotall mode. */
    KnownRegexFlags["DotAll"] = "DOTALL";
    /** Enables literal parsing of the pattern. */
    KnownRegexFlags["Literal"] = "LITERAL";
    /** Enables multiline mode. */
    KnownRegexFlags["Multiline"] = "MULTILINE";
    /** Enables Unicode-aware case folding. */
    KnownRegexFlags["UnicodeCase"] = "UNICODE_CASE";
    /** Enables Unix lines mode. */
    KnownRegexFlags["UnixLines"] = "UNIX_LINES";
})(exports.KnownRegexFlags || (exports.KnownRegexFlags = {}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const readFileAsync = util.promisify(fs__namespace.readFile);
/**
 * Helper method to create a SynonymMap object. This is a NodeJS only method.
 *
 * @param name - Name of the SynonymMap.
 * @param filePath - Path of the file that contains the Synonyms (seperated by new lines)
 * @returns SynonymMap object
 */
async function createSynonymMapFromFile(name, filePath) {
    const synonyms = (await readFileAsync(filePath, "utf-8"))
        .replace(/\r/g, "")
        .split("\n")
        .map((line) => line.trim())
        .filter(Boolean);
    return {
        name,
        synonyms,
    };
}

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () { return coreAuth.AzureKeyCredential; }
});
exports.DEFAULT_BATCH_SIZE = DEFAULT_BATCH_SIZE;
exports.DEFAULT_FLUSH_WINDOW = DEFAULT_FLUSH_WINDOW;
exports.DEFAULT_RETRY_COUNT = DEFAULT_RETRY_COUNT;
exports.GeographyPoint = GeographyPoint;
exports.IndexDocumentsBatch = IndexDocumentsBatch;
exports.SearchClient = SearchClient;
exports.SearchIndexClient = SearchIndexClient;
exports.SearchIndexerClient = SearchIndexerClient;
exports.SearchIndexingBufferedSender = SearchIndexingBufferedSender;
exports.createSynonymMapFromFile = createSynonymMapFromFile;
exports.odata = odata;
//# sourceMappingURL=index.js.map
