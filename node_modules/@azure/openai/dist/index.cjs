'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreAuth = require('@azure/core-auth');
var tslib = require('tslib');
var coreClient = require('@azure-rest/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
require('@azure/core-util');
var coreSse = require('@azure/core-sse');
var logger$1 = require('@azure/logger');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * THIS IS AN AUTO-GENERATED FILE - DO NOT EDIT!
 *
 * Any changes you make here may be lost.
 *
 * If you need to make changes, please do so in the original source file, \{project-root\}/sources/custom
 */
const logger = logger$1.createClientLogger("openai");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * THIS IS AN AUTO-GENERATED FILE - DO NOT EDIT!
 *
 * Any changes you make here may be lost.
 *
 * If you need to make changes, please do so in the original source file, \{project-root\}/sources/custom
 */
/**
 * Initialize a new instance of `OpenAIContext`
 * @param endpoint - Supported Cognitive Services endpoints (protocol and hostname, for example:
 * https://westus.api.cognitive.microsoft.com).
 * @param credentials - uniquely identify client credential
 * @param options - the parameter for all optional parameters
 */
function createClient(endpoint, credentials, options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const baseUrl = (_a = options.baseUrl) !== null && _a !== void 0 ? _a : `${endpoint}/openai`;
    options.apiVersion = (_b = options.apiVersion) !== null && _b !== void 0 ? _b : "2023-12-01-preview";
    const userAgentInfo = `azsdk-js-openai-rest/1.0.0-beta.11`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
        ? `${options.userAgentOptions.userAgentPrefix} ${userAgentInfo}`
        : `${userAgentInfo}`;
    options = Object.assign(Object.assign({}, options), { userAgentOptions: {
            userAgentPrefix,
        }, loggingOptions: {
            logger: (_d = (_c = options.loggingOptions) === null || _c === void 0 ? void 0 : _c.logger) !== null && _d !== void 0 ? _d : logger.info,
        }, credentials: {
            scopes: (_f = (_e = options.credentials) === null || _e === void 0 ? void 0 : _e.scopes) !== null && _f !== void 0 ? _f : ["https://cognitiveservices.azure.com/.default"],
            apiKeyHeaderName: (_h = (_g = options.credentials) === null || _g === void 0 ? void 0 : _g.apiKeyHeaderName) !== null && _h !== void 0 ? _h : "api-key",
        } });
    const client = coreClient.getClient(baseUrl, credentials, options);
    return client;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const responseMap = {
    "POST /deployments/{deploymentId}/audio/transcriptions": ["200"],
    "POST /deployments/{deploymentId}/audio/translations": ["200"],
    "POST /deployments/{deploymentId}/completions": ["200"],
    "POST /deployments/{deploymentId}/chat/completions": ["200"],
    "POST /deployments/{deploymentId}/extensions/chat/completions": ["200"],
    "POST /deployments/{deploymentId}/images/generations": ["200"],
    "POST /deployments/{deploymentId}/embeddings": ["200"],
    "GET /operations/images/{operationId}": ["200"],
    "POST /images/generations:submit": ["202"],
    "GET /images/generations:submit": ["200", "202"],
};
function isUnexpected(response) {
    const lroOriginal = response.headers["x-ms-original-url"];
    const url = new URL(lroOriginal !== null && lroOriginal !== void 0 ? lroOriginal : response.request.url);
    const method = response.request.method;
    let pathDetails = responseMap[`${method} ${url.pathname}`];
    if (!pathDetails) {
        pathDetails = getParametrizedPathSuccess(method, url.pathname);
    }
    return !pathDetails.includes(response.status);
}
function getParametrizedPathSuccess(method, path) {
    var _a, _b, _c, _d;
    const pathParts = path.split("/");
    // Traverse list to match the longest candidate
    // matchedLen: the length of candidate path
    // matchedValue: the matched status code array
    let matchedLen = -1, matchedValue = [];
    // Iterate the responseMap to find a match
    for (const [key, value] of Object.entries(responseMap)) {
        // Extracting the path from the map key which is in format
        // GET /path/foo
        if (!key.startsWith(method)) {
            continue;
        }
        const candidatePath = getPathFromMapKey(key);
        // Get each part of the url path
        const candidateParts = candidatePath.split("/");
        // track if we have found a match to return the values found.
        let found = true;
        for (let i = candidateParts.length - 1, j = pathParts.length - 1; i >= 1 && j >= 1; i--, j--) {
            if (((_a = candidateParts[i]) === null || _a === void 0 ? void 0 : _a.startsWith("{")) && ((_b = candidateParts[i]) === null || _b === void 0 ? void 0 : _b.indexOf("}")) !== -1) {
                const start = candidateParts[i].indexOf("}") + 1, end = (_c = candidateParts[i]) === null || _c === void 0 ? void 0 : _c.length;
                // If the current part of the candidate is a "template" part
                // Try to use the suffix of pattern to match the path
                // {guid} ==> $
                // {guid}:export ==> :export$
                const isMatched = new RegExp(`${(_d = candidateParts[i]) === null || _d === void 0 ? void 0 : _d.slice(start, end)}`).test(pathParts[j] || "");
                if (!isMatched) {
                    found = false;
                    break;
                }
                continue;
            }
            // If the candidate part is not a template and
            // the parts don't match mark the candidate as not found
            // to move on with the next candidate path.
            if (candidateParts[i] !== pathParts[j]) {
                found = false;
                break;
            }
        }
        // We finished evaluating the current candidate parts
        // Update the matched value if and only if we found the longer pattern
        if (found && candidatePath.length > matchedLen) {
            matchedLen = candidatePath.length;
            matchedValue = value;
        }
    }
    return matchedValue;
}
function getPathFromMapKey(mapKey) {
    const pathStart = mapKey.indexOf("/");
    return mapKey.slice(pathStart);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function createOpenAI(endpoint, credential, options = {}) {
    const clientContext = createClient(endpoint, credential, options);
    return clientContext;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function wrapError(f, message) {
    try {
        const result = f();
        return result;
    }
    catch (cause) {
        throw new Error(`${message}: ${cause}`, { cause });
    }
}
function camelCaseKeys(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    if (Array.isArray(obj)) {
        return obj.map((v) => camelCaseKeys(v));
    }
    else {
        for (const key of Object.keys(obj)) {
            const value = obj[key];
            const newKey = tocamelCase(key);
            if (newKey !== key) {
                delete obj[key];
            }
            obj[newKey] =
                typeof obj[newKey] === "object" ? camelCaseKeys(value) : value;
        }
        return obj;
    }
}
function snakeCaseKeys(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    if (Array.isArray(obj)) {
        return obj.map((v) => snakeCaseKeys(v));
    }
    else {
        for (const key of Object.keys(obj)) {
            const value = obj[key];
            const newKey = toSnakeCase(key);
            if (newKey !== key) {
                delete obj[key];
            }
            obj[newKey] =
                typeof obj[newKey] === "object" ? snakeCaseKeys(value) : value;
        }
        return obj;
    }
}
function tocamelCase(str) {
    return str
        .toLowerCase()
        .replace(/([_][a-z])/g, (group) => group.toUpperCase().replace("_", ""));
}
function toSnakeCase(str) {
    return str
        .replace(/([A-Z])/g, (group) => `_${group.toLowerCase()}`)
        .replace(/^_/, "");
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
async function getStream(response) {
    const { body, status } = await response.asNodeStream();
    if (status !== "200" && body !== undefined) {
        const text = await streamToText(body);
        throw wrapError(() => JSON.parse(text).error, "Error parsing response body");
    }
    if (!body)
        throw new Error("No stream found in response. Did you enable the stream option?");
    return body;
}
function streamToText(stream) {
    return new Promise((resolve, reject) => {
        const buffer = [];
        stream.on("data", (chunk) => {
            if (Buffer.isBuffer(chunk)) {
                buffer.push(chunk);
            }
            else {
                buffer.push(Buffer.from(chunk));
            }
        });
        stream.on("end", () => {
            resolve(Buffer.concat(buffer).toString("utf8"));
        });
        stream.on("error", (e) => {
            if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
                reject(e);
            }
            else {
                reject(new coreRestPipeline.RestError(`Error reading response as text: ${e.message}`, {
                    code: coreRestPipeline.RestError.PARSE_ERROR,
                }));
            }
        });
    });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * THIS IS AN AUTO-GENERATED FILE - DO NOT EDIT!
 *
 * Any changes you make here may be lost.
 *
 * If you need to make changes, please do so in the original source file, \{project-root\}/sources/custom
 */
function polyfillStream(stream) {
    makeAsyncIterable(stream);
    return stream;
}
function makeAsyncIterable(webStream) {
    if (!webStream[Symbol.asyncIterator]) {
        webStream[Symbol.asyncIterator] = () => toAsyncIterable(webStream);
    }
    if (!webStream.values) {
        webStream.values = () => toAsyncIterable(webStream);
    }
}
function toAsyncIterable(stream) {
    return tslib.__asyncGenerator(this, arguments, function* toAsyncIterable_1() {
        const reader = stream.getReader();
        try {
            while (true) {
                const { value, done } = yield tslib.__await(reader.read());
                if (done) {
                    return yield tslib.__await(void 0);
                }
                yield yield tslib.__await(value);
            }
        }
        finally {
            const cancelPromise = reader.cancel();
            reader.releaseLock();
            yield tslib.__await(cancelPromise);
        }
    });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
async function getOaiSSEs(response, toEvent) {
    const stringStream = await getStream(response);
    const eventStream = coreSse.createSseStream(stringStream);
    const jsonParser = new TransformStream({
        transform: async (chunk, controller) => {
            if (chunk.data === "[DONE]") {
                return;
            }
            controller.enqueue(toEvent(wrapError(() => JSON.parse(chunk.data), "Error parsing an event. See 'cause' for more details")));
        },
    });
    /** TODO: remove these polyfills once all supported runtimes support them */
    return polyfillStream(eventStream.pipeThrough(jsonParser));
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function getContentFilterResultsForPrompt({ prompt_annotations, prompt_filter_results, }) {
    var _a;
    const res = prompt_filter_results !== null && prompt_filter_results !== void 0 ? prompt_filter_results : prompt_annotations;
    return ((_a = res === null || res === void 0 ? void 0 : res.map((_a) => {
        var { content_filter_results } = _a, rest = tslib.__rest(_a, ["content_filter_results"]);
        return (Object.assign(Object.assign({}, camelCaseKeys(rest)), { contentFilterResults: parseContentFilterResultDetailsForPromptOutput(content_filter_results) }));
    })) !== null && _a !== void 0 ? _a : []);
}
function getCompletionsResult(body) {
    const { created, choices, prompt_filter_results, prompt_annotations } = body, rest = tslib.__rest(body, ["created", "choices", "prompt_filter_results", "prompt_annotations"]);
    return Object.assign(Object.assign({}, camelCaseKeys(rest)), { created: new Date(created), promptFilterResults: getContentFilterResultsForPrompt({
            prompt_filter_results,
            prompt_annotations,
        }), choices: choices.map((_a) => {
            var { content_filter_results } = _a, choice = tslib.__rest(_a, ["content_filter_results"]);
            return (Object.assign(Object.assign({}, camelCaseKeys(choice)), (!content_filter_results
                ? {}
                : {
                    contentFilterResults: parseContentFilterResultsForChoiceOutput(content_filter_results),
                })));
        }) });
}
function getChatCompletionsResult(body) {
    const { created, choices, prompt_filter_results, prompt_annotations } = body, rest = tslib.__rest(body, ["created", "choices", "prompt_filter_results", "prompt_annotations"]);
    return Object.assign(Object.assign({}, camelCaseKeys(rest)), { created: new Date(created), promptFilterResults: getContentFilterResultsForPrompt({
            prompt_filter_results,
            prompt_annotations,
        }), choices: !choices
            ? []
            : choices.map((_a) => {
                var { content_filter_results, delta, message } = _a, choice = tslib.__rest(_a, ["content_filter_results", "delta", "message"]);
                return (Object.assign(Object.assign(Object.assign(Object.assign({}, camelCaseKeys(choice)), (!delta ? {} : { delta: parseMessage(delta) })), (!message ? {} : { message: parseMessage(message) })), (!content_filter_results
                    ? {}
                    : {
                        contentFilterResults: parseContentFilterResultsForChoiceOutput(content_filter_results),
                    })));
            }) });
}
function parseMessage(message) {
    const { context, tool_calls } = message, rest = tslib.__rest(message, ["context", "tool_calls"]);
    return Object.assign(Object.assign(Object.assign({}, camelCaseKeys(rest)), { toolCalls: tool_calls !== null && tool_calls !== void 0 ? tool_calls : [] }), (!context
        ? {}
        : {
            context: Object.assign({}, (!context.messages
                ? {}
                : {
                    messages: context.messages.map(parseMessage),
                })),
        }));
}
function parseError(error) {
    var _a;
    return {
        error: Object.assign(Object.assign({}, error), { details: (_a = error["details"]) !== null && _a !== void 0 ? _a : [] }),
    };
}
function parseContentFilterResultDetailsForPromptOutput(_a = {}) {
    var { error } = _a, rest = tslib.__rest(_a, ["error"]);
    return error ? parseError(error) : camelCaseKeys(rest);
}
function parseContentFilterResultsForChoiceOutput(_a = {}) {
    var { error } = _a, rest = tslib.__rest(_a, ["error"]);
    return error ? parseError(error) : camelCaseKeys(rest);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function _getCompletionsSend(context, deploymentId, body, options = { requestOptions: {} }) {
    return context.path("/deployments/{deploymentId}/completions", deploymentId).post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters(options)), { body: {
            prompt: body["prompt"],
            max_tokens: body["maxTokens"],
            temperature: body["temperature"],
            top_p: body["topP"],
            logit_bias: body["logitBias"],
            user: body["user"],
            n: body["n"],
            logprobs: body["logprobs"],
            echo: body["echo"],
            stop: body["stop"],
            presence_penalty: body["presencePenalty"],
            frequency_penalty: body["frequencyPenalty"],
            best_of: body["bestOf"],
            stream: body["stream"],
            model: body["model"],
        } }));
}
/**
 * Gets completions for the provided input prompts.
 * Completions support a wide variety of tasks and generate text that continues from or "completes"
 * provided prompt data.
 */
async function getCompletions(context, deploymentName, prompt, options = { requestOptions: {} }) {
    const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const response = await _getCompletionsSend(context, deploymentName, Object.assign({ prompt }, rest), { abortSignal, onResponse, requestOptions, tracingOptions });
    return _getCompletionsDeserialize(response);
}
async function _getCompletionsDeserialize(result) {
    if (isUnexpected(result)) {
        throw result.body.error;
    }
    return getCompletionsResult(result.body);
}
async function _getChatCompletionsDeserialize(result) {
    if (isUnexpected(result)) {
        throw result.body.error;
    }
    return getChatCompletionsResult(result.body);
}
function _getImageGenerationsSend(context, deploymentId, body, options = { requestOptions: {} }) {
    return context.path("/deployments/{deploymentId}/images/generations", deploymentId).post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters(options)), { body: {
            model: body["model"],
            prompt: body["prompt"],
            n: body["n"],
            size: body["size"],
            response_format: body["responseFormat"],
            quality: body["quality"],
            style: body["style"],
            user: body["user"],
        } }));
}
async function _getImageGenerationsDeserialize(result) {
    if (isUnexpected(result)) {
        throw result.body.error;
    }
    return {
        created: new Date(result.body["created"]),
        data: result.body["data"].map((p) => ({
            url: p["url"],
            base64Data: p["b64_json"],
            revisedPrompt: p["revised_prompt"],
        })),
    };
}
function _getEmbeddingsSend(context, deploymentId, body, options = { requestOptions: {} }) {
    return context.path("/deployments/{deploymentId}/embeddings", deploymentId).post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters(options)), { body: { user: body["user"], model: body["model"], input: body["input"] } }));
}
async function _getEmbeddingsDeserialize(result) {
    if (isUnexpected(result)) {
        throw result.body.error;
    }
    return {
        data: result.body["data"].map((p) => ({
            embedding: p["embedding"],
            index: p["index"],
        })),
        usage: {
            promptTokens: result.body.usage["prompt_tokens"],
            totalTokens: result.body.usage["total_tokens"],
        },
    };
}
/** Return the embeddings for a given prompt. */
async function getEmbeddings(context, deploymentId, body, options = { requestOptions: {} }) {
    const result = await _getEmbeddingsSend(context, deploymentId, body, options);
    return _getEmbeddingsDeserialize(result);
}
function streamCompletions(context, deploymentName, prompt, options = { requestOptions: {} }) {
    const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const response = _getCompletionsSend(context, deploymentName, Object.assign(Object.assign({ prompt }, rest), { stream: true }), { abortSignal, onResponse, requestOptions, tracingOptions });
    return getOaiSSEs(response, getCompletionsResult);
}
async function getImages(context, deploymentName, prompt, options = { requestOptions: {} }) {
    const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const result = await _getImageGenerationsSend(context, deploymentName, Object.assign({ prompt }, rest), { abortSignal, onResponse, requestOptions, tracingOptions });
    return _getImageGenerationsDeserialize(result);
}
function streamChatCompletions(context, deploymentName, messages, options = { requestOptions: {} }) {
    const response = _getChatCompletionsSendX(context, deploymentName, messages, Object.assign(Object.assign({}, options), { stream: true }));
    return getOaiSSEs(response, getChatCompletionsResult);
}
/**
 * Gets chat completions for the provided chat messages.
 * Completions support a wide variety of tasks and generate text that continues from or "completes"
 * provided prompt data.
 */
async function getChatCompletions(context, deploymentName, messages, options = { requestOptions: {} }) {
    const result = await _getChatCompletionsSendX(context, deploymentName, messages, options);
    return _getChatCompletionsDeserialize(result);
}
async function getAudioTranslation(context, deploymentName, fileContent, formatOrOptions, inputOptions) {
    const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : (typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {});
    const response_format = typeof formatOrOptions === "string" ? formatOrOptions : undefined;
    const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const { body, status } = await context
        .pathUnchecked("deployments/{deploymentName}/audio/translations", deploymentName)
        .post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters({
        abortSignal,
        onResponse,
        tracingOptions,
        requestOptions,
    })), { contentType: "multipart/form-data", body: Object.assign(Object.assign(Object.assign({}, snakeCaseKeys(rest)), { file: coreRestPipeline.createFile(fileContent, "placeholder.wav") }), (response_format ? { response_format } : {})) }));
    if (status !== "200") {
        throw body.error;
    }
    return response_format !== "verbose_json"
        ? body
        : camelCaseKeys(body);
}
async function getAudioTranscription(context, deploymentName, fileContent, formatOrOptions, inputOptions) {
    const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : (typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {});
    const response_format = typeof formatOrOptions === "string" ? formatOrOptions : undefined;
    const { abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const { body, status } = await context
        .pathUnchecked("deployments/{deploymentName}/audio/transcriptions", deploymentName)
        .post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters({
        abortSignal,
        onResponse,
        tracingOptions,
        requestOptions,
    })), { contentType: "multipart/form-data", body: Object.assign(Object.assign(Object.assign({}, snakeCaseKeys(rest)), { file: coreRestPipeline.createFile(fileContent, "placeholder.wav") }), (response_format ? { response_format } : {})) }));
    if (status !== "200") {
        throw body.error;
    }
    return response_format !== "verbose_json"
        ? body
        : camelCaseKeys(body);
}
function _getChatCompletionsSendX(context, deploymentName, messages, options = { requestOptions: {} }) {
    const { azureExtensionOptions, abortSignal, onResponse, requestOptions, tracingOptions } = options, rest = tslib.__rest(options, ["azureExtensionOptions", "abortSignal", "onResponse", "requestOptions", "tracingOptions"]);
    const coreOptions = {
        abortSignal,
        onResponse,
        requestOptions,
        tracingOptions,
    };
    const azure = Object.assign(Object.assign({}, (!(azureExtensionOptions === null || azureExtensionOptions === void 0 ? void 0 : azureExtensionOptions.extensions)
        ? {}
        : { dataSources: azureExtensionOptions.extensions })), (!(azureExtensionOptions === null || azureExtensionOptions === void 0 ? void 0 : azureExtensionOptions.enhancements)
        ? {}
        : { enhancements: azureExtensionOptions.enhancements }));
    return azure.dataSources || azure.enhancements
        ? _getChatCompletionsWithAzureExtensionsSend(context, deploymentName, Object.assign(Object.assign({ messages }, rest), azure), coreOptions)
        : _getChatCompletionsSend(context, deploymentName, Object.assign({ messages }, rest), coreOptions);
}
function _getChatCompletionsWithAzureExtensionsSend(context, deploymentName, body, options = { requestOptions: {} }) {
    const { functions, functionCall, messages, dataSources } = body, rest = tslib.__rest(body, ["functions", "functionCall", "messages", "dataSources"]);
    return context
        .path("/deployments/{deploymentId}/extensions/chat/completions", deploymentName)
        .post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters(options)), { body: Object.assign(Object.assign({}, snakeCaseKeys(rest)), { dataSources: dataSources === null || dataSources === void 0 ? void 0 : dataSources.map((_a) => {
                var { type } = _a, opts = tslib.__rest(_a, ["type"]);
                return ({ type, parameters: opts });
            }), functions, function_call: functionCall, messages: messages.map(serializeChatRequestMessage) }) }));
}
function serializeChatRequestMessage(message) {
    if (message.content === undefined) {
        message.content = null;
    }
    switch (message.role) {
        case "assistant": {
            const { functionCall, toolCalls } = message, rest = tslib.__rest(message, ["functionCall", "toolCalls"]);
            return Object.assign(Object.assign(Object.assign({}, snakeCaseKeys(rest)), (!toolCalls || toolCalls.length === 0 ? {} : { tool_calls: toolCalls })), (functionCall ? { function_call: functionCall } : {}));
        }
        default: {
            return snakeCaseKeys(message);
        }
    }
}
function _getChatCompletionsSend(context, deploymentName, body, options = { requestOptions: {} }) {
    const { functions, functionCall, messages } = body, rest = tslib.__rest(body, ["functions", "functionCall", "messages"]);
    return context.path("/deployments/{deploymentId}/chat/completions", deploymentName).post(Object.assign(Object.assign({}, coreClient.operationOptionsToRequestParameters(options)), { body: Object.assign(Object.assign({}, snakeCaseKeys(rest)), { functions, function_call: functionCall, messages: messages.map(serializeChatRequestMessage) }) }));
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function nonAzurePolicy() {
    const policy = {
        name: "openAiEndpoint",
        sendRequest: (request, next) => {
            const obj = new URL(request.url);
            const parts = obj.pathname.split("/");
            switch (parts[parts.length - 1]) {
                case "completions":
                    if (parts[parts.length - 2] === "chat") {
                        obj.pathname = `${parts[1]}/chat/completions`;
                    }
                    else {
                        obj.pathname = `${parts[1]}/completions`;
                    }
                    break;
                case "embeddings":
                    obj.pathname = `${parts[1]}/embeddings`;
                    break;
                case "generations":
                    if (parts[parts.length - 2] === "images") {
                        obj.pathname = `${parts[1]}/images/generations`;
                    }
                    else {
                        throw new Error("Unexpected path");
                    }
                    break;
                case "transcriptions":
                    obj.pathname = `${parts[1]}/audio/transcriptions`;
                    break;
                case "translations":
                    obj.pathname = `${parts[1]}/audio/translations`;
                    break;
            }
            obj.searchParams.delete("api-version");
            request.url = obj.toString();
            return next(request);
        },
    };
    return policy;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A client for interacting with Azure OpenAI.
 *
 * The client needs the endpoint of an OpenAI resource and an authentication
 * method such as an API key or token. The API key and endpoint can be found in
 * the OpenAI resource page. They will be located in the resource's Keys and Endpoint page.
 *
 * ### Examples for authentication:
 *
 * #### API Key
 *
 * ```js
 * import { OpenAIClient } from "@azure/openai";
 * import { AzureKeyCredential } from "@azure/core-auth";
 *
 * const endpoint = "<azure endpoint>";
 * const credential = new AzureKeyCredential("<api key>");
 *
 * const client = new OpenAIClient(endpoint, credential);
 * ```
 *
 * #### Azure Active Directory
 *
 * ```js
 * import { OpenAIClient } from "@azure/openai";
 * import { DefaultAzureCredential } from "@azure/identity";
 *
 * const endpoint = "<azure endpoint>";
 * const credential = new DefaultAzureCredential();
 *
 * const client = new OpenAIClient(endpoint, credential);
 * ```
 */
class OpenAIClient {
    constructor(endpointOrOpenAiKey, credOrOptions = {}, options = {}) {
        var _a, _b;
        this._isAzure = false;
        let opts;
        let endpoint;
        let cred;
        if (isCred(credOrOptions)) {
            endpoint = endpointOrOpenAiKey;
            cred = credOrOptions;
            opts = options;
            this._isAzure = true;
        }
        else {
            endpoint = createOpenAIEndpoint(1);
            cred = endpointOrOpenAiKey;
            const { credentials } = credOrOptions, restOpts = tslib.__rest(credOrOptions, ["credentials"]);
            opts = Object.assign({ credentials: {
                    apiKeyHeaderName: (_a = credentials === null || credentials === void 0 ? void 0 : credentials.apiKeyHeaderName) !== null && _a !== void 0 ? _a : "Authorization",
                    scopes: credentials === null || credentials === void 0 ? void 0 : credentials.scopes,
                } }, restOpts);
        }
        this._client = createOpenAI(endpoint, cred, Object.assign(Object.assign({}, opts), (this._isAzure
            ? {}
            : {
                additionalPolicies: [
                    ...((_b = opts.additionalPolicies) !== null && _b !== void 0 ? _b : []),
                    {
                        position: "perCall",
                        policy: nonAzurePolicy(),
                    },
                ],
            })));
    }
    /**
     * Returns textual completions as configured for a given prompt.
     * @param deploymentName - Specifies either the model deployment name (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
     * @param prompt - The prompt to use for this request.
     * @param options - The options for this completions request.
     * @returns The completions for the given prompt.
     */
    getCompletions(deploymentName, prompt, options = { requestOptions: {} }) {
        this.setModel(deploymentName, options);
        return getCompletions(this._client, deploymentName, prompt, options);
    }
    /**
     * Lists the completions tokens as they become available for a given prompt.
     * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
     * @param prompt - The prompt to use for this request.
     * @param options - The completions options for this completions request.
     * @returns An asynchronous iterable of completions tokens.
     */
    streamCompletions(deploymentName, prompt, options = {}) {
        this.setModel(deploymentName, options);
        return streamCompletions(this._client, deploymentName, prompt, options);
    }
    /**
     * Return the computed embeddings for a given prompt.
     * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
     * @param input - The prompt to use for this request.
     * @param options - The embeddings options for this embeddings request.
     * @returns The embeddings for the given prompt.
     */
    getEmbeddings(deploymentName, input, options = { requestOptions: {} }) {
        this.setModel(deploymentName, options);
        return getEmbeddings(this._client, deploymentName, Object.assign({ input }, options), options);
    }
    /**
     * Get chat completions for provided chat context messages.
     * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
     * @param messages - The chat context messages to use for this request.
     * @param options - The chat completions options for this completions request.
     * @returns The chat completions for the given chat context messages.
     */
    getChatCompletions(deploymentName, messages, options = { requestOptions: {} }) {
        this.setModel(deploymentName, options);
        return getChatCompletions(this._client, deploymentName, messages, options);
    }
    /**
     * Lists the chat completions tokens as they become available for a chat context.
     * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
     * @param messages - The chat context messages to use for this request.
     * @param options - The chat completions options for this chat completions request.
     * @returns An asynchronous iterable of chat completions tokens.
     */
    streamChatCompletions(deploymentName, messages, options = { requestOptions: {} }) {
        this.setModel(deploymentName, options);
        return streamChatCompletions(this._client, deploymentName, messages, options);
    }
    /**
     * Starts the generation of a batch of images from a text caption
     * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
     * @param prompt - The prompt to use for this request.
     * @param options - The options for this image request.
     * @returns The image generation response (containing url or base64 data).
     */
    getImages(deploymentName, prompt, options = { requestOptions: {} }) {
        this.setModel(deploymentName, options);
        return getImages(this._client, deploymentName, prompt, options);
    }
    async getAudioTranscription(deploymentName, fileContent, formatOrOptions, inputOptions) {
        const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : (typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {});
        const response_format = typeof formatOrOptions === "string" ? formatOrOptions : undefined;
        this.setModel(deploymentName, options);
        if (response_format === undefined) {
            return getAudioTranscription(this._client, deploymentName, fileContent, options);
        }
        return getAudioTranscription(this._client, deploymentName, fileContent, response_format, options);
    }
    async getAudioTranslation(deploymentName, fileContent, formatOrOptions, inputOptions) {
        const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : (typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {});
        const response_format = typeof formatOrOptions === "string" ? formatOrOptions : undefined;
        this.setModel(deploymentName, options);
        if (response_format === undefined) {
            return getAudioTranslation(this._client, deploymentName, fileContent, options);
        }
        return getAudioTranslation(this._client, deploymentName, fileContent, response_format, options);
    }
    setModel(model, options) {
        if (!this._isAzure) {
            options.model = model;
        }
    }
}
function createOpenAIEndpoint(version) {
    return `https://api.openai.com/v${version}`;
}
function isCred(cred) {
    return coreAuth.isTokenCredential(cred) || cred.key !== undefined;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The OpenAIKeyCredential class represents an OpenAI API key
 * and is used to authenticate into an OpenAI client for
 * an OpenAI endpoint.
 */
class OpenAIKeyCredential {
    /**
     * Create an instance of an AzureKeyCredential for use
     * with a service client.
     *
     * @param key - The initial value of the key to use in authentication
     */
    constructor(key) {
        if (!key) {
            throw new Error("key must be a non-empty string");
        }
        this._key = createKey(key);
    }
    /**
     * The value of the key to be used in authentication
     */
    get key() {
        return this._key;
    }
    /**
     * Change the value of the key.
     *
     * Updates will take effect upon the next request after
     * updating the key value.
     *
     * @param newKey - The new key value to be used
     */
    update(newKey) {
        this._key = createKey(newKey);
    }
}
function createKey(key) {
    return key.startsWith("Bearer ") ? key : `Bearer ${key}`;
}

Object.defineProperty(exports, "AzureKeyCredential", {
    enumerable: true,
    get: function () { return coreAuth.AzureKeyCredential; }
});
exports.OpenAIClient = OpenAIClient;
exports.OpenAIKeyCredential = OpenAIKeyCredential;
//# sourceMappingURL=index.cjs.map
