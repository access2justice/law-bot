{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../src/api/util.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAgClC,MAAM,UAAU,SAAS,CAAI,CAAU,EAAE,OAAe;IACtD,IAAI,CAAC;QACH,MAAM,MAAM,GAAG,CAAC,EAAE,CAAC;QACnB,OAAO,MAAM,CAAC;IAChB,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,IAAI,KAAK,CAAC,GAAG,OAAO,KAAK,KAAK,EAAE,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;IACrD,CAAC;AACH,CAAC;AAED,MAAM,UAAU,aAAa,CAAgC,GAAM;IACjE,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,GAAG;QAAE,OAAO,GAAG,CAAC;IAChD,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;QACvB,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CACnB,aAAa,CACX,CAAC,CACF,CACkB,CAAC;IACxB,CAAC;SAAM,CAAC;QACN,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;YACnC,MAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;YACvB,MAAM,MAAM,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC;YAChC,IAAI,MAAM,KAAK,GAAG,EAAE,CAAC;gBACnB,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;YAClB,CAAC;YACA,GAAG,CAAC,MAAM,CAAyB;gBAClC,OAAO,GAAG,CAAC,MAAM,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QACnE,CAAC;QACD,OAAO,GAAG,CAAC;IACb,CAAC;AACH,CAAC;AAED,MAAM,UAAU,aAAa,CAAgC,GAAM;IACjE,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,GAAG;QAAE,OAAO,GAAG,CAAC;IAChD,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;QACvB,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CACnB,aAAa,CACX,CAAC,CACF,CACkB,CAAC;IACxB,CAAC;SAAM,CAAC;QACN,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;YACnC,MAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;YACvB,MAAM,MAAM,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC;YAChC,IAAI,MAAM,KAAK,GAAG,EAAE,CAAC;gBACnB,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;YAClB,CAAC;YACA,GAAG,CAAC,MAAM,CAAyB;gBAClC,OAAO,GAAG,CAAC,MAAM,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QACnE,CAAC;QACD,OAAO,GAAG,CAAC;IACb,CAAC;AACH,CAAC;AAED,SAAS,WAAW,CAAmB,GAAM;IAC3C,OAAO,GAAG;SACP,WAAW,EAAE;SACb,OAAO,CAAC,aAAa,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAiB,CAAC;AAC7F,CAAC;AAED,SAAS,WAAW,CAAmB,GAAM;IAC3C,OAAO,GAAG;SACP,OAAO,CAAC,UAAU,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,KAAK,CAAC,WAAW,EAAE,EAAE,CAAC;SACzD,OAAO,CAAC,IAAI,EAAE,EAAE,CAAiB,CAAC;AACvC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * THIS IS AN AUTO-GENERATED FILE - DO NOT EDIT!\n *\n * Any changes you make here may be lost.\n *\n * If you need to make changes, please do so in the original source file, \\{project-root\\}/sources/custom\n */\n\ntype CamelCase<S extends string> = S extends `${infer P1}_${infer P2}`\n  ? `${Lowercase<P1>}${Capitalize<CamelCase<P2>>}`\n  : Lowercase<S>;\ntype SnakeCase<S extends string> = S extends `${infer T}${infer U}`\n  ? `${T extends Capitalize<T> ? \"_\" : \"\"}${Lowercase<T>}${SnakeCase<U>}`\n  : S;\n\ntype MapCamelCaseKeysOverCollections<T> =\n  T extends Array<infer X> ? Array<MapCamelCaseKeysOverCollections<X>> : CamelCaseKeys<T>;\ntype MapSnakeCaseKeysOverCollections<T> =\n  T extends Array<infer X>\n    ? Array<MapSnakeCaseKeysOverCollections<X>>\n    : // : T extends (infer X | infer Y)\n      // ? MapSnakeCaseKeysOverCollections<X> | MapSnakeCaseKeysOverCollections<Y>\n      SnakeCaseKeys<T>;\ntype CamelCaseKeys<T> = {\n  [K in keyof T as CamelCase<K & string>]: MapCamelCaseKeysOverCollections<T[K]>;\n};\nexport type SnakeCaseKeys<T> = {\n  [K in keyof T as SnakeCase<K & string>]: MapSnakeCaseKeysOverCollections<T[K]>;\n};\n\nexport function wrapError<T>(f: () => T, message: string): T {\n  try {\n    const result = f();\n    return result;\n  } catch (cause) {\n    throw new Error(`${message}: ${cause}`, { cause });\n  }\n}\n\nexport function camelCaseKeys<O extends Record<string, any>>(obj: O): CamelCaseKeys<O> {\n  if (typeof obj !== \"object\" || !obj) return obj;\n  if (Array.isArray(obj)) {\n    return obj.map((v) =>\n      camelCaseKeys<O extends Array<infer X> ? (X extends Record<string, any> ? X : never) : never>(\n        v,\n      ),\n    ) as CamelCaseKeys<O>;\n  } else {\n    for (const key of Object.keys(obj)) {\n      const value = obj[key];\n      const newKey = tocamelCase(key);\n      if (newKey !== key) {\n        delete obj[key];\n      }\n      (obj[newKey] as Record<string, any>) =\n        typeof obj[newKey] === \"object\" ? camelCaseKeys(value) : value;\n    }\n    return obj;\n  }\n}\n\nexport function snakeCaseKeys<O extends Record<string, any>>(obj: O): SnakeCaseKeys<O> {\n  if (typeof obj !== \"object\" || !obj) return obj;\n  if (Array.isArray(obj)) {\n    return obj.map((v) =>\n      snakeCaseKeys<O extends Array<infer X> ? (X extends Record<string, any> ? X : never) : never>(\n        v,\n      ),\n    ) as SnakeCaseKeys<O>;\n  } else {\n    for (const key of Object.keys(obj)) {\n      const value = obj[key];\n      const newKey = toSnakeCase(key);\n      if (newKey !== key) {\n        delete obj[key];\n      }\n      (obj[newKey] as Record<string, any>) =\n        typeof obj[newKey] === \"object\" ? snakeCaseKeys(value) : value;\n    }\n    return obj;\n  }\n}\n\nfunction tocamelCase<P extends string>(str: P): CamelCase<P> {\n  return str\n    .toLowerCase()\n    .replace(/([_][a-z])/g, (group) => group.toUpperCase().replace(\"_\", \"\")) as CamelCase<P>;\n}\n\nfunction toSnakeCase<P extends string>(str: P): SnakeCase<P> {\n  return str\n    .replace(/([A-Z])/g, (group) => `_${group.toLowerCase()}`)\n    .replace(/^_/, \"\") as SnakeCase<P>;\n}\n"]}