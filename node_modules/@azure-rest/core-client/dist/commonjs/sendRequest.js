"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendRequest = void 0;
const core_rest_pipeline_1 = require("@azure/core-rest-pipeline");
const clientHelpers_js_1 = require("./clientHelpers.js");
const isReadableStream_js_1 = require("./helpers/isReadableStream.js");
/**
 * Helper function to send request used by the client
 * @param method - method to use to send the request
 * @param url - url to send the request to
 * @param pipeline - pipeline with the policies to run when sending the request
 * @param options - request options
 * @param customHttpClient - a custom HttpClient to use when making the request
 * @returns returns and HttpResponse
 */
async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {
    const httpClient = customHttpClient ?? (0, clientHelpers_js_1.getCachedDefaultHttpsClient)();
    const request = buildPipelineRequest(method, url, options);
    const response = await pipeline.sendRequest(httpClient, request);
    const headers = response.headers.toJSON();
    const stream = response.readableStreamBody ?? response.browserStreamBody;
    const parsedBody = options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);
    const body = stream ?? parsedBody;
    if (options?.onResponse) {
        options.onResponse({ ...response, request, rawHeaders: headers, parsedBody });
    }
    return {
        request,
        headers,
        status: `${response.status}`,
        body,
    };
}
exports.sendRequest = sendRequest;
/**
 * Function to determine the request content type
 * @param options - request options InternalRequestParameters
 * @returns returns the content-type
 */
function getRequestContentType(options = {}) {
    return (options.contentType ??
        options.headers?.["content-type"] ??
        getContentType(options.body));
}
/**
 * Function to determine the content-type of a body
 * this is used if an explicit content-type is not provided
 * @param body - body in the request
 * @returns returns the content-type
 */
function getContentType(body) {
    if (ArrayBuffer.isView(body)) {
        return "application/octet-stream";
    }
    if (typeof body === "string") {
        try {
            JSON.parse(body);
            return "application/json; charset=UTF-8";
        }
        catch (error) {
            // If we fail to parse the body, it is not json
            return undefined;
        }
    }
    // By default return json
    return "application/json; charset=UTF-8";
}
function buildPipelineRequest(method, url, options = {}) {
    const requestContentType = getRequestContentType(options);
    const { body, formData } = getRequestBody(options.body, requestContentType);
    const hasContent = body !== undefined || formData !== undefined;
    const headers = (0, core_rest_pipeline_1.createHttpHeaders)({
        ...(options.headers ? options.headers : {}),
        accept: options.accept ?? "application/json",
        ...(hasContent &&
            requestContentType && {
            "content-type": requestContentType,
        }),
    });
    return (0, core_rest_pipeline_1.createPipelineRequest)({
        url,
        method,
        body,
        formData,
        headers,
        allowInsecureConnection: options.allowInsecureConnection,
        tracingOptions: options.tracingOptions,
        abortSignal: options.abortSignal,
        onUploadProgress: options.onUploadProgress,
        onDownloadProgress: options.onDownloadProgress,
        timeout: options.timeout,
        enableBrowserStreams: true,
        streamResponseStatusCodes: options.responseAsStream
            ? new Set([Number.POSITIVE_INFINITY])
            : undefined,
    });
}
/**
 * Prepares the body before sending the request
 */
function getRequestBody(body, contentType = "") {
    if (body === undefined) {
        return { body: undefined };
    }
    if ((0, isReadableStream_js_1.isReadableStream)(body)) {
        return { body };
    }
    const firstType = contentType.split(";")[0];
    if (firstType === "application/json") {
        return { body: JSON.stringify(body) };
    }
    if (ArrayBuffer.isView(body)) {
        return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };
    }
    switch (firstType) {
        case "multipart/form-data":
            return isRLCFormDataInput(body)
                ? { formData: processFormData(body) }
                : { body: JSON.stringify(body) };
        case "text/plain":
            return { body: String(body) };
        default:
            if (typeof body === "string") {
                return { body };
            }
            return { body: JSON.stringify(body) };
    }
}
function isRLCFormDataValue(value) {
    return (typeof value === "string" ||
        value instanceof Uint8Array ||
        // We don't do `instanceof Blob` since we should also accept polyfills of e.g. File in Node.
        typeof value.stream === "function");
}
function isRLCFormDataInput(body) {
    return (body !== undefined &&
        body instanceof Object &&
        Object.values(body).every((value) => isRLCFormDataValue(value) || (Array.isArray(value) && value.every(isRLCFormDataValue))));
}
function processFormDataValue(value) {
    return value instanceof Uint8Array ? (0, core_rest_pipeline_1.createFile)(value, "blob") : value;
}
/**
 * Checks if binary data is in Uint8Array format, if so wrap it in a Blob
 * to send over the wire
 */
function processFormData(formData) {
    const processedFormData = {};
    for (const element in formData) {
        const value = formData[element];
        processedFormData[element] = Array.isArray(value)
            ? value.map(processFormDataValue)
            : processFormDataValue(value);
    }
    return processedFormData;
}
/**
 * Prepares the response body
 */
function getResponseBody(response) {
    // Set the default response type
    const contentType = response.headers.get("content-type") ?? "";
    const firstType = contentType.split(";")[0];
    const bodyToParse = response.bodyAsText ?? "";
    if (firstType === "text/plain") {
        return String(bodyToParse);
    }
    // Default to "application/json" and fallback to string;
    try {
        return bodyToParse ? JSON.parse(bodyToParse) : undefined;
    }
    catch (error) {
        // If we were supposed to get a JSON object and failed to
        // parse, throw a parse error
        if (firstType === "application/json") {
            throw createParseError(response, error);
        }
        // We are not sure how to handle the response so we return it as
        // plain text.
        return String(bodyToParse);
    }
}
function createParseError(response, err) {
    const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
    const errCode = err.code ?? core_rest_pipeline_1.RestError.PARSE_ERROR;
    return new core_rest_pipeline_1.RestError(msg, {
        code: errCode,
        statusCode: response.status,
        request: response.request,
        response: response,
    });
}
//# sourceMappingURL=sendRequest.js.map